<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chain Key - Book</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The constellation book for you.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.png">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../about.html">üëΩConstellation Booküõ∏</a></li><li class="chapter-item affix "><li class="part-title">Journey of the Dream Weaverüîç</li><li class="chapter-item "><a href="../0.JourneytoWeb3/JourneyoftheDreamWeaver.html">Journey of the Dream Weaver</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../0.JourneytoWeb3/NavigatingtheFrontiersofTomorrow.html">Future Has Come</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/ThingsaboutCryptoPunks.html">Things About Crypto Punks</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/WhatistheBlockchain.html">What is Blockchain?</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/WhatisEthereum.html">What is Ethereum?</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/Whathappenedtomyprivacyontheinternet.html">What Happened to My Privacy on the Internet?</a></li><li class="chapter-item "><a href="../0.JourneytoWeb3/Bitcoin.html">Bitcoin</a></li></ol></li><li class="chapter-item "><li class="part-title">Overview of ICüì°</li><li class="chapter-item "><a href="../1.OverviewofIC/1.html">Internet Computer</a></li><li class="chapter-item affix "><li class="part-title">Core Protocol‚≠ê</li><li class="chapter-item "><a href="../2.CoreProtocol/P2Player.html">Peer-to-peer Layer</a></li><li class="chapter-item "><a href="../2.CoreProtocol/IntroductiontoConsensusLayer.html">Consensus Layer</a></li><li class="chapter-item "><a href="../2.CoreProtocol/Messageroutinglayer.html">Message Routing Layer</a></li><li class="chapter-item "><a href="../2.CoreProtocol/executionLayer.html">Execution Layer</a></li><li class="chapter-item "><a href="../2.CoreProtocol/Relatedconcepts/Introduction.html">Related Concepts</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../2.CoreProtocol/Relatedconcepts/HowToPickNumberInConsensus.html">How to Pick the Number of Consensus Committee?</a></li><li class="chapter-item "><a href="../2.CoreProtocol/Relatedconcepts/P2PLayerAndMaliciousAttack.html">How Does P2P Layer Reduce Malicious Attack?</a></li></ol></li><li class="chapter-item "><li class="part-title">Chain Key Cryptographyü™Ñ</li><li class="chapter-item expanded "><a href="../3.ChainKey/Chainkey.html" class="active">Chain Key</a></li><li class="chapter-item "><a href="../3.ChainKey/VETkeys.html">VETKeys</a></li><li class="chapter-item affix "><li class="part-title">Network Nervous System‚öôÔ∏è</li><li class="chapter-item "><a href="../5.NNS/NNS.html">NNS</a></li><li class="chapter-item "><a href="../5.NNS/DAO.html">DAO</a></li><li class="chapter-item "><a href="../5.NNS/EconomicModel.html">Economic Model</a></li><li class="chapter-item affix "><li class="part-title">Canisterü´ô</li><li class="chapter-item "><a href="../4.Canister/Canister.html">Canister</a></li><li class="chapter-item "><a href="../4.Canister/Motoko.html">Motoko</a></li><li class="chapter-item "><a href="../4.Canister/DeployCanister.html">Deploy Your Canister</a></li><li class="chapter-item "><a href="../4.Canister/XRC.html">XCR</a></li><li class="chapter-item affix "><li class="part-title">Blockchain Web ServicesüéØ</li><li class="chapter-item affix "><li class="part-title">Internet Identityüîë</li><li class="chapter-item "><a href="../7.ii/ii.html">Internet Identity</a></li><li class="chapter-item affix "><li class="part-title">Cryptography in ICüîí</li><li class="chapter-item "><div>Threshold BLS Signatures</div></li><li class="chapter-item "><div>Threshold ECDSA Signatures</div></li><li class="chapter-item affix "><li class="part-title">Dapp Developmentüåü</li><li class="chapter-item "><div>Dapp</div></li><li class="spacer"></li><li class="chapter-item affix "><a href="../Glossary.html">Glossary</a></li><li class="chapter-item affix "><a href="../Contributors.html">Contributors</a></li><li class="chapter-item affix "><a href="../References.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NeutronStarDAO/ConstellationBook-English" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                    // Get viewed page store
                    var viewed_key = 'mdbook-viewed';
                    var viewed_map = {};
                    try {
                        var viewed_storage = localStorage.getItem(viewed_key);
                        if (viewed_storage) {
                            viewed_map = JSON.parse(viewed_storage)
                        }
                    } catch (e) { }

                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        
                        // Apply viewed style
                        if (viewed_map[link.pathname]) {
                            link.classList.add('md-viewed')
                        }
                    }); 

                    // Mark viewed after 30s
                    setTimeout(function() {
                        viewed_map[location.pathname] = 1;
                        localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                    }, 30000)
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h2 id="chain-key-cryptography"><a class="header" href="#chain-key-cryptography">Chain-key cryptography</a></h2>
<div class="center-image">
    <img src="assets/Chainkey/image-20230925163327385.jpg" alt="img" style="zoom:67%;" />
</div>
<p>Chain-key cryptography refers to the suite of cryptogenic protocols embedded in Internet Computer lower-level systems. It is the complete set of cryptographic protocols that Internet Computers rely on for runtime operations, including threshold BLS signatures, non-interactive key distribution (NIDKG), non-interactive zero-knowledge proofs (NIZK), Threshold ECDSA signatures, and verifiable encrypted threshold keys (VETKeys).</p>
<p>The most important among these is threshold BLS signatures.</p>
<h2 id="threshold-bls-signatures"><a class="header" href="#threshold-bls-signatures">Threshold BLS signatures</a></h2>
<p>What is threshold BLS signatures? ‡∏Ö ï‚Ä¢Õ°Ã´‚Ä¢ î‡∏Ö</p>
<p>It is the most important, fundamental, and core component of cryptographic key chains. Subnet operations rely on threshold BLS signatures to achieve consensus, provide message authentication to users, generate random beacons on which consensus depends, and sign catch-up packages, among other tasks. </p>
<p>To give an example, a threshold BLS signature is like a &quot;DAO&quot; - any place the subnet needs to sign something requires enough replicas in the subnet to &quot;agree&quot; (sign) before it can go through. When enough replicas agree, that represents consensus and the majority rules.</p>
<p>In traditional asymmetric cryptography, we can generate a public and private key pair; the public key is shared openly while the private key is kept secret. The public key encrypts information, the private key decrypts it. The private key signs information, the public key verifies it. You can learn more about asymmetric cryptography here.</p>
<p>As I explained with <a href="../2.CoreProtocol/IntroductiontoConsensusLayer.html">consensus</a> earlier, when a replica in a subnet creates a block proposal, if everyone agrees the block looks good, they will each sign it with their private key to indicate their approval.</p>
<p>If every replica generated their own key pair, managing the keys would be complex and inefficient ü•≤. Even more importantly, if users wanted to verify chain contents, they'd have to download hundreds of GBs to check everything themselves üò≠. That's just unfriendly.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20231008154331015.png" alt="image-20231008154331015" style="zoom:42%;" />
</div>
<p>To solve this, Dfinity chose a threshold BLS signature scheme to enable subnet signatures.</p>
<h3 id="bls-signatures"><a class="header" href="#bls-signatures">BLS signatures</a></h3>
<p>Let me explain why BLS signatures were chosen.</p>
<p>One reason for using BLS signatures is that the final signature produced by the subnet is unique - for a given public key and message, there is only one valid signature. This unique signature property allows smart contracts to generate unpredictable random numbers: after a smart contract requests a random number, (through one round of consensus) the subnet will generate a signature on a special message, then hash that signature to derive a random number seed, and finally generate the required (pseudo) random number from the seed. </p>
<p>Due to the security properties of BLS signatures, no one can predict or tamper with this randomness.</p>
<p>BLS signatures are quite different from common signature algorithms like RSA and DSA in many ways. </p>
<p>First, BLS signatures are much shorter and more secure. </p>
<p>A signature value only needs one coordinate of an elliptic curve point, around 160 bits is enough. But RSA and DSA signature contain two large integers, usually 320 bits are needed to achieve an equivalent security level, so BLS signatures have a clear advantage in length. The security of BLS signatures does not rely on integer factorization or other mathematical problems, but rather on computationally hard problems on elliptic curves, like the CDH problem. These kinds of problems seem even harder to break today.</p>
<p>Although BLS signatures verification is slower due to requiring some pairing computations, signature generation is very fast, requiring only a simple point multiplication. RSA and DSA are the opposite - signing is slow but verification is fast.</p>
<p>Another advantage of BLS signatures is they don't require maintaining signature state, the signature is fixed as long as the message content doesn't change. But RSA and DSA signature need to save randomness to prevent replay attacks. </p>
<p>Additionally, BLS signatures can be efficiently batch verified together, greatly improving efficiency in many use cases. This is not possible with RSA and DSA.</p>
<p>These properties make BLS signatures very suitable for many blockchain applications with high requirements on signature size and scalability. </p>
<p>The algorithm itself is very elegant and a promising signature algorithm. You can learn more about the cryptographic principles of BLS signatures here.</p>
<p>Most importantly, BLS signatures can split the private key into share fragments and be upgraded to multi-signature or <strong>threshold signature</strong> schemes! Doing this directly with RSA and DSA would be very difficult.</p>
<h3 id="threshold-bls-signatures-1"><a class="header" href="#threshold-bls-signatures-1">Threshold BLS signatures</a></h3>
<p>Splitting the private key into share fragments!</p>
<p>It sounds very sophisticated, but it's actually just an algorithm that allows multiple parties to participate in signing. The private key is split into many shares and given to different people to keep. When signing, enough people (meeting the threshold) have to collaborate to combine the signature fragments into a valid signature.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20231008154650846.png" alt="image-20231008154650846" style="zoom:39%;" />
</div>
<p>In movies, books, and games, there are often quests that require collecting multiple keys, crystals, or other artifacts to unlock the gateway to the final level or obtain the ultimate treasure. Like in Avengers: Infinity War, Thanos had to assemble the six Infinity Stones to wipe out half of all life in the universe. In the Harry Potter series, Voldemort split his soul to create multiple horcruxes, and Harry had to find and destroy them all to fully defeat Voldemort. In Dragon Ball, gathering the seven Dragon Balls allows you to summon the dragon and make a wish.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230818135016018.jpg" alt="img" style="zoom:40%;" />
</div>
<p>Plots involving collecting or combining items to produce some magical effect are common tropes across various media.</p>
<p>In reality, threshold BLS signatures implement this kind of magic through cryptography. Each person generates a signature fragment using their private key share, and when enough fragments meet the threshold, they can be combined into a complete signature. Even if some replicas (less than one third) in the subnet fail or lose network connectivity, signing can still complete. Yet the public key used to verify the signature is unique!</p>
<p>Although threshold signature schemes existed long before, the Internet Computer is the first blockchain to integrate this technology into the low-level protocol.</p>
<p>Without the full private key, only dispersed key shares, even replicas holding shares can't directly obtain signature results. Enough signature fragments have to be collected to generate the signature. Requiring multiple replicas to jointly confirm operations on the blockchain enhances security and reliability. It becomes very difficult for an adversary to control enough replicas to forge signatures.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20231008154809887.png" alt="image-20231008154809887" style="zoom:35%;" />
</div>
<p>BLS is the only signature scheme that enables a very simple and efficient threshold signing protocol. Replicas holding private key shares can easily generate fragmentary signatures on messages, and reaching the threshold number of fragments allows composing the complete signature for the message. Moreover, the replicas don't need interaction, each one just broadcasts out its fragment. And inheriting excellent genes from BLS, the signature is unique - for a given public key and message, there is only one valid signature. No matter which private key fragments sign, as long as enough fragments are combined, the final signature is always the same.</p>
<p>Threshold BLS signatures are the foundation of the Internet Computer. With threshold signatures, replicas in a subnet can use threshold BLSs to achieve consensus:</p>
<ul>
<li>
<p>When enough replicas in a subnet sign a new block, their fragments can be combined into a complete signature, meaning consensus is reached with the majority ruling. Other replicas can verify the block using the subnet's public key.</p>
</li>
<li>
<p>When enough replicas sign a random beacon, their fragments also make a full signature, meaning the new signature becomes a new random number. As long as the signed message is different each time, the signature result will definitely be different too. And each private key fragment allows other replicas to verify this randomness using the subnet's public key.</p>
</li>
<li>
<p>When enough replicas sign a Merkle tree root, their fragments make a complete signature, meaning most replicas in the subnet have consistent state. Users can verify the output using the subnet's public key.</p>
</li>
</ul>
<p>Additionally, these threshold signatures serve as the source of unpredictable pseudorandomness:</p>
<p>As an unpredictable and unbiasable source of pseudorandomness available to any smart contract, this is a unique capability that enables applications impossible on other blockchains (e.g. NFT lotteries).</p>
<p>Threshold BLS signatures have another critical benefit - users need to ensure messages returned from the subnet haven't been tampered with, otherwise there could be trouble if a hacker swaps them out. </p>
<p>So the subnets sign messages back to users.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230818163340357.jpg" alt="img" style="zoom:30%;" />
</div>
<p>With threshold BLSs, even if some replica nodes fail or go offline, the remaining honest nodes can still reach consensus and sign messages as long as their number meets the threshold. This maintains liveliness and security.</p>
<p>The fragments from honest nodes are sufficient to compose valid signatures that users can verify with the subnet's public key. Threshold signatures provide decentralization, scalability, and antifragility!</p>
<p>As I mentioned earlier - if every replica generated their own key pair, managing all those keys would be complex and inefficient ü•≤. And if different replicas signed each block, for users to verify chain contents they'd have to download hundreds of GBs to check everything themselves üò≠. That's just unfriendly.</p>
<p>But with threshold BLS signatures, it's like each subnet only has &quot;one key pair&quot;. The private key is jointly held by replicas in the subnet, while there is only one corresponding public key for the subnet! Anyone can use the subnet public key to verify content signed by the subnet üëç!</p>
<p>This means verifying chain data no longer requires downloading hundreds of GBs - you can just use a 48 kb subnet public key to independently check any message. Even mobile phones, computers, and IoT devices can verify messages signed by subnets.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230818163244831.png" alt="img" style="zoom:27%;" />
</div>
<p>Similarly, when communication between subnets is needed, Subnet B can use Subnet A's public key to verify messages from Subnet A.</p>
<p>This cross-shard verification enables the Internet Computer to scale horizontally - with enough replicas, unlimited shards (subnets) can be created.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230818175102179.png" alt="img" style="zoom:33%;" />
</div>
<p>Each subnet is like an independent &quot;mini blockchain&quot;, with subnets using public keys to verify communication. Since consensus already happened internally in Subnet A, Subnet B just needs to verify messages from A using its public key. This greatly streamlines cross-shard communication.</p>
<br>
<p>But wait, if every subnet has a public key, won't there be tens of thousands of keys to manage with so many subnets in the future?</p>
<p>No worries üòè. There's the system subnet - the NNS! The NNS Canister has a registry holding every subnet's public key. Just ask the NNS if you need a subnet's key.</p>
<p>And for extra safety, the NNS subnet threshold signs all other subnets' public keys. So you can use the NNS subnet key to verify its signatures on other subnets' keys.</p>
<p>Then cache a few common subnet keys on user devices, and we're good to go üëå. </p>
<div class="center-image">
    <img src="assets/Chainkey/image-20231008155036213.png" alt="image-20231008155036213" style="zoom:50%;" />
</div>
<p>Alright, threshold BLS verification is no problem now.</p>
<p>But this is still far from enough.</p>
<h2 id="nidkg"><a class="header" href="#nidkg">NIDKG</a></h2>
<p>The replicas in a subnet need threshold BLS signatures to operate, so the first step is distributing keys to each replica. However, threshold schemes usually rely on a trusted key generation center to distribute the keys. But in a blockchain, no single replica can be easily trusted as non-malicious.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230820224815507.png" alt="img" style="zoom:30%;" />
</div>
<p>This requires a distributed key generation (DKG) protocol - such protocols had very limited use before, are complex to implement, and inefficient taking a long time just to distribute keys, far from practical.</p>
<p>The main reason is traditional DKGs either assume synchronous networks for communication, or lack robustness, or both require synchrony but aren't robust.</p>
<p>Synchronous communication means if there's even a slight delay in messages, the whole DKG process would fail or be insecure. And no robustness means if any replica crashes during DKG, the whole protocol fails.</p>
<p>But to realize threshold BLSs on a blockchain requires DKG, otherwise it wouldn't be a blockchain! With no choice, Dfinity's masters had to research improving DKG efficiency.</p>
<p>For ordinary people, the complex crypto theory would look like hieroglyphics. Luckily Dfinity's masters each have incredible skills.</p>
<p><a href="https://dfinity.org/">Dfinity</a> has many experienced experts, including computer scientists, cryptographers, researchers, and PhDs from top institutions like ETH Zurich, MIT, Stanford, UCLA, Yale, and more, with many previously at tech giants like Google, Amazon, IBM.</p>
<p>CTO <strong>Jan Camenisch</strong> is a computer scientist, IEEE and IACR fellow, published over 120 highly-cited papers on privacy and crypto, and was an IBM Chief Scientist for 19 years. <strong>Ben Lynn</strong> co-created BLS signatures - the &quot;L&quot; in BLS is for Lynn. He got his PhD from Stanford and worked at Google for 10 years. <strong>Timo Hanke</strong> was a professor of mathematics and cryptography at RWTH Aachen University. In 2013 he created AsicBoost, improving Bitcoin mining efficiency by 20-30%, now a standard for large mining operations.</p>
<p>There's also cryptographic wizard <strong>Jens Groth</strong>, who invented pairing-based NIZKs, pairing-based SNARKs, and sub-logarithmic sized proof systems for Bulletproofs. With a PhD from Aarhus University, he did postdoctoral research at UCLA, became a cryptography professor at UCL, and has published over 50 papers.</p>
<p>Ah yes, <a href="https://medium.com/dfinity/jens-groth-principal-researcher-at-dfinity-receives-the-iacr-test-of-time-award-512bcddceed9">Jens</a> is our protagonist here.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230820221756941.png" alt="img" style="zoom:80%;" />
</div>
<p>No existing DKG could meet the Internet Computer's high standards - it needed one that was secure and robust even on an asynchronous network with many faulty replicas.</p>
<p>To tackle inefficient DKGs, Jens went back to basics and heavily optimized the complex multi-round interaction required in DKG. DKGs use zero knowledge proofs, but normal proofs require multiple rounds of interaction just between two parties, let alone the many replicas in a subnet. And proofs have high computation complexity, needing intricate crypto and protocols, with expensive proof generation and verification.</p>
<p>So master Jens rolled up his sleeves and got to work on the cryptography: inventing efficient non-interactive zero knowledge proofs (NIZKs) that complete proofs without interaction.</p>
<p>With NIZKs, the new DKG gained wings, and soon NIDKG was born!</p>
<p>The novel NIDKG can run on asynchronous networks with great robustness - it keeps operating even if a third of replicas in a subnet fail or crash. Replicas just generate transactions without interacting further with others. The remaining replicas can aggregate transactions to compute the subnet's public key for the threshold scheme. Each replica can also decrypt its own private key share from the transactions.</p>
<p>As Dfinity boasted about their scientific team üëá.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230820231353543.png" alt="img" style="zoom:67%;" />
</div>
<p>The &quot;non-interactive&quot; in NIDKG means replicas don't need interaction. Without multiple communications, each replica just generates its polynomial secrets and NIZK proofs based on the protocol, then broadcasts them out. If interaction was required, complexity scales exponentially with more replicas, messing up the whole subnet. And any replica's slight delay could cause failure across the subnet.</p>
<p>By the way, zero knowledge (ZK) proofs are a cutting-edge cryptography technique that lets you prove something to someone without revealing what it is. Sounds unbelievable right! But it's possible in cryptography. It's like when your girlfriend says &quot;I want to tell you something, but you have to promise me first.&quot; And you ask &quot;What do you need to tell me?&quot; She replies &quot;You have to promise first!&quot;</p>
<p>Besides integrating new tech into the low-level system, Dfinity has also started applying it to other areas recently, building the encrypted utopia Dominic envisions. In 2021 they proposed using ZK proofs for identity on the Internet Computer. And in 2023 the crypto wizards are already planning to add zero knowledge proofs!</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230820230117316.png" alt="img" style="zoom:80%;" />
</div>
<h3 id="the-specific-process"><a class="header" href="#the-specific-process">The Specific Process</a></h3>
<p>Whoops, I rambled too much just now. Been feeling lonely lately, tend to babble on and on when talking. Anyway, let's dive into the NIDKG internals and see how it enables our operation.</p>
<p>After the previous overview, we know NIDKG has each replica independently generate a transaction (dealing) and broadcast it out. The transaction contains the replica's secret encrypted file, NIZK proof of the encryption, and material to generate the subnet's public key. Other replicas receive and verify the NIZK proofs, and once 2/3 of dealings are collected, they can reconstruct the subnet public key and their own private key shares.</p>
<h4 id="public-parameters"><a class="header" href="#public-parameters">Public Parameters</a></h4>
<p>Before starting, the NIDKG protocol needs some public parameters, such as NNS will tell everyone <strong>how many replicas there are in the subnet (n)</strong>, <strong>what the threshold is (t)</strong>, and some parameters that are predetermined, bilinear groups \(G1\) ,\(G2\) ,\(GT\) and generators \(g1\) ,\(g2\) , hash function \(H\) and binary tree height \(Œª\) etc. NNS will also assign each replica a <strong>node ID (node_id)</strong> as the replica's own identity. (<a href="https://github.com/dfinity/ic/blob/master/rs/consensus/src/dkg.rs#L98C25-L98C25">Source code</a> calls it this, I don't know why not call it replica ID üòù, maybe &quot;replica&quot; was coined later ~)</p>
<p>These parameters need to be determined and published before running the protocol.</p>
<br>
<h4 id="generate-key-pairs"><a class="header" href="#generate-key-pairs">Generate Key Pairs</a></h4>
<p>In NIDKG, each replica needs to generate its own public and private key pair. The steps to generate the key pairs are:</p>
<ol>
<li>Choose a random \(x\), uniformly randomly selected from \(Z_{p}\).</li>
<li>Use the chosen \(x\) to compute the public key:</li>
</ol>
<p>$$
y = g_{1}^{x} 
$$</p>
<p>where \(g1\) is a predefined generator of the protocol.</p>
<ol start="3">
<li>Construct a zero knowledge proof \(œÄ\) to prove knowledge of the discrete logarithm \(x\) of \(y\). This uses the standard Schnorr proof for elliptic curve discrete log.</li>
<li>Set the public key to:</li>
</ol>
<p>$$
pk = (y, œÄ_{dlog})
$$</p>
<p>where it contains \(y\) and the proof \(œÄ\).</p>
<ol start="5">
<li>Choose another random \(œÅ\), uniformly randomly selected from \(Z_{p}\).</li>
<li>Use \(œÅ\) and the predefined protocol parameters \(f0, ..., fŒª, h\) to compute the private key:</li>
</ol>
<p>$$
dk\ =\ (g_{1}^œÅ,\ g_{2}^x\ *\ f_{0}^œÅ,\ f_{1}^œÅ,\ ...,\ f_{Œª}^œÅ,\ h^œÅ) 
$$</p>
<p>$$
dk_{0}\ =\ (0,\ dk) 
$$</p>
<p>where the private key \(dk\) is a forward secure private key that can be used to decrypt subsequent ciphertexts.</p>
<ol start="7">
<li>Delete the intermediate temporary variables \(x\), \(œÅ\) used in the computations.</li>
<li>Use the generated public and private key pair (pk, dk) as this replica's key pair.</li>
</ol>
<p>Each replica needs to generate such a key pair (pk, dk).</p>
<br>
<h4 id="generate-dealings"><a class="header" href="#generate-dealings">Generate dealings</a></h4>
<p>The process of generating dealings:</p>
<p><strong>Each replica independently randomly generates a (t-1)-degree polynomial \(a_{i}(x\)).</strong></p>
<p>For example, replica \(i\) generates:</p>
<p>$$
a_{i}(x)\ =\ a_{i0}\ +\ a_{i1}*x\ +\ ...\ +\ a_{i(t-1)}*x^{t-1} 
$$</p>
<p>where when \(x = 0\), the value of the polynomial \(a_{i}(0\)) is a randomly generated secret \(s\). If it is re-distributing keys, the private key share from before is used as the secret \(s\).</p>
<p><strong>The constant \(a_{i0}\) of the polynomial represents the shared secret, \(a_{i1},\ ...,\ a_{it-1}\) are randomly chosen coefficients from \(Z_{p}\):</strong></p>
<p>$$
Set\ a_{i0}\ =\ s\ \ and\ \ pick\ random\ a_{1},\ ...,\ a_{t-1}\ \overset{$}{\leftarrow} Z_{p} 
$$</p>
<p>Then compute all the constant terms \(a_{i0},\ ...,\ a_{i(t-1)}\) of the polynomial \(a_{i}(x\)) corresponding \(g_{2}\) group elements \(A_{i0}\ ...\ A_{i(t-1)}\):</p>
<p>$$
A_{i0}\ =\ g_{2}^{a_{i0}} 
$$</p>
<p>$$
A_{i1} = g_{2}^{a_{i1}} 
$$</p>
<p>$$
... 
$$</p>
<p>$$
A_{i(t-1)} = g_{2}^{a_{i(t-1)}} 
$$</p>
<p>Then put these \(A_{i}\) as public parameters into the dealing \(d\).</p>
<p>So \(A_{i0},\ ...,\ A_{i(t-1)}\) correspond to the coefficients of the Shamir secret sharing polynomial \(a(x\)) used to generate the dealing. They are part of dealing d, used to verify the correctness of the secret sharing.</p>
<p>When the threshold number of dealings are collected, the public polynomial \(a(x\)) of all replicas can be recovered using Lagrangian interpolation, where \(a(0\)) is the public key of the subnet.</p>
<div class="center-image">
<img src="assets/Chainkey/image-20230825213313484.png" alt="img" style="zoom:35%;" /> 
</div>
<p><strong>Replica i computes its secret share \(s_{1},\ ...,\ s_{n}\) of the polynomial \(a_{i}(x\)) using Shamir secret sharing:</strong></p>
<p>$$
s_{i}\ =\ {\textstyle \sum_{k=0}^{t-1}} a_{k}i^{k} \bmod p \ \ \ (k\ =\ 1,...,t-1) 
$$</p>
<p>Then convert \(s_{i}\) to binary:</p>
<p>$$
s_{i}\ =\ {\textstyle \sum_{j=1}^{m}} s_{i,j} B^{j-1} 
$$</p>
<p>Then, we need to encrypt and broadcast the secret share \(s_{i}\) so that other replicas will believe that decrypting the ciphertext gives \(s_{i}\)!</p>
<br>
<p>So we must provide evidence that we can decrypt the ciphertext in the dealing, so other replicas can recover their private key share with enough dealings. We use a multi-recipient forward secure encryption scheme where the ciphertext is publicly verifiable.</p>
<p>The only problem is the plaintext should be partitioned into small chunks, as recipients need to compute discrete logs to extract these chunks. So if the chunks a recipient needs to extract are too large, they will have problems. This requires a non-interactive proof system that can ensure all chunks are moderately sized.</p>
<br>
<p><strong>The secret share \(s_{i}\) is split into multiple small chunks mi, using a forward secure encryption scheme based on bilinear pairings.</strong></p>
<p>Each chunk \(mi\) has a small domain, so it can be brute forced decrypted later. ElGamal encryption is used on each chunk \(mi\).</p>
<p>Before generating the dealing, we already generated a public/private key pair, now we can encrypt the chunks using the public keys of all replicas: \(pk_{i}\ =\ (y_{i},\ œÄ_{i}\)).</p>
<p>Choose m random numbers \(r_{m},\ s_{m}\), uniformly randomly selected from \(Z_{p}\): \(r_{1},\ s_{1},\ ...,\ r_{m},\ s_{m}\ \overset{$}{\leftarrow} \ Z_{p}\).</p>
<p>First compute: \(C_{1,1},\ ...,\ C_{n,m},\ R_{1},S_{1},\ ...,\ R_{m},S_{m}\):
$$
C_{i,j} \ = \ y_i^{r_{j}} \ * \ g_{1}^{s_{i,j}}
$$</p>
<p>$$
Ri \ = \ g_{1}^{ri}
$$</p>
<p>$$
S_{j}\ =\ g_{1}^{s_{j}} 
$$
Then do some computations: (where \(\tau\) denotes epoch):
$$
\tau <em>{ Œª</em> { T + 1 } } ... \tau <em>{ Œª</em> { H } }\ =\ H <em>{ Œª</em> { H } } ( pk <em>{ 1 },\ ...,\ pk</em> { n },\ C <em>{ 1 , 1 },\ ...,\ C</em> { n,m },\ R <em>{ 1 } , S</em> { 1 },\ ...,\ R <em>{ m }, S</em> { m } ,\ \tau )
$$</p>
<p>$$
f\ =\ f(\tau <em>{1}\ ...\ \tau</em> {Œª})
$$</p>
<p>$$
Z_{j}\ =\ f^{r_{j}}h^{s_{j}} \ \ \ (Z_{1},\ ...,\ Z_{m}) 
$$
We can use the same random number \(R\) for all chunks to optimize performance:
$$
r\ = {\textstyle \sum_{m}^{j=1}} r_{j} B^{j-1} \bmod p 
$$</p>
<p>$$
R\ = \ g_{1}^{r} 
$$</p>
<p>The ciphertext C is the collection of encryptions of all chunks \(y_n^{r} \ * \ g_{n}^{s_{n} }\):</p>
<p>$$
C_{1} \ = \ y_1^{r} \ *\ g_{1}^{s_{1}},\ ...,\ C_{n} \ = \ y_n^{r} * \ g_{1}^{s_{n}}
$$</p>
<p>Now the chunked encryption is done.</p>
<br>
<p><strong>Finally construct two NIZK proofs:</strong></p>
<ul>
<li>\(œÄ_share\): Proof that the secret share \(s_{i}\) is a correct Shamir secret sharing, satisfying the polynomial \(a_{i}(x\)).</li>
</ul>
<p>$$ œÄ_{share} \gets Prove_{share}(y_{1},\ ...,\ y_{n},\ A_{0},\ ...,\ A_{t‚àí1},\ R,\ C1,\ ...,\ Cn;\ r,\ s_{1},\ ...,\ s_{n}) $$</p>
<ul>
<li>\(œÄ_chunk\): Proof that each ciphertext chunk is a correct encryption of \(s_{i}\).</li>
</ul>
<p>$$
œÄ_{chunk} \gets Prove_{chunk}(y_{1},\ ...,\ y_{n},\ R_{1},\ ...,\ R_{m},\ C_{1,1},\ ...,\ C_{n,m};\ r_{1},\ ...,\ r_{m},\ s_{1,1},\ ...,\ s_{n,m})
$$</p>
<div class="center-image"> 
<img src="assets/Chainkey/image-20230825213207705.png" alt="img" style="zoom:33%;" /> 
</div>
<p><strong>Replica i packages the encrypted private key share C, polynomial coefficients \(A_{i}\), and two NIZK proofs into a dealing \(d_{i}\).</strong> It broadcasts this dealing \(d_{i}\) to other replicas in the subnet.
$$
d\ =\ \binom{C_{1,1},\ ...,\ C_{n,m},\ R_{1},\ S_{1},\ ...,\ R_{m},\ S_{m}}{Z_{1},\ ...,\ Z_{m},\ A_{0},\ ...,\ A_{t-1},\ œÄ_{share},\ œÄ_{chunk}}
$$</p>
<p>The key to generating a dealing is doing the secret sharing, encryption, and providing NIZK proofs. This process ensures verifiability and security of the dealing.</p>
<br>
<h4 id="verify-dealings"><a class="header" href="#verify-dealings">Verify dealings</a></h4>
<p>When a replica receives a dealing d broadcast by another replica, it can verify the dealing like this:</p>
<p>The key is to verify the correctness of the NIZK proofs, that the plaintext chunks in the ciphertext are correct, and that it finally matches the published share verification key.</p>
<p>Input parameters explained:</p>
<ul>
<li>
<p>Optional \(shvk\) (share verification key), generated during public key aggregation.</p>
</li>
<li>
<p>Threshold t.</p>
</li>
<li>
<p>Public keys of n participants \(pk_{1},\ ...,\ pk_{n}\).</p>
</li>
<li>
<p>Current epoch \(œÑ\).</p>
</li>
<li>
<p>Dealing \(d_{j}\) to verify.</p>
</li>
</ul>
<p><strong>Check dealing format:</strong></p>
<ul>
<li>
<p>Ensure it contains the right components: ciphertext, NIZK proofs, etc.</p>
</li>
<li>
<p>Ensure each component is a valid group element.</p>
</li>
</ul>
<p><strong>If there is \(shvk_{j}\), check if it equals \(A_{j,0}\).</strong></p>
<p><strong>Compute leaf path and epoch \(œÑ\):</strong></p>
<ul>
<li>
<p>Extract hash parameters from ciphertext.</p>
</li>
<li>
<p>Run hash function to compute path \(œÑ\).</p>
</li>
</ul>
<p><strong>Compute f function value:</strong></p>
<ul>
<li>Compute \(f(œÑ1,\ ...,\ œÑŒª\)) according to path \(œÑ\).</li>
</ul>
<p><strong>Verify ciphertext relation with f:</strong></p>
<ul>
<li>Check pairing relation: \(e(g_{1}, Z_{j}) = e(R_{j}, f) ¬∑ e(S_{j}, h\))</li>
</ul>
<p><strong>Verify NIZK proof \(œÄ_share\):</strong></p>
<ul>
<li>Input instance info, run \(œÄ_share\)'s verification algorithm.</li>
</ul>
<p><strong>Verify NIZK proof \(œÄ_chunk\):</strong></p>
<ul>
<li>Input instance info, run \(œÄ_chunk\)'s verification algorithm.</li>
</ul>
<p>If all checks pass, the dealing d is considered valid. Otherwise it is invalid, reject the dealing.</p>
<p>This verification process can be done publicly by all replicas, ensuring verifiability of dealings, i.e. PVSS (Publicly Verifiable Secret Sharing).</p>
<br>
<h4 id="combine-dealings"><a class="header" href="#combine-dealings">Combine dealings</a></h4>
<p>When calling the function to recover the public key by combining dealings, the input parameters are:</p>
<ul>
<li>
<p>Threshold t.</p>
</li>
<li>
<p>Total number of participants n.</p>
</li>
<li>
<p>Index set indicating which dealings I were selected.</p>
</li>
<li>
<p>Validated dealings \(d1,\ ...,\ d\ell\).</p>
</li>
</ul>
<p><strong>Parse dealings:</strong></p>
<p>Each dealing \(d_{j}\) contains: \(A_{j,0},\ ...,\ A_{j,t-1}\).</p>
<p>Where \(A_{j,k} = g_{2}^{a_{j,k} }\), \(a_{j,k}\) is the polynomial coefficient of some replica j. The polynomial generated by each replica is random, like this:</p>
<div class="center-image">
<img src="assets/Chainkey/image-20230825143154446.png" alt="img" style="zoom: 37%;" /> 
</div>
<p>And \(A_{j,k}\) is \(a_{j,k}\) of each replica's polynomial computed as \( g_{2}^{a_{j,k} }\). Like a hash function, knowing \(A_{j,k} = g_{2}^{a_{j,k} }\) does not reveal \(a_{j,k}\). As long as \(a_{j,k}\) is unchanged, \(A_{j,k}\) remains unchanged.</p>
<br>
<p><strong>Multiply \(A_{j,k}\) from each dealing to recover the public polynomial:</strong></p>
<p>Compute the public polynomial's \(A_{0}, ..., A_{t-1}\) of all replicas, for each \(k\ =\ 0,\ ...,\ t-1\):
$$
A <em>{ k } \ =\ \prod</em> { j=1 } ^ { \ell } A <em>{ j , k } ^ { L ^ { I }</em> { i _ { \ell } } ( 0 ) }
$$</p>
<div class="center-image">
<img src="assets/Chainkey/image-20230825214349915.png" alt="img" style="zoom:27%;" />
</div>
<p>This recovers the public polynomial's coefficients \(A_{0}, ..., A_{t-1}\) through interpolation. When \(k=0\), \(A_{0}\) is the public key of the subnet.</p>
<p><strong>Generate public key:</strong></p>
<p>$$
vk = A_{0}
$$</p>
<p><strong>Compute verification key:</strong></p>
<p>$$
shvk_{j}\ =\ \prod_{k=0}^{t-1}A_{k}^{j^{k}} 
$$</p>
<p>If successful, return \((vk, shvk_{1},\ ...,\ shvk_{n}\)).</p>
<p>Then the public key \(vk\) still needs to be verified:</p>
<p>Check parameters \(t,n\) are in valid range: \(1 &lt;= t &lt;= n &lt;= N\)</p>
<p>Check \(vk, shvk_{1}...shvk_{n}\) are all in group \(G2\). Set \(shvk_{0}\) to \(vk\).</p>
<p>Define index set \(J = {0,...,t-1}\).</p>
<p>For \(i\) from \(t\) to \(n\):</p>
<ul>
<li>Check if \(shvk_{i}\) equals:</li>
</ul>
<p>$$
shvk_{i}\ =\ \prod_{j=0}^{t-1}A_{k}^{j^{k}}
$$</p>
<p>That is, check if \(shvk_{i}\) lies on the Lagrangian interpolation polynomial of \(shvk_{0}...shvk_{(t-1)}\).</p>
<p>If all checks pass, then there are no issues. This verifies \(vk\) and \(shvk\) satisfy the public key validity requirements of the threshold BLS signature scheme, ensuring they are a valid public key set that can correctly perform threshold signatures.</p>
<br>
<h4 id="retrieve-private-key"><a class="header" href="#retrieve-private-key">Retrieve Private Key</a></h4>
<p>Finally each replica uses its own decryption key to decrypt and compute its private key share sk from all valid dealings.</p>
<p><strong>Parse input:</strong></p>
<ul>
<li>
<p>Recipient's decryption private key: \(dk_{œÑ'}\).</p>
</li>
<li>
<p>Dealing index set used: \(K\).</p>
</li>
<li>
<p>Dealings: \(d1,\ ...,\ d\ell\).</p>
</li>
<li>
<p>Epoch: \(œÑ\).</p>
</li>
</ul>
<p><strong>Parse each dealing:</strong> Parse each dealing to get its various elements, including \(C_{k,n,m}„ÄÅR_{k,m}„ÄÅS_{k,m}„ÄÅZ_{k,m}\) etc. These elements are in groups \(G1\) and \(G2\). Ensure \(1 ‚â§ i ‚â§ n ‚â§ N\).</p>
<p><strong>Define and compute \(œÑ\):</strong> For each dealing, based on the given \(œÑ\) value, define a series of \(œÑ_{k,1}\) to \( œÑ_{k, Œª_{T} }\), then compute subsequent \(œÑ_{k,Œª_{T+1} } ... œÑ_{k, Œª}\).</p>
<p><strong>Compute intermediate \(f_{k}\):</strong> Use function f to compute intermediate \(f_{k}\) for each dealing's \(œÑ\) value:
$$
f_{k}\ =\ f(\tau_{k,1},\ ...,\ \tau_{k,\lambda }) 
$$
<strong>Derive decryption key:</strong> Based on given key update information \(dk_{œÑ'}\), derive the decryption key \(dk_{œÑ_{k,1},\ ...,\ œÑ_{k, Œª} }\). These decryption keys are in the set \({0, 1}^{Œª} √ó G_{1} √ó G_{2}^{2}\).</p>
<p><strong>Compute \(M_{k,j}\):</strong> For each element of each dealing, use the given algorithm to compute \(M_{k,j}\) values, involving some multiplications and exponentiations:
$$
M_{k,j}\ =\ e(C_{k,i,j},\ g_{2})\ \cdot e(R_{k,j},\ b_{k}^{-1})\ \cdot e(a_{k},\ Z_{k,j})\ \cdot e(S_{k,j},\ e_{k}^{-1}) 
$$
<strong>Brute force search:</strong> For each k and j, use the Baby-Step Giant-Step algorithm to brute force search for a suitable \(s_{k,j}\) value, such that \(M_{k,j}\) equals a specific value:
$$
M_{k,j}\ =\ e(g_{1},\ g_{2})^{s_{k,j}}
$$
<strong>Compute \(s_{k}\):</strong> Use the found \(s_{k, j}\) values to compute part of the private key \(s_{k}\):
$$
s_{k}\ =\ \sum_{j\in J}^{m} s_{k,j}B^{j-1} \bmod p 
$$
<strong>Parse K and compute \(s_{i}\):</strong> Parse set \(K\), compute \(s_{i}\) from all \(s_{k}\) using Lagrangian interpolation, involving previous private key shares and \(s_{k, j}\):
$$
sk\ =\ s_{i}\ =\ \sum_{j\in J}^{\ell} s_{k,j}L_{k}^{K}(0) 
$$
<strong>Return result:</strong> If all steps succeed, erase intermediate computations, return private key share sk.</p>
<br>
<p><strong>Finally, verify the private key share:</strong> Validate secret sharing signature key validity, to verify the private key matches the signature verification parameters.</p>
<p>If sk is an integer in the normal range, and \(shvk\) equals \(g_{2}^{sk}\), then the verification succeeds.</p>
<br>
<p><strong>The key to NIDKG is that zero knowledge proofs make the verification process publicly verifiable, without needing interaction with other replicas to independently judge if a dealing is correct.</strong></p>
<p><strong>Each replica chooses a random secret (random number or private key share from last epoch) to generate a polynomial, then computes the shared secret \(s_{i}\). Finally it chunks \(s_{i}\), encrypts the chunks, builds two zero knowledge proofs, and packages it as a dealing for other replicas to verify. After verification, the public key of the subnet and the replica's own private key share can still be computed through non-interactive methods.</strong></p>
<br>
<h3 id="resharing-protocol"><a class="header" href="#resharing-protocol">Resharing Protocol</a></h3>
<p>After a subnet has generated its public key, if a new public key is generated every time subnet members change, it would be quite troublesome. Also, if the key is only updated when subnet members change, it is not secure enough. Because if over one third of replicas are compromised by hackers in various ways, the whole subnet would be paralyzed. If a hacker first silently compromises one replica, continues to lurk and silently tries to compromise the next replica, until controlling enough replicas, then launches an attack ... </p>
<br>
<p>So to solve these two problems, the resharing protocol can retain the subnet public key, and only reshare the private key share of each replica. This also provides proactive security, periodically refreshing the private key shares of all replicas in the subnet. </p>
<div class="center-image"> 
<img src="assets/Chainkey/image-20230827153152958.png" alt="img" style="zoom:43%;" /> 
</div>
<p>Now let's review:</p>
<p>Assume the old public key \(vk\) has passed public key validation.</p>
<p>In the verification after public key aggregation, it is guaranteed that \(shvk_{1},...,shvk_{n}\) can be derived from \(vk\) and \(shvk_{1},...,shvk_{t-1}\) through Lagrangian interpolation.</p>
<p>That is, \(vk\) and \(shvk_{1},...,shvk_{n}\) satisfy the same \(t-1\) degree polynomial \(a(i\)):</p>
<p>\[</p>
<p>vk\ =\ A <em>{ 0 } \ =\ \prod</em> { j=1 } ^ { \ell } A_ {j,0} ^ {L ^ { I } <em>{ i</em> { \ell } } ( 0 ) } \ = \ g <em>{ 2 } ^ { a</em> { 0 } }</p>
<p>\]</p>
<p>\[</p>
<p>shvk_{ i } = g^{ a( i ) }<em>{ 2 }\ \ \ (i\ =\ 1,\ ...,\ n)\ = A</em>{ i }</p>
<p>\]</p>
<p>For any index set \(I\) containing \(1&lt;=i_{1} &lt; ... &lt; i_{t} &lt;= n \) , we can compute the public key \(vk\) from \(shvk_{i}\) using:</p>
<p>\[</p>
<p>vk\ =\ \prod_{j=1}^{t} shvk_{ i_{ j } } ^ { L^{I}_ {i_{ j } }(0)}</p>
<p>\]</p>
<p>During key resharing, given \(t\) dealings \(d_{1},...,d_{t}\) that correspond to valid \(shvk_{ i_{ 1 } },...,shvk_{ i_{ t } }\) respectively.</p>
<p>When verifying the validity of these dealings, we know:
$$
A <em>{ 1 , 0 } = shvk</em> { i <em>{ 1 } } ,\ ...,\ A</em> { t , 0 } = shvk <em>{ i</em> { t } }
$$
Compute the new public key \(vk'\) from these dealings:
$$
vk' \ = \ A <em>{ 0 } \ = \ \prod</em> { j = 1 } ^ { t } A <em>{ j , 0 } ^ { L ^ { I }</em> { i _ { \ell } } ( 0 ) }
$$
Substitute \( A <em>{ 1 , 0 } = shvk</em> { i <em>{ 1 } },\ ...,\ A</em>{ t , 0 } = shvk <em>{ i</em> { t } } \) into this formula, we get:
$$
vk'\ =\ A <em>{ 0 } \ = \ \prod</em> { j = 1 } ^ { t } shvk <em>{ i</em> { j } } ^ { L ^ { I } <em>{ i</em> { j } } ( 0 ) }
$$</p>
<p>The new \(vk' = A_{0}\), so \(vk' = vk\). Thus the verification keys are perfectly retained.</p>
<br>
<p>So each time after key update, the public polynomial \(a(i\)) plotted looks something like this: the other coefficients of the public polynomial change each time, but each different public polynomial passes through the same point when \(x = 0\).</p>
<div class="center-image"> 
<img src="assets/Chainkey/image-20230825222232664.png" alt="img" style="zoom:25%;" /> 
</div>
<p>This ensures that each NIDKG can recover the same public key. The subnet public key remains unchanged, but the other coefficients of the public polynomial change, thus achieving forward security.</p>
<br>
<h3 id="epochs"><a class="header" href="#epochs">Epochs</a></h3>
<p>First is to ensure security of each replica, making it difficult for hackers to attack. Second is that even if a few minority replicas are attacked, as long as the hacker does not compromise more than one third of replicas at once, the subnet will not be threatened. As long as the hacker does not acquire enough private key shares within one epoch, they cannot pose a threat to the subnet.</p>
<div class="center-image"> 
    <img src="assets/Chainkey/image-20231008155922792.png" alt="image-20231008155922792" style="zoom:40%;" /> 
</div>
<p>Even if the hacker severs node connections, the subnet can purge anomalous nodes by frequently changing private key shares.</p>
<p>When new replicas join the subnet, the resharing protocol is also run to share private key shares with the new replicas.</p>
<br>
<p>So how often should the private keys be changed? Once per epoch, where an epoch contains many consensus rounds, usually 500 rounds (adjustable by the NNS).</p>
<p><a href="https://claude.ai/chat//2.%E6%A0%B8%E5%BF%83%E5%8D%8F%E8%AE%AE/2.%E5%85%B1%E8%AF%86%E5%B1%82.html#%E9%A6%96%E5%85%88%E6%98%AF%E5%87%BA%E5%9D%97%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">As mentioned before</a>, Internet Computer has the concept of &quot;epochs&quot;. The replicas in each subnet change private key shares once per epoch. The concept of epochs comes from the paper <a href="https://eprint.iacr.org/2019/514">Pixel: Multi-signatures for Consensus</a>, co-authored by Dfinity's engineering manager Manu Drijvers, Gregory Neven, Hoeteck Wee and Sergey Gorbunov.</p>
<p>The paper designs an efficient and secure forward secure multi-signature scheme Pixel that can be directly applied to existing blockchains, while bringing significant performance improvements.</p>
<blockquote>
<p>The paper proposes a new forward secure multi-signature scheme Pixel that can be used in PoS blockchains to prevent posterior corruption attacks. This scheme is based on hierarchical identity-based encryption and achieves highly efficient forward secure multi-signatures without relying on a trusted setup. Pixel signatures consist of just two group elements regardless of the number of signers. Verification requires just 3 pairings and 1 exponentiation, supporting non-interactive aggregation. Compared to tree-based forward secure signatures, Pixel provides significant improvements in storage, bandwidth, and verification time. It also compares Pixel to BLS-based signatures, demonstrating that Pixel satisfies both efficiency and forward security.</p>
</blockquote>
<br>
<h2 id="chain-evolution-technology"><a class="header" href="#chain-evolution-technology">Chain Evolution Technology</a></h2>
<p>Two other important parts of chain key cryptography are Summary Blocks and Catch-up Packages (CUPs). Their role is to help subnets smoothly perform on-chain changes and upgrades, which we call Chain-evolution Technology.</p>
<p>What are on-chain changes and upgrades? During operation of a subnet, the replicas in the subnet may increase or leave, and the algorithms and protocols of the replicas also need continuous improvements and optimizations. This requires dynamically adjusting the blockchain state.</p>
<p>If backward compatibility is not considered and protocols are directly upgraded in a subnet, forks are very likely to occur. This is extremely detrimental to decentralized networks. This requires a carefully designed on-chain upgrade mechanism, i.e. chain evolution technology.</p>
<br>
<h3 id="summary-blocks"><a class="header" href="#summary-blocks">Summary Blocks</a></h3>
<p>The first block of each epoch is a Summary Block. It is the beginning of an epoch, serving as a transition between epochs.</p>
<p>It is key to the smooth running of each epoch. The Summary Block records important information about an epoch, such as which replicas have the right to produce blocks, who has the right to validate blocks, who has the right to sign messages, etc. Each epoch has different characteristics, and this information is updated every epoch.</p>
<p>The Summary Block provides base parameters and initialization information for an epoch. With the Summary Block as the cornerstone, the subnet can stably run throughout the entire epoch. It is like rules set before a competition, to let all players clearly understand their positioning and responsibilities.</p>
<p>Summarizing this critical information into Summary Blocks has many benefits:</p>
<ol>
<li>New replicas can quickly sync subnet state, without needing to execute from genesis once.</li>
<li>Key parameters are centrally managed, convenient for on-chain governance and upgrades.</li>
</ol>
<p>It can be seen that Summary Blocks serve as &quot;anchors&quot; in smoothly performing on-chain changes.</p>
<div class="center-image">
<img src="assets/Chainkey/image-20231008160127485.png" alt="image-20231008160127485" style="zoom:80%;" />
</div>
<p>Several very important data fields in each epoch's Summary Block:</p>
<p>The <strong>currentRegistryVersion</strong> determines which replicas comprise the consensus committee for this epoch. The consensus committee will be responsible for all consensus layer activities like block production, validation, finalization, etc. during this epoch.</p>
<p>The <strong>nextRegistryVersion</strong>, each consensus round, the block producer will put the latest registry version number it knows into the proposal (this version number must be no earlier than the block it is extending). This ensures the value of this field in each epoch's Summary Block is always the newest.</p>
<p>The &quot;currentRegistryVersion&quot; of this epoch will become the &quot;currentRegistryVersion&quot; of the next epoch. Similarly, the &quot;currentRegistryVersion&quot; of this epoch also comes from the &quot;nextRegistryVersion&quot; in the previous epoch's Summary Block.</p>
<p>The <strong>currentDealingSets</strong> is the set of threshold signature dealings that determine the threshold signature key used to sign messages this epoch.</p>
<p>The <strong>nextDealingSets</strong> is the set of dealings prepared in the previous epoch, which will be set as the &quot;nextDealingSets&quot; this epoch. The &quot;nextDealingSets&quot; of this epoch will become the &quot;currentDealingSets&quot; of the next epoch.</p>
<p>That is, the NIDKG protocol or key resharing process is carried out every epoch. Assume key resharing occurred in epoch 4, it would be placed in the &quot;nextDealingSets&quot; of the Summary Block in epoch 5, and set as the &quot;currentDealingSets&quot; in epoch 6. Meaning the replicas that shared private key shares in epoch 4 serve as the consensus committee.</p>
<div class="center-image">
<img src="assets/Chainkey/image-20231008160821553.png" alt="image-20231008160821553" style="zoom:67%;" />
</div>
<p>This provides enough time for the replicas in the subnet to run the NIDKG protocol or key resharing. If not enough dealings are collected, the protocol will continue using the dealings from this epoch in the next epoch, to buy more time to generate sufficient dealings.</p>
<p>The <strong>collectDealingParams</strong> describes the parameters of the set of dealings to be collected this epoch. This epoch, the block producers will put these parameters into dealings, then into the blocks in their proposals.</p>
<p>The dealing committee that receives these dealings is determined by the &quot;nextRegistryVersion&quot; in the Summary Block. The members of the &quot;nextRegistryVersion&quot; generate dealings this epoch, then become the consensus committee next epoch, and finally become the random beacon committee two epochs later.</p>
<p><strong>The dealing, consensus, and random beacon committees are different each epoch, with replicas taking turns being responsible for different tasks in each committee. The dealing committee has two epochs to run the NIDKG protocol and prepare their private keys. Next epoch they become the consensus committee, then are responsible for subnet consensus, and finally subnet random beacons.</strong></p>
<div class="center-image">
<img src="assets/Chainkey/image-20231008161307295.png" alt="image-20231008161307295" style="zoom:31%;" />
</div>
<p>Through the current and next registry versions, current and next dealing sets, and dealing collection parameters, a Summary Block for an epoch contains all the rules and configurations the consensus layer needs to follow for the current epoch.</p>
<blockquote>
<p>Note that even if a replica is removed from a subnet, (if possible) it should fulfill an extra epoch of assigned committee duties. For example if it worked in the consensus committee for one epoch, it should go to the random beacon committee for one more epoch before leaving the subnet.</p>
</blockquote>
<br>
<h3 id="catch-up-packages"><a class="header" href="#catch-up-packages">Catch-up Packages</a></h3>
<p>A Catch-up Package (CUP) is a special message containing a snapshot of the current state, allowing replicas to recover to the current state at the start of a new epoch without needing to know past information.</p>
<p>The CUP does not contain the full state of the entire subnet. The CUP only contains the root of the Merkle tree resulting from converting the entire subnet state into a Merkle tree, plus some other critical data.</p>
<div class="center-image">
<img src="assets/Chainkey/image-20230912232811269.png" alt="img" style="zoom:37%;" />
</div>
<h4 id="structure-of-a-cup"><a class="header" href="#structure-of-a-cup">Structure of a CUP</a></h4>
<p>It contains all the key information a replica needs to start working in a new epoch:</p>
<ul>
<li>Digest of the entire replica state (root of the Merkle tree). This is also a snapshot of the entire subnet state.</li>
<li>The Summary Block of the current epoch, containing key information about this epoch.</li>
<li>The first random beacon of the current epoch, which is the random number seed needed to generate new blocks.</li>
<li>Threshold signature of the subnet. This can verify validity and authority of the CUP.</li>
</ul>
<p>The CUP still relies on threshold BLS signatures, which are fundamental to subnet consensus. The replicated state of the entire subnet is several hundred GBs, too large. So we can split the entire subnet state into chunks, then convert into a Merkle tree. We just need to give the root of the Merkle tree to the replicas for a low threshold signature! (*^‚ñΩ^*) </p>
<div class="center-image">
<img src="assets/Chainkey/image-20231008161915908.png" alt="image-20231008161915908" style="zoom:50%;" />
</div>
<p>Generating a CUP requires waiting until the end of the epoch to obtain the complete state information. Then the state is processed into a tree structure, calculating the root as the digest. This greatly reduces message size.</p>
<p>The CUP only contains a digest of the subnet replica state (root of the Merkle tree), not the complete state. Replicas can pull required state from peer replicas in the P2P layer, then combine with the Summary Block and random number seed in the CUP message to reconstruct the state at that time and continue working in the new epoch.</p>
<p>Using a threshold signature ensures there is only one valid CUP each epoch, the subnet public key remains unchanged, so the CUP can be verified by any replica.</p>
<div class="center-image">
<img src="assets/Chainkey/image-20230912232912503.png" alt="img" style="zoom:50%;" />
</div>
<p>It is similar to saving game progress. When restarting the game we can directly load the progress, without needing to replay everything. The CUP saves the current progress state of the blockchain network.</p>
<p>CUPs are also not permanently saved. Each replica only needs to save the latest CUP.</p>
<p>This is undoubtedly an important step for Internet Computer towards being practical and evolvable. It provides a framework for on-chain parameter adjustments, replica migrations, algorithm upgrades, etc.</p>
<br>
<h4 id="the-role-of-catch-up-packages"><a class="header" href="#the-role-of-catch-up-packages">The Role of Catch-Up Packages</a></h4>
<p>Like I mentioned before, when a new replica joins a subnet, it can quickly get up to speed on the subnet's current state thanks to the magic of Catch-Up Packages. Also, if a replica falls way behind the other replicas (maybe it was offline or disconnected from the network for a while), it relies on the Catch-Up Package to catch back up with the latest state.</p>
<p>Subnets don't permanently store every single block forever and ever. They don't need historical blocks for validation or anything. So each replica only keeps blocks from the most recent epoch to stay healthy, and deletes old blocks when they're no longer useful. Once a block gets finalized in consensus, the execution layer can just update the state. The subnet only needs the latest container state - old blocks and old state are kaput.</p>
<p>So whenever a subnet generates a Catch-Up Package, it can take out the trash and delete those old blocks. This gives Internet Computer way higher storage efficiency compared to typical blockchains (which keep every block and state forever).</p>
<p>Also based on Internet Computer's economic model where it uses a reverse Gas thingamajig. If developers don't top up their deployed smart contracts (Canisters) and the Canister runs outta Gas (Cycles), it goes buh-bye for good.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230912233446307.png" alt="img" style="zoom:50%;" />
</div>
<p>Catch-Up Packages also let subnets recover even if most replicas crash. As long as one replica survives, a brand new subnet can rise from the ashes using the Package and the replica's state.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20231008162159112.png" alt="image-20231008162159112" style="zoom:50%;" />
</div>
<p>Subnets can use CUPs to balance their load too. If too many Canisters are installed on a subnet, the NNS can split it into two subnets. Each new subnet keeps truckin' using the Package from the original subnet, with each subnet keeping half of the Canisters.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230913001217267.png" alt="img" style="zoom: 35%;" />
</div>
<p>In each consensus round, one replica in the subnet cooks up a block. Each block contains the latest registry version the block creator downloaded from the NNS. Other replicas only notarize the block if that registry is around.</p>
<p>Within an epoch, all the subnets' replicas run the same replica version. To avoid forks, the replicas gotta switch versions at the same block height. For example, if the replicas find an upgrade is needed in the new version, they start upgrading next epoch.</p>
<p>After consensus is reached on the latest registry version among replicas across all subnets, next step is to switch to the new version. Subnet replicas upgrade protocols to the latest after generating the Package. When a new protocol version is needed, the Summary Block at epoch start will give the heads up; all replicas running the old protocol keep running the consensus protocol until the Summary Block of the next epoch is finalized and the corresponding Package is created; once that Package is good to go the replicas gotta hurry up and upgrade the protocol, install the new version, and keep on truckin' with the full protocol starting from the Package.</p>
<p>During upgrades the subnet can keep processing read queries, but can't process updates, putting Canisters in read-only mode. Afterwards the upgrade itself needs to be installed and the VM (Internet Computer Virtual Machine) restarted to complete the upgrade, so query calls go dark too. Overall, downtime during subnet upgrades is just a few minutes.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20230908180550931.png" alt="img" style="zoom:33%;" />
</div>
<p>This is how each Internet Computer subnet fixes bugs, adds new features, which is the super critical capability allowing Internet Computer to run forever.</p>
<br>
<h2 id="chain-key-tokens"><a class="header" href="#chain-key-tokens">Chain Key Tokens</a></h2>
<p>Canisters are super powerful Wasm virtual containers. Andreas, one of the WebAssembly VM designers and Google senior engineer, also worked on designing Canisters at Dfinity. They're so powerful we can even use Canisters as mini servers!</p>
<p>Knowing how insecure bridge security is, constantly getting hacked.</p>
<p>Well if we can use Canisters as servers, could we run other blockchain nodes on them? üòâ The answer is yesss - this directly brings smart contract capabilities to Bitcoin.</p>
<br>
<p>But Bitcoin and Ethereum use ECDSA for signatures, while Internet Computer uses BLS signatures. Also, we can't directly put private keys in a Canister. If we use a Canister to run other blockchain nodes (like a Bitcoin node), each replica in the subnet would have the same Canister, so we couldn't ensure security of the Bitcoin private key held in the Canister, because if any one replica gets hacked, the Bitcoin private key in the Canister would be leaked.</p>
<p>Of course, no worries, Dfinity crypto experts Jens Groth and Victor Shoup got this. üòè</p>
<p>It's just like threshold BLS signatures, we just need to deploy a threshold ECDSA algorithm in the subnet!</p>
<br>
<p>In traditional ECDSA, there is only one private key that can be used for signing. The idea behind threshold ECDSA signatures is, don't centralize the signing key in one place, but rather split the key across multiple replicas, so no single replica can sign alone, multiple replicas must collaborate to generate a signature. This way even if some individual replicas are compromised, the overall system's signing private key will not be leaked.</p>
<p>To sign, each replica will use its private key share to generate a &quot;signature share&quot;. Then combine all the signature shares from the replicas, and that gives the full signature. When combining the shares, malicious shares from dishonest replicas will be filtered out. Each replica's private key share is only known to itself.</p>
<p>Let's take a simple example, say there are 7 replicas in the subnet, each holding a private key share. Of them 2 replicas may be compromised and dishonest. We set a threshold of at least 5 replicas needing to collaborate to generate a signature.</p>
<p>When a user requests a signature, the 7 replicas each generate a signature share. The 5 honest replicas will generate correct shares, while the 2 dishonest may generate incorrect shares. The system will then choose any 5 of the 7 shares at random to combine, reconstructing the full signature. Since there are only 2 dishonest replicas, when choosing 7 shares there will definitely be 5 from honest ones, so incorrect signature shares can be filtered out, correctly generating the signature.</p>
<p>Dfinity's expert mentors also made threshold ECDSA satisfy multiple properties fitting Internet Computer:</p>
<ul>
<li>Threshold ECDSA is also non-interactive. It can ensure signatures are eventually output even if network communication is unreliable. This means signatures will be returned to users even if some messages are heavily delayed or some replicas temporarily go offline.</li>
<li>The signing phase is very efficient. If preprocessing has prepared auxiliary info, when a user requests a signature, each replica only needs to broadcast minimal info to complete signing, no extra coordination communication needed.</li>
<li>Supports the BIP32 standard, allowing deriving multiple signing keys from a master key.</li>
<li>Under reasonable crypto assumptions, this protocol provides the same level of security as single-point ECDSA. That is, the difficulty of an attacker forging signatures is equivalent to breaking the single-point ECDSA signature scheme.</li>
</ul>
<div class="center-image">
    <img src="assets/Chainkey/1.webp" alt="1" style="zoom:55%;" />
</div>
<p>The benefit of this approach is the attacker has to compromise multiple replicas simultaneously to forge signatures. Even if a small number of replicas are compromised, the &quot;ECDSA private key&quot; will not directly leak, allowing the overall system to continue operating securely. This improves security.</p>
<p>Learn more about ckBTC and ckETH.</p>
<br>
<h2 id="vetkeys"><a class="header" href="#vetkeys">VETKeys</a></h2>
<p>VETKey is a technology that derives decentralized keys via IDs.</p>
<p>By way of threshold signature encryption, replicas within the subnet collaboratively derive the private key corresponding to the ID. But here's the kicker: each replica is left clueless about the final private key. There's no Achilles' heel ‚Äì we're talking about top-notch security here. Even if a few replicas are compromised, the actual private key stays under wraps. Compared to traditional schemes, it's a safer bet as it doesn't rely on a trusted execution environment.</p>
<p>Users can encrypt private data. The replicas then join forces to decrypt the key and deliver it to the user. However, the actual key remains a secret throughout the process. Plus, a single subnet public key (a master key, if you will) can spawn an infinite number of isolated identity keys. This massively simplifies key management. It also paves the way for a variety of end-to-end encrypted applications, such as private chats, confidential payments, key custodian services, and so on.</p>
<p>Let's <a href="https://neutronstardao.github.io/constellation.github.io/3.ChainKey/VETkeys.html">take a closer look at</a> this on-chain key derivation scheme.</p>
<br>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The greatest innovation of the Internet Computer lies in its use of a series of complex cryptographic technologies. It has achieved self-consensus within the subnet, which can be perceived as a type of sharding technology. With chain-key cryptography, secure cross-subnet communication can take place between subnets. As it does not require global consensus across the entire network, the Internet Computer can achieve horizontal scalability by adding more subnets.</p>
<div class="center-image">
    <img src="assets/Chainkey/image-20231008163127289.png" alt="image-20231008163127289" style="zoom:50%;" />
</div>
<p>Hence, the threshold BLS signature is the cryptographic heart that keeps the Internet Computer running, with consensus requiring the threshold BLS signature. A host of other cryptographic technologies revolve around the threshold BLS signature. For instance, the secure distribution of threshold BLS signature keys, secret resharing, on-chain evolution technology, and randomness based on threshold BLS signature form the core protocols of the Internet Computer's foundation. Technologies such as Chain-Key Token and VETKey are advanced applications that indirectly use the threshold BLS signature.</p>
<br>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2.CoreProtocol/Relatedconcepts/P2PLayerAndMaliciousAttack.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../3.ChainKey/VETkeys.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2.CoreProtocol/Relatedconcepts/P2PLayerAndMaliciousAttack.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../3.ChainKey/VETkeys.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "3.ChainKey/Chainkey.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/custom.js"></script>
        <script type="text/javascript" src="../assets/bigPicture.js"></script>


    </body>
</html>
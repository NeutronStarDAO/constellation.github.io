<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The constellation book for you.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.png">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="about.html">üëΩConstellation Booküõ∏</a></li><li class="chapter-item affix "><li class="part-title">Journey of the Dream Weaverüîç</li><li class="chapter-item "><a href="0.JourneytoWeb3/JourneyoftheDreamWeaver.html">Journey of the Dream Weaver</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="0.JourneytoWeb3/NavigatingtheFrontiersofTomorrow.html">Future Has Come</a></li><li class="chapter-item "><a href="0.JourneytoWeb3/ThingsaboutCryptoPunks.html">Things About Crypto Punks</a></li><li class="chapter-item "><a href="0.JourneytoWeb3/WhatistheBlockchain.html">What is Blockchain?</a></li><li class="chapter-item "><a href="0.JourneytoWeb3/WhatisEthereum.html">What is Ethereum?</a></li><li class="chapter-item "><a href="0.JourneytoWeb3/Whathappenedtomyprivacyontheinternet.html">What Happened to My Privacy on the Internet?</a></li><li class="chapter-item "><a href="0.JourneytoWeb3/Bitcoin.html">Bitcoin</a></li></ol></li><li class="chapter-item "><li class="part-title">Overview of ICüì°</li><li class="chapter-item "><a href="1.OverviewofIC/1.html">Internet Computer</a></li><li class="chapter-item "><a href="1.OverviewofIC/ICP=Web3.0.html">ICP = Web 3.0</a></li><li class="chapter-item affix "><li class="part-title">Core Protocol‚≠ê</li><li class="chapter-item "><a href="2.CoreProtocol/P2Player.html">Peer-to-peer Layer</a></li><li class="chapter-item "><a href="2.CoreProtocol/IntroductiontoConsensusLayer.html">Consensus Layer</a></li><li class="chapter-item "><a href="2.CoreProtocol/Messageroutinglayer.html">Message Routing Layer</a></li><li class="chapter-item "><a href="2.CoreProtocol/executionLayer.html">Execution Layer</a></li><li class="chapter-item "><a href="2.CoreProtocol/Relatedconcepts/Introduction.html">Related Concepts</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2.CoreProtocol/Relatedconcepts/HowToPickNumberInConsensus.html">How to Pick the Number of Consensus Committee?</a></li><li class="chapter-item "><a href="2.CoreProtocol/Relatedconcepts/P2PLayerAndMaliciousAttack.html">How Does P2P Layer Reduce Malicious Attack?</a></li></ol></li><li class="chapter-item "><li class="part-title">Chain Key Cryptographyü™Ñ</li><li class="chapter-item "><a href="3.ChainKey/Chainkey.html">Chain Key</a></li><li class="chapter-item "><a href="3.ChainKey/VETkeys.html">VETKeys</a></li><li class="chapter-item affix "><li class="part-title">Network Nervous System‚öôÔ∏è</li><li class="chapter-item "><a href="5.NNS/NNS.html">NNS</a></li><li class="chapter-item "><a href="5.NNS/DAO.html">DAO</a></li><li class="chapter-item "><a href="5.NNS/EconomicModel.html">Economic Model</a></li><li class="chapter-item affix "><li class="part-title">Canisterüß∞</li><li class="chapter-item "><a href="4.Canister/Canister.html">Canister</a></li><li class="chapter-item "><a href="4.Canister/Motoko.html">Motoko</a></li><li class="chapter-item "><a href="4.Canister/DeployCanister.html">Deploy Your Canister</a></li><li class="chapter-item "><a href="4.Canister/XRC.html">XRC</a></li><li class="chapter-item affix "><li class="part-title">Blockchain Web ServicesüéØ</li><li class="chapter-item "><a href="6.InternetServices/RandomNumberOnChain.html">Random Number On Chain</a></li><li class="chapter-item "><a href="6.InternetServices/TEE.html">TEE</a></li><li class="chapter-item affix "><li class="part-title">Internet Identityüîë</li><li class="chapter-item "><a href="7.ii/ii.html">Internet Identity</a></li><li class="chapter-item "><a href="7.ii/pid.html">pid</a></li><li class="chapter-item affix "><li class="part-title">Cryptography in ICüîí</li><li class="chapter-item "><a href="8.CryptographyInIC/BasicCryptography.html">Introduction to basic cryptography</a></li><li class="chapter-item "><a href="8.CryptographyInIC/SecretSharing.html">Secret Sharing</a></li><li class="chapter-item "><a href="8.CryptographyInIC/BLS.html">Threshold BLS Signatures</a></li><li class="chapter-item "><a href="8.CryptographyInIC/HashAlgorithm.html">Hash Algorithm</a></li><li class="chapter-item affix "><li class="part-title">Developing DAppüåü</li><li class="chapter-item "><a href="9.DevelopingDApp/CommonDfxCommands.html">Common dfx Commands</a></li><li class="chapter-item "><a href="9.DevelopingDApp/InstallDevelopmentEnvironment.html">Install Development Environment</a></li><li class="chapter-item "><a href="9.DevelopingDApp/1.GettingStartedwithDApp.html">Getting Started with DApp</a></li><li class="chapter-item "><a href="9.DevelopingDApp/2.DesigningDApp.html">Designing DApp</a></li><li class="chapter-item "><a href="9.DevelopingDApp/3.DevelopingProton.html">Developing Proton</a></li><li class="chapter-item "><a href="9.DevelopingDApp/4.UserModule.html">User Module</a></li><li class="chapter-item "><a href="9.DevelopingDApp/5.PostModule.html">Post Module</a></li><li class="chapter-item "><a href="9.DevelopingDApp/6.FeedModule.html">Feed Module</a></li><li class="chapter-item "><a href="9.DevelopingDApp/7.FetchModule.html">Fetch Module</a></li><li class="chapter-item "><a href="9.DevelopingDApp/8.SharedTypes.html">Shared Types</a></li><li class="chapter-item "><a href="9.DevelopingDApp/9.Completion.html">Completion!</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="Glossary.html">Glossary</a></li><li class="chapter-item affix "><a href="Contributors.html">Contributors</a></li><li class="chapter-item affix "><a href="References.html">References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NeutronStarDAO/ConstellationBook-English" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                    // Get viewed page store
                    var viewed_key = 'mdbook-viewed';
                    var viewed_map = {};
                    try {
                        var viewed_storage = localStorage.getItem(viewed_key);
                        if (viewed_storage) {
                            viewed_map = JSON.parse(viewed_storage)
                        }
                    } catch (e) { }

                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        
                        // Apply viewed style
                        if (viewed_map[link.pathname]) {
                            link.classList.add('md-viewed')
                        }
                    }); 

                    // Mark viewed after 30s
                    setTimeout(function() {
                        viewed_map[location.pathname] = 1;
                        localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                    }, 30000)
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <div class="center-image">
    <h1 id="constellation-book" class="home-h1"><a class="header" href="#constellation-book">üëΩConstellation Booküõ∏</a></h1>
</div>
<div class="center-image">
    <h3 id="your-journey-to-the-internet-computer" class="home-h3"><a class="header" href="#your-journey-to-the-internet-computer">Your Journey to the Internet Computer</a></h3>
</div>
<p>(ÔΩ°ÔΩ•‚àÄÔΩ•)ÔæâÔæû Hey there! Yeah! ü´° Welcome aboard! üéâ </p>
<p>1Ô∏è‚É£If you're not yet familiar with blockchain, bitcoin, and IC, no worries. I'm <a href="0.JourneytoWeb3/WhatistheBlockchain.html">here</a> to give you the lowdown on the history of crypto!</p>
<p>2Ô∏è‚É£If you've heard of IC but haven't gotten the full scoop yet, you've come to <a href="1.OverviewofIC/1.html">the right place to learn more</a>.</p>
<p>3Ô∏è‚É£Wanna hear Dominic's story? He's <a href="0.JourneytoWeb3/JourneyoftheDreamWeaver.html">right here</a>!</p>
<div class="home-box">
    <div class="box box1">1Ô∏è‚É£üì°
            <div>
                Crypto's past
            </div>
            <div>
                Starting web3 from scratch
            </div>
    </div>
    <div class="box box2">2Ô∏è‚É£üìñ
            <div>
                Get the facts fast
            </div>
            <div>
                IC's web3 dispatched
            </div>
    </div>
    <div class="box box3">3Ô∏è‚É£üîç
            <div>
                The tale behind
            </div>
            <div>
                Dominic's adventure ride
            </div>
    </div>
</div>
<div class="zoom-font">
    &nbsp; 2015 &nbsp;&nbsp;&nbsp;&nbsp; 2018 &nbsp;&nbsp;&nbsp;
    &nbsp; 2021 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Now &nbsp;&nbsp;&nbsp;
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10 Years
    <br>
    ‚Äî„Ä¶‚Äî‚Äî‚Äî„Ä¶‚Äî‚Äî‚Äî„Ä¶‚Äî‚Äî‚Äî„Ä¶‚Äî‚Äî‚Äî‚Äî‚Äî„Ä¶‚Äî‚Äî‚Äî‚Üí ‚àû üí• Blockchain Singularity
</div>
<img src="assets/README/iclogo.png" width="30%" style="float: right; margin-left: 35px;" class="zoom-img"/>
<p>Sometimes, I'm really awestruck to be living in such a miraculous era. Just a few years ago, we were mocking Bitcoin, and now decentralized finance, Ethereum and crypto have become deeply embedded. And in this rapidly evolving new world, a bunch of new technologies are adding color to our lives in their own unique ways: The Internet Computer, a next-gen general purpose blockchain compute platform.</p>
<p>Originating from Dominic's ideas in 2015: a horizontally scalable decentralized World Computer. The embryo was completed in 2018. After years of deep optimization of the underlying protocols, it launched in 2021. After years of development, it aims to become a decentralized cloud services platform,
<span class="hover-win0">
<span class="hover-win2">
The underlying infrastructure has been developed into a decentralized cloud, while the upper-layer applications achieve decentralization through DAO-controlled permissions to accomplish the goal of decentralization.
</span>
<span class="hover-win1">
deploying various dapps
</span>
</span>
100% on-chain without the need for other centralized services.</p>
<div class="center-image">
    <img src="assets/README/Book0.jpg">
</div>
<p>The structure of the Constellation Book:</p>
<ul>
<li>
<p>The first half is vivid and interesting, and the second half is concise</p>
</li>
<li>
<p>The first half talks about IC principles, and the second half discusses development in practice</p>
</li>
</ul>
<h2 id="why-do-i-write-this-book"><a class="header" href="#why-do-i-write-this-book">Why do I Write this book</a></h2>
<p>Early on, after learning about IC, I collected and arranged materials from the IC Whitepaper, Medium, ICPL forums, and IC Developer Forums. After talking to a friend about the IC architecture, I told her I was making notes on the IC resources and would share them when they were ready. I didn't expect that it would take a year. After experiencing the long years of procrastination, and with what I learned later, I finally put together the first version of the notes. After a period of further study, I thought it would be better to share these notes. Making it an open-source book helps everyone learn about IC and contributes to the IC developer community.</p>
<br>
<p>Learn blockchain with zero thresholds and level the learning field for IC.üë®‚Äçüíªüë©‚Äçüíª</p>
<div class="center-image">
    <img src="assets/README/1.jpg" style="zoom:15%;" >
</div>
<h2 id="why-open-source"><a class="header" href="#why-open-source">Why open source?</a></h2>
<p>I really like the Rust open-source community. There are many open-source books and high-quality projects in the Rust community, which have helped me a lot. I have learned a lot from the Rust open-source community. Projects like Bitcoin, Ethereum, and their related projects also have a strong open-source atmosphere, and I hope that more and more open-source projects will emerge in the IC community for everyone to learn from each other.</p>
<p>In addition, the IC content is updated and iterated quickly. With open-source references, everyone can contribute, keeping the content fresh and up-to-date.</p>
<br>
<br>
<p>Join the developer discussion group for this book, correct errors, make modifications, suggest improvements, and contribute to the open-source book together!</p>
<p>üåé
<a href="https://oc.app/4jwox-pyaaa-aaaar-amjbq-cai/?ref=3iq22-xyaaa-aaaar-amjrq-cai&amp;code=834791b392db154c">OpenChat</a>, <a href="https://discord.gg/5Y8QPHvR">Discord</a>, <a href="https://github.com/NeutronStarDAO/ConstellationBook-English">Github</a></p>
<div class="center-image">
    <img src="assets/README/2.jpg">
</div>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="journey-of-the-dream-weaver"><a class="header" href="#journey-of-the-dream-weaver">Journey of the Dream Weaver</a></h1>
<p>In every geek's heart lies a dream of decentralization. </p>
<p>This is a story about Dominic Williams.</p>
<br>
<h2 id="jahebil"><a class="header" href="#jahebil">JAHEBILüòé</a></h2>
<p>He liked to call himself &quot;JAHEBIL&quot;, which stands for &quot;Just Another Hacker Entrepreneur Based in London&quot;.</p>
<p>He wrote code, started businesses, and worked as a &quot;dream maker&quot; in London.</p>
<p>He was brave and optimistic, living secludedly, was not interested in socializing, and was only concerned about the brand of his company, living a repetitive and focused life. Even working 18 hours per day in an unfriendly entrepreneurial environment in the UK, he could still hum the happiest tunes.</p>
<br>
<p>Compared to Silicon Valley, the UK's entrepreneurial environment was like a living hell. The success of numerous companies in Silicon Valley led to even greater investments, which attracted top entrepreneurs from around the world to the area, either to reach the pinnacle of success or fail. Unlike Silicon Valley's talented pool, in the UK, every company that Dominic founded could only produce limited returns, then he would start another company, getting caught in a vicious cycle of working hard, making dreams, maintaining dreams, and making new dreams... He had to sharpen his skills to improve technically while ensuring the company remained profitable.</p>
<br>
<p>Tired of the cyclical life that was only draining his enthusiasm, the seed of hope ground at Dominic's heart. In 2010, as a dream maker, he decided to take chances!</p>
<p>Fight My Monster was a massively multiplayer online game and a children's social network. He planned to connect children from all over the world to play this game online. Players have their own monsters and use different skills to attack each other in a turn-based battle. At that time, on the other side of the earth, China was also going crazy for &quot;Roco Kingdom&quot; developed by Tencent.</p>
<br>
<p>After comparing HBase, Cassandra, and other databases, Dominic chose the early Cassandra beta, the first horizontally scalable distributed database. Dominic built various tools for Cassandra, including the first system that ran atomic transactions on scalable eventually consistent storage. They were the first team in the world to attempt to use a complex Cassandra system in a production environment.</p>
<p>Dominic wanted to connect millions of users worldwide through a distributed system, which was a significant innovation at the time. After several test runs, the game was officially launched on New Year's Day in 2011, and in just two weeks, it gained 30,000 users, skyrocketing to 300,000 users in just a few months.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/c84b1d3c76e8d4f51a2189ca557f2e4c-1674887452158-1.jpg" style="zoom:35%;" />
</div>
<p>The team achieved remarkable success in scaling up their business despite having a meager budget. However, they had overlooked one crucial factor - the development of a large-scale online game required an army of specialists, including Flash developers, database administrators, network engineers, payment system experts, operations and maintenance personnel, complexity analysts, cartoon artists, sound engineers, music composers, animation experts, advertising gurus, and more.</p>
<p>This massive expenditure surpassed any budget they had previously allocated to their entrepreneurial projects. In due course, Dominic and his friends exhausted their investment and were forced to seek additional funding. Day and night's overnight work resulted in an almost perfect growth chart, &quot;so raising funds shouldn't be too difficult&quot;.</p>
<br>
<p>Dominic introduced the project to investors, saying, &quot;Fight My Monster is growing rapidly and will soon exceed one million users. We believe that engineers live in an exciting era, and the Internet infrastructure is already mature. Many things can suddenly be achieved in new ways. This company was initially self-sufficient on a very limited budget. You may have heard that Fight My Monster is expanding, and now many excellent engineers have the opportunity to join us&quot;.</p>
<p>&quot;Let me explain our architecture plan and why we did it this way. As you can see, it is not a traditional architecture. We chose a simple but scalable three-tier architecture, which we host in the cloud. I hope this system works...&quot; Dominic continued passionately.</p>
<p>&quot;Since you already have so many users, maybe you should try to get more of them to pay. This will not only prove your ability to make money but also get our investment.&quot; The other party frowned, clearly reluctant to invest. Faced with such a crazy user growth, London investors even suspected Dominic of fabricating data.</p>
<br>
<p>Now, Dominic's heart was shattered like a biscuit. He had underestimated the difficulty of financing.</p>
<p>Soon, the pieces turned to crumbs. At this point, competitors had already secured funding from other investment firms and prevented other investment firms from investing in Fight My Monster.</p>
<p>Was it because they weren't working hard enough?</p>
<p>Since Cassandra was also in early development, at the end of 2011, due to bugs in Cassandra beta code, Fight My Monster's user data was almost lost. It took several days and nights of work from Cassandra senior engineers and Dominic's team to save the data, ultimately resolving this horrific incident.</p>
<img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/e2727ae940125d7ce368730cda151745.png" alt="e2727ae940125d7ce368730cda151745" style="zoom:33%; float: right; margin-left: 35px;" class="zoom-img"/>
<br>
<p>Dominic was in a constant flurry of activity. </p>
<p>He raced between his home and the company like a wound-up toy car: just after fixing a bug, he was off to meet with investors without even testing it first; he barely had time to eat, his head buried in meetings with engineers to discuss system adjustments; as soon as he left the company, he was off to the supermarket to buy Christmas gifts for his wife...</p>
<p>The team leans heavily on him in all aspects. His workload has become insanely heavy, even in a place like Silicon Valley where securing investments is a piece of cake. Back in the day, Dominic was putting in 12-18 hours a day ‚Äì a work rhythm that's rarer than a unicorn in today's startup scene. Balancing business management, system oversight, and coding, he had to carve out time for his personal life. Before you knew it, Dominic's wife had also acclimated to this lifestyle: during the day, she directed and planned game scenarios, optimizing gameplay and devising project workflows; come evening, she seamlessly transitioned into cooking, tidying up the house, perfectly in sync with Dominic. It's a juggling act that makes Cirque du Soleil look like child's play.</p>
<br>
<p>Dominic's photos.</p>
<img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/d5fa82e6a76e2272bcdad16a8cf7692c.jpeg" style="zoom: 33%; float: left; margin-right: 35px;"/>
<p>Dominic became even more hardworking after that. Fortunately, he happened to meet a company willing to invest in him in Silicon Valley. Finally, an investor was moved by this dreamer in front of them. Within a few weeks of raising funds, Fight My Monster's user count quickly reached 1 million. A few months later, Dominic relocated the company to San Mateo (a small town near San Francisco). </p>
<p>HHe went downstairs to grab a coffee, and when he got back, his notepad was chock-full of common ConcurrentHashMap issues and fixes. He listened to geeks dish on startup team-building tips and networked with Silicon Valley venture capitalists.</p>
<br>
<p>After a year of development, Dominic was very excited in 2012: </p>
<p>&quot;Fight My Monster appeared on TechCrunch today, worth a big cheer, thank you!!! We are working hard and hope we can achieve our dreams.&quot;</p>
<p>&quot;If you haven't played Fight My Monster yet, I suggest you give it a try - there really is nothing better online. We are incubating in the UK, and the best time to experience the site is weekdays (after school) from 4 pm to 8 pm or weekends during the day.&quot;</p>
<br>
<p>However, setbacks soon followed. After raising funds, the company's newly hired financial executive disagreed with the original team on strategy, and the disagreement escalated into a fatal decision-making mistake. Although the user base continued to grow, Fight My Monster was facing insurmountable obstacles. </p>
<p>From a financial return perspective, Fight My Monster was a failure, with the user base only expanding to over 3 million in 2013. </p>
<p>However, this experience was very valuable, and the most precious part was finding a group of capable colleagues who were also obsessed with the distributed system that Dominic loved. Dominic admired Fight My Monster's designer Jon Ball, who was always able to create a bunch of beautiful models using the team's design system, and later set the record for the highest ad viewing rate. There was also Aaron Morton, the Cassandra engineer who said &quot;We work together, believe each other&quot;, who worked with Dominic to build the &quot;engine&quot; behind the game - a distributed database. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/c509771324246de22e736b76c24b2343.jpg" alt="image-20230124164720298" style="zoom: 37%;" />
</div>
<p>In hindsight, Dominic's Flash game was no longer popular as people were gradually shifting towards mobile games and tablets. In 2010, Steve Jobs announced that Apple would no longer support Flash on its devices due to its impact on device performance. Additionally, due to frequent security vulnerabilities, BBC published an article titled &quot;How much longer can Flash survive?&quot; Shortly after, Adobe announced that it was abandoning the Flash project and switching to Animate for professional animation.</p>
<p>Reflecting on his experience, Dominic said, &quot;We could have succeeded but needed to move faster: if I had my time again, I would have relocated to The Valley very soon after the company started growing to raise money faster and gain access to a bigger pool of experienced gaming executives&quot;.</p>
<br>
<h2 id="engineers-turned-entrepreneurs-entrepreneurs-turned-engineers"><a class="header" href="#engineers-turned-entrepreneurs-entrepreneurs-turned-engineers">Engineers turned entrepreneurs, entrepreneurs turned engineers</a></h2>
<p>Although the gaming industry was withering away, in Silicon Valley, a strange yet formidable force captured Dominic's attention, causing ripples to emerge in his mind's stagnant pool of inspiration. These ripples quickly transformed into rolling waves, propelling him towards a new frontier.</p>
<p>Rewinding back to 1998, Dominic was developing an online storage system for a London-based startup and utilizing <a href="http://www.weidai.com/">Wei Dai</a>'s <a href="http://www.weidai.com">Crypto++</a> library extensively. While browsing Wei Dai's website, Dominic stumbled upon an article about &quot;b-money&quot;, one of the early precursors to Bitcoin.</p>
<p>Little did Dominic know that this article from 1998 would ignite the spark for Bitcoin and connect the timeline of his cryptography career for the next decade.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/9d3e99b7d9b265f272df6f184b1d467f.png" alt="http://www.weidai.com" style="zoom: 50%;" />
</div>
<p>After leaving Fight My Monster in 2013, Dominic became obsessed with Bitcoin, a long-dormant interest that had been sparked by the &quot;b-money&quot; article he had stumbled upon back in 1998. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/0c0ef2986203947e6d9d9bd7fb29bba4.png" alt="image-20230124132844405" style="zoom:67%;" class="zoom-img"/>
</div>
<p>Wei Dai wrote in <a href="http://www.weidai.com/bmoney.txt">b-money</a>: </p>
<p>&quot;I am fascinated by Tim May's crypto-anarchy. Unlike the typical understanding of 'anarchy', in a crypto-anarchy the government is not temporarily destroyed but permanently forbidden and unnecessary. It's a community where the threat of violence is impotent because violence is impossible, and violence is impossible because its participants cannot be linked to their true names or physical locations through cryptography&quot;. </p>
<p>Click <a href="0.JourneytoWeb3/ThingsaboutCryptoPunks.html">here</a> to see more about Crypto Punks.</p>
<br>
<p>B-money outlined a protocol for providing currency exchange and contract execution services in an anonymous community. Wei Dai first introduced a less practical protocol as a prelude because it required a synchronous, interference-free anonymous broadcast channel. He then proposed a practical protocol. In all schemes, Wei Dai assumed the existence of an untraceable network where senders and receivers could only be identified by digital pseudonyms (i.e., public keys), and each message was signed by the sender and encrypted for the receiver. </p>
<p>Wei Dai described in detail how to create currency, how to send it, how to prevent double-spending, how to broadcast transaction information, and how to achieve consensus among servers. </p>
<p>We cannot determine the relationship between Wei Dai's b-money and Bitcoin or whether he was inspired by &quot;The Sovereign Individual&quot; to design a scheme. However, Wei Dai's website shows that it was last updated on January 10, 2021. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/cc24110e86f36b5623b94b5bff3b1f9f.png" alt="image-20230124140739990" style="zoom:80%;" />
</div>
<br>
<p>Dominic said, &quot;I love algorithms and distributed computing, and I won many awards in this field during university. More importantly, I had never encountered a technical field that combined the thinking of finance, law, politics, economics, and philosophy, while also having the potential to drive significant change in the world. For me, this emerging field was a dream come true. I made a bigger life decision to re-enter this field with my career&quot;.</p>
<br>
<p>In 2013, Dominic started trading cryptocurrencies full-time, while picking up some basics about consensus algorithms on the side ü§£üòâ. He was interested in designing faster consensus mechanisms to work in conjunction with proof-of-stake (PoS) architectures.</p>
<p>Here is Dominic's &quot;Bitcoin ATM kiss&quot; in 2014.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/83403aa2179a2e9ded1d8f5bc9dc71e2.png" style="zoom:33%;" />
</div>
<br>
<p>On February 7th, Mt. Gox, the world's largest Bitcoin exchange, announced its bankruptcy. Dominic took to Twitter to express his distress at the beloved Bitcoin's plummeting value.</p>
<p>Bitcoin crashed to 666 USD. (It's currently priced at 23,000 USD, down from its peak of 69,000 USD.)</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/77ae5916be556e50b88f07b00bf1343f.png" style="zoom:50%;" />
</div>
<p>He buckled down, diving deep into traditional Byzantine fault tolerance, combined with his previous experience building online games. Dominic conceived a decentralized network that could horizontally scale like Cassandra - allowing more and more servers to join while maintaining high performance. In just a few days, Dominic published a <a href="https://drive.google.com/file/d/1agn88cO5ED1phN2vVx_Tj-jWmrfJ8Hmo/view?usp=sharing">paper</a> describing a scalable cryptocurrency called Pebble. The paper quietly circulated in the small crypto circles, the first to describe a decentralized sharded system. In this system, each shard uses an asynchronous Byzantine consensus algorithm to reach agreement.</p>
<br>
<p>While learning, Dominic didn't forget to trade Bitcoin. Investing in Bitcoin brought him some peace of mind, and now he could focus on designing consensus algorithms without having to work day and night or in a frenzy.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/60f45fe06eb9fa990443162691e7cab8.png" alt="image-20230123222606352" style="zoom:52%;" />
</div>
<br>
<p>Later Dominic fused the early Ethereum ethos, like an intricate tapestry. Inspired by Ethereum, after Dominic heard of the concept of the &quot;World Computer&quot;, it became his ultimate goal - he thought perhaps this was what the future internet would look like.</p>
<p>He realized smart contracts were actually a brand new, extremely advanced form of software. He saw that if the limitations of performance and scalability could be broken through, then undoubtedly almost everything would eventually be rebuilt on blockchains. Because smart contracts run on open public networks, superior to private infrastructure, they are inherently tamper-proof, unstoppable, can interconnect on one network, making each contract simultaneously part of multiple systems, providing extraordinary network effects, and can operate autonomously, inheriting blockchain properties, and so on.</p>
<p>Most of the details have faded over time into the mists of history - although not much time has passed, in the rapidly changing evolution of blockchain, this period seems to have already spanned the peaks and valleys of an entire lifetime.</p>
<br>
<p>Dominic's research focuses on protocols and cryptography, which are like dry kindling that reignites the dreamer's inner spark. Dominic believes that these protocols and cryptographic algorithms can change the world. He took the &quot;D&quot; for decentralized and the &quot;finity&quot; for infinity and combined them to create &quot;DFINITY&quot;. DFINITY aims to create a decentralized application platform with infinite scalability.</p>
<p>After returning to Mountain View, California from China, Dominic tweeted, &quot;China Loves Blockchain :)&quot;. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/12d2ad4630ef26d1c5988adf7a901d51.jpg" style="zoom:67%;" />
</div>
<p>Like Ethereum, Dominic also received investment in China. The reason is simple. Silicon Valley invested in Bitcoin very early and gained huge returns, so they don't care much about &quot;altcoins&quot; (the secular view is that coins other than Bitcoin are &quot;altcoins&quot;, which are basically coins that are slightly improved versions of Bitcoin).</p>
<br>
<p>Next, I need to introduce what the DFINITY team is doing in detail.</p>
<br>
<h2 id="point-line-surface-solid"><a class="header" href="#point-line-surface-solid">Point. Line. Surface. Solid!</a></h2>
<p>We know that Bitcoin is the pioneer of blockchain. Bitcoin itself emerged slowly in the long-term pursuit of decentralized currency projects by cypherpunks. Click <a href="0.JourneytoWeb3/WhatistheBlockchain.html">here</a> to see more about Blockchain.</p>
<p>It created an open ledger system: people from all over the world can join or leave at any time, rely on consensus algorithms to keep everyone's data consistent, and create a co-creation, co-construction, and shared decentralized network. People just need to download the Bitcoin software (downloading the source code and compiling it is also possible), and then start running it on their own machines to join the Bitcoin network. Bitcoin will enable computers around the world to reach a consensus and jointly record every transaction. With everyone's record, the legendary feature of &quot;immutability&quot; in blockchain is achieved, which is actually a matter of majority rule and not being able to cheat everyone.</p>
<br>
<p>In the traditional network architecture, user data is indiscriminately stuffed into servers. Users cannot truly control their own data, and whoever controls the server has the final say. If we can view this one-to-many relationship as &quot;<strong>points</strong>&quot; scattered around the world, the user's data flows into each point tirelessly.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20230717095805648.png" style="zoom:33%;" />
</div>
<p>So the Bitcoin network can be seen as a &quot;<strong>line</strong>&quot;, it connects isolated points into a line, making the internet more fair and open. What Bitcoin does is to combine computers from all over the world to form a huge &quot;<strong>world ledger</strong>&quot;. So what if you want to record something else? Just imitate Bitcoin and create a new one!</p>
<p>Six years after the birth of Bitcoin, a &quot;<strong>surface</strong>&quot; that can deploy software on a decentralized network gradually emerged, called <a href="0.JourneytoWeb3/WhatisEthereum.html">Ethereum</a>. Ethereum is not a replica of Bitcoin's world ledger. Ethereum has created a shared and universal virtual &quot;<strong>world computer</strong>&quot;, with Ethereum's virtual machine running on everyone's computer. Like the Bitcoin ledger, it is tamper-proof and cannot be modified. Everyone can write software and deploy it on the virtual machine, as long as they pay a bit of ether to the miners. (There are no miners anymore, but that's another article üòã)</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/38d3219e513911f18db5c8468841e030.png" alt="image-20230124190858096" style="zoom: 15%;" />
</div>
<p>Deployed software on the blockchain becomes an automated vending machine, permanently stored within a distributed and decentralized network that fairly and justly evaluates each transaction to determine if conditions are met. With the blockchain's immutable storage capabilities, the phrase &quot;code is law&quot; is coined. Here, software is referred to by another name: &quot;smart contracts&quot;. </p>
<p>However, ahem, interrupting for a moment. The idea is beautiful, but reality can be cruel. In the early Ethereum community, there was indeed a desire to create a &quot;world computer,&quot; establishing a decentralized infrastructure distributed worldwide. But Ethereum's architecture has certain limitations, including lower transaction execution performance, high gas fees due to rising ETH prices, poor scalability, and the inability to store large amounts of data, among other issues. </p>
<br>
<p>Dominic eagerly hoped his research could be put to use by the Ethereum project. His motivation was not for money, but a long-held passion for distributed computing, now sublimated into boundless aspirations for blockchain, making it hard for him to imagine anything that could eclipse the excitement and determination before him. He soon became a familiar face in Ethereum circles, often discussing at various conferences the possibilities of applying new cryptography and distributed computing protocols in next-generation blockchains.</p>
<p>The solution to this problem can take two approaches. The first is to improve the existing architecture, such as transitioning Ethereum's consensus from PoW to PoS (Casper), building shard chains, or creating sidechains. The other approach is to start over and design a new architecture that can handle information processing and large-scale data storage at high speeds. </p>
<p>Should they keep improving, scaling and retrofitting Ethereum's old architecture, or start from scratch to design a real &quot;World Computer&quot;?</p>
<p>At the time, people were interested in his ideas, but the inertia was that his concepts were too complex and distant, requiring too much time to realize and fraught with difficulties. Even though Ethereum did not adopt Dominic's ideas later, he was still grateful to early Ethereum members like Vitalik and Joe Lubin for patiently listening to his ideas in many early discussions.</p>
<p>Finally, Dominic made the difficult decision to start from scratch and design a real &quot;World Computer&quot;.</p>
<br>
<p>When we try to solve a specific problem, we often find that the key is to create powerful &quot;tools&quot;. With a more advanced and practical tool, and continuously maintain and improve it, it gradually becomes a more powerful tool to solve many valuable problems. A common business phenomenon is that in order to realize a product or service, a tool is developed, and then it is found that this tool has wider applicability, and then the tool itself evolves into a larger, more successful and higher-valued product.</p>
<p>Amazon's cloud services were originally designed to solve the problem of waste of computing resources after Black Friday. Later, it became the world's earliest and largest cloud service provider. Similarly, SpaceX solved the problem of high rocket launch costs. In order to thoroughly solve the scalability problem, Dominic decided to redesign the consensus algorithm and architecture.</p>
<p>The opportunity finally arrived in November 2015, in London.</p>
<p>Dominic presented the consensus algorithm he had been studying at devcon one.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/93504674b2894befb3c529b248726f50.jpg" style="zoom: 67%;" />
</div>
<p>Now we can see from Dominic's presentation at devcon one in 2015 that he described the IC as Ethereum 3.0. In fact, it wouldn't be too much to call it Blockchain 3.0. If Bitcoin and Ethereum are called &quot;Blockchain 1.0&quot; and &quot;Blockchain 2.0&quot;, he wanted to create a &quot;<strong>solid</strong>&quot;, a true world computer, even naming the project the Internet Computer (IC for short). Based on the &quot;face&quot; to support large-scale applications, it can horizontally expand and achieve unlimited scalability as a &quot;<strong>world computer</strong>&quot;. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/d566e01d9397ce368f777127001a237c.png" style="zoom:50%;" />
</div>
<p>Oops, sorry, it should be this one:</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/d600d44cc130bd67f9daad687a0db40c.png" alt="d600d44cc130bd67f9daad687a0db40c" style="zoom:80%;" />
</div>
<p>During the conversation, Dominic discovered that even the staunchest Bitcoin supporters were very interested in the concept of Ethereum. This reinforced his belief in the potential of Trusted Computing.</p>
<p>Dominic had an even grander vision than Ethereum. He wanted to create a public network of servers that would provide a &quot;decentralized cloud&quot; - a trusted computing platform. Software would be deployed and run on this decentralized cloud.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/73d313475c9ef0586de3a71b9b05f7c5.png" style="zoom: 67%;" />
</div>
<p>Dominic is working on reshaping a completely decentralized infrastructure, which can also be understood as the next generation of internet infrastructure or as a decentralized trusted computing platform combined with blockchainüòâ.</p>
<br>
<p>Simply put:</p>
<p>Traditional defense systems: mainly composed of firewalls, intrusion detection, virus prevention, etc. The principle of traditional network security is passive defense, often &quot;treatment after the event&quot;. For example, when an application has a virus, it is necessary to use anti-virus software to detect and kill it. At this time, the enterprise has already incurred losses to some extent.</p>
<p>Trusted computing: based on cryptographic computation and protection, combined with secure technology to ensure full traceability and monitoring. The principle of trusted computing is active defense. Since the entire chain from application, operating system to hardware must be verified, the probability of virus and network attacks is greatly reduced.</p>
<br>
<p>Blockchain has something called a consensus algorithm, which is responsible for coordinating the nodes in the network (a node is a group of servers, which can be understood as a high-performance computer). The consensus algorithm can ensure that everyone's information in the network is in agreement, because this is a network that anyone can join or leave at any time, and it is not known which node might intentionally disrupt it (you can refer to my future blog post about the Byzantine Generals problem). With the consensus algorithm, even if one-third of the nodes in the network are malicious, the other nodes can still reach a consensus normally (the resistance of different consensus algorithms varies).</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20230717095524248.png" style="zoom:50%;" />
</div>
<p>Decentralized platforms not only involve token transfers between parties, but also rely on consensus algorithms to establish a barrier and keep malicious actors at bay. However, efficiency and decentralization are difficult to achieve simultaneously, and it's challenging to create a fully decentralized system that can both protect nodes and allow for coordination and data synchronization among them. Dominic's goal is to merge trusted computing and blockchain to create a limitless, open, high-performance, strongly consistent, scalable, and data-intensive blockchain network composed of servers from all over the world, without the need for firewalls.</p>
<p>For Dominic, the future of blockchain is the future of the internet, and vice versa. The internet is no longer just about connecting servers in data centers to users, but first forming a trusted and secure blockchain network composed of servers from around the world, and then deploying apps and serving users on top of it. Dominic hopes that banking and finance, the sharing economy (such as Uber), social networks, email, and even web searches can all be transferred to such a network.</p>
<br>
<p>In retrospect, Ethereum made the right call not adopting Dominic's ideas back then. Because while focused on proof-of-work (PoW), Ethereum was also exploring upgrade paths to proof-of-stake (PoS). The blueprint he outlined was too ambitious to realize in a limited timeframe. To achieve his vision would have required an enormous, stellar team relentlessly researching, inventing new cryptographic techniques, and more.</p>
<p>In the fall of 2016, Dominic announced his return as a &quot;decentralized adventurer&quot;. With the theoretical framework in place, the adventure of a dreamer has officially begun!</p>
<br>
<h2 id="dfinity-"><a class="header" href="#dfinity-">DFINITY !</a></h2>
<p>IC re-designed the blockchain architecture and developed more efficient consensus, along with innovative cryptographic combinations, in order to achieve the idea of a &quot;world computer&quot;. The goal is to solve the limitations of speed, efficiency, and scalability in traditional blockchain architectures. </p>
<br>
<p>Dominic is busy researching with the technical team on his left hand, writing strategic plans for the team on his right hand, and going to various blockchain forums to introduce the project with his mouth. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/fb974c47245d325b1defc2ac8865e7ec.jpeg" style="zoom:15%;" />
</div>
<p>Over the years, Dominic has shared many critical cryptographic technologies with other blockchain teams, such as the application of VRF, which has been adopted by many well-known projects (such as Chainlink, etc.).</p>
<p>In February 2017, Dominic participated in a roundtable forum with Vitalik Buterin and many other experts. From left to right: Vitalik Buterin (left one), Dominic (left two), Timo Hanke (right one).</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/99e283e435820e746ca62048059b4909.jpg" alt="FfGddz-XoAA9SzO" style="zoom:33%;" />
</div>
<br>
<p>Ben Lynn (second from left in the red T-shirt) is demonstrating a mind-blowing technology called Threshold Relay, which can significantly improve the performance of blockchain and quickly generate blocks. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/63cf9b6bfe37c841fae4da90b0004c1a.jpeg" alt="ÂõæÁâá" style="zoom: 27%;" />
</div>
<p>By the way, engineer Timo Hanke (third from left in the middle) was a mathematics and cryptography professor at RWTH Aachen University in Germany before he created AsicBoost in 2013, which increased the efficiency of Bitcoin mining by 20-30% and is now a standard for large-scale mining operations.</p>
<p>Ben Lynn is one of the creators of the BLS signature algorithm, and the &quot;L&quot; in BLS stands for the &quot;L&quot; in his name. After graduating from Stanford with a Ph.D., he worked at Google for 10 years before joining DFINITY in May 2017. If you haven't heard of the BLS algorithm, you must have read Ben Lynn's &quot;Git Magic,&quot; which was all the rage on the internet a few years ago.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/fed23c8e27a52bd194abd072f602c2d3.png" style="zoom:57%;" />
</div>
<br>
<br>
<p>2021 was not an ordinary year. </p>
<p>May 10th. The IC mainnet was launched. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/df5b4b83d7b278dd3fdb923135947a16.jpeg" alt="Image" style="zoom: 50%;" class="zoom-img"/>
</div>
<p>The chart above shows a comparison of performance, storage data costs, and energy consumption against other blockchains.</p>
<br>
<p>When the IC mainnet went live, there were already over 4,000 active developers. The chart below shows the growth of developers compared to other blockchains. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/fabf7f6e50771c50912dc419e9284f16.jpeg" style="zoom:37%;" class="zoom-img"/>
</div>
<br>
<br>
<p>IC has many innovations, such as unlimited horizontal scalability. Through Chain Key, IC network has the ability to infinitely expand. The network is managed by a DAO - the <strong>Network Nervous System (NNS)</strong>. So this requires an <strong>unusual consensus algorithm</strong>. IC's consensus only <strong>orders messages so that replicas execute messages in the same order. Relying on the BLS threshold signature algorithm and non-interactive distributed key generation (DKG) to randomly select who produces blocks, the consensus speed is very fast.</strong> <strong>This also gives IC higher TPS</strong>, millisecond level queries and second level data updates. The experience of using Dapps is much smoother than other public chains.</p>
<p>IC's goal is decentralized cloud services. In order to deploy <strong>Full Dapps on chain</strong>, all Dapps are installed in a virtualized container. &quot;Canister&quot; on IC is equivalent to smart contracts on Ethereum. Canisters can store data and deploy code. Developers can also test through the <strong>Candid UI</strong> automatically generated by the backend virtual container without writing a line of code. Clients can directly access the frontend pages and smart contracts deployed on IC through https. The virtual containers are like small servers, providing each Dapp with its own on-chain storage space. They can also support smart contracts directly calling external https servers without an oracle. This is the first time in the history of blockchain that smart contracts can communicate directly with <strong>external https servers</strong>. After further processing the messages, the smart contracts can respond. Like Ethereum and Bitcoin, IC also accepts the paradigm of &quot;code is law&quot;. This also means that there is no governance to regulate the use of the platform or the underlying network itself. IC's &quot;smart contracts&quot; Canisters are not immutable. They can store data and update code.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20230614155150128.jpg" style="zoom:80%;" />
</div>
<br>
<p>Historically, for the first time, Bitcoin and Ethereum are directly integrated at the bottom layer through cryptography (not cross-chain bridges): IC is directly integrated with Bitcoin at the protocol level. The Canisters on IC can directly receive, hold and send Bitcoin on the Bitcoin network. In other words, Canisters can hold Bitcoin like a user's wallet. Canisters can securely hold and use ECDSA keys through the Threshold ECDSA Chain Key signing protocol. It is equivalent to giving Bitcoin smart contract functionality!</p>
<p>The whiteboard of the Zurich office's computing Bitcoin integration.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/6d6fa714d370a66d05a6c0d443c585b2.jpeg" style="zoom:70%;" class="zoom-img"/>
</div>
<p>Since the data is on the chain, the <strong>Gas fee has to be very low</strong> so people will use it: 1 G for 1 year is $5! Low Gas alone is not enough. In order for users to use Dapps without barriers, IC uses a <strong>reverse Gas fee model</strong> where the Gas is paid by the development team. The DFINITY team also pegged Gas to SDR, turning it into <strong>stable Gas</strong> that does not fluctuate with the coin price. IC has a unified decentralized anonymous identity: <strong>Internet Identity (ii)</strong> as the login for Dapps and joins the network neural system to participate in governance...</p>
<p>The IC architecture and consensus are also unique. In theory, IC has unlimited computation and storage - just keep adding server nodes. The improved consensus is a bit like practical Byzantine fault tolerance, yet more complex, because it's quite different from existing consensuses. Dominic gave it the name &quot;PoUW&quot; consensus, for <a href="0.JourneytoWeb3/../2.CoreProtocol/IntroductiontoConsensusLayer.html">Proof of Useful Work</a>. BLS threshold signatures with VRF produce truly unpredictable random numbers, and everyone can verify the randomness is not forged. Sybil attack-resistant edge nodes, hierarchical architecture, randomly assigned block production - no need to elaborate, just one word: exquisite.</p>
<br>
<p>According to statistics from GitHub and Electric Capital (2023), IC has the most active developer community and is still growing rapidly.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/616e010d7ec8b2eb236d023004f8ead4.jpeg" style="zoom:63%;" class="zoom-img"/>
</div>
<br>
<p>The photo on the office wall when IC was about to reach 30 million blocks after three weeks of mainnet launch. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/f78783b11cb609cfb3545381525ee787.jpeg" alt="ÂõæÁâá" style="zoom:50%;" />
</div>
<br>
<p>In July 2021, many new DFINITY members interviewed and joined the team via video conferencing during the COVID-19 pandemic without meeting in person. On this day, a small group of people came to the office located in Zurich to meet face-to-face. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/3adc64294313d748a0fe347ee81007b3.jpg" style="zoom:23%;" />
</div>
<br>
<p>Dominic has written two visions for DFINITY in his blog: </p>
<p>On the one hand, many traditional monopolistic technology intermediaries, such as Uber, eBay, social networks, instant messaging, and even search engines, may be redesigned as &quot;open-source enterprises,&quot; using proprietary software and their own decentralized governance systems to update themselves. </p>
<p>On the other hand, we hope to see large-scale redesign of enterprise IT systems to take advantage of the special properties offered by blockchain computers and dramatically reduce costs. The last point is not obvious, as computing on blockchain computers is much more expensive than traditional cloud computing such as Amazon Web Services. However, significant cost savings are possible because the vast majority of costs involved in running enterprise IT systems come from supporting human capital, not computing itself, and IC will make it possible to create systems with much less human capital involvement. </p>
<br>
<p>Image from Shanghai, October 2021. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/2cea7849c09de6aadd133bf5337ec7fa.jpeg" alt="Image" style="zoom:55%;" />
</div>
<br>
<p>On July 14, 2022, at a street caf√© in Zurich, Dominic and his team were waiting for the 1,000,000,000th block of IC to be mined, while checking the real-time statistics of IC data on the <a href="https://dashboard.internetcomputer.org/">dashboard</a>. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/6de3ff8a4d75d9964afa8252433562c7.jpeg" style="zoom:37%;" />
</div>
<br>
<p>DFINITY's new office building is located in Switzerland. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/03c4efa5b588d05bc594c6c98b5ef081.jpg" style="zoom:35%;" />
</div>
<br>
<p>When leaving the office, Dominic took some photos of murals on the cafeteria wall that were created by talented IC NFT artists. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/55079229adecb6dd5c35d8ad1fc84cd9.jpg" style="zoom:20%;" />
</div>
<p>Dominic moved into his new house, and shared the good news on Twitter while enjoying a piece of cake. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/f9803e7660dbfa51bc918b50e92a3e91.jpeg" alt="ÂõæÁâá" style="zoom:33%;" />
</div>
<p>After work, one must not neglect their musical pursuits. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/88fefffafff481e6a74b511e629f2fc5.png" alt="image-20230124235301028" style="zoom:70%;" />
</div>
<br>
<p>After talking for so long, what problems does IC actually solve? In general, it solves the problems that traditional blockchains have low TPS, poor scalability, and Dapps still rely on some centralized services. </p>
<br>
<p>Bitcoin is a decentralized ledger. A chain is a network. </p>
<p>Ethereum created decentralized computing. There are also side chains, cross-chain interactions. </p>
<p>Cosmos, Polkadot achieved composability and scalability of blockchains. In the multi-chain era, many blockchain networks come together, with interactions between chains. And these chains have organizational protocols that can scale indefinitely. </p>
<p>The Internet Computer built a decentralized cloud service that can auto-scale elastically with ultra high TPS. It's a brand new system and architecture, redesigned from bottom to top. </p>
<div class="center-image">
<img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20231130151540666.png" style="zoom:53%;" />
</div>
<p>The IC is designed to be decentralized at the base layer, which means deployed websites, smart contracts cannot be forcibly shut down by others. </p>
<p>Applications deployed on top can be controlled by users themselves, storing their private data. They can also choose to be controlled through a DAO, becoming fully decentralized Dapps, with community governance. </p>
<p>IC's smart contracts are Wasm containers, like small servers in the cloud, very capable, can directly provide computing, storage, web hosting, HTTP queries (oracles), WebSocket and other services. </p>
<br>
<p>The key to scalability is near-zero marginal cost. Polkadot's scalability is built on software engineers' development, while IC's scalability is automatically completed at the lower level. This greatly reduces the development cost of application teams on IC. </p>
<p>To build a highly scalable and high-performance public chain: </p>
<ul>
<li>
<p>First, scalability and performance must be valued in the planning stage, and the design and layout in all aspects are aimed at achieving scalability and TPS as soon as possible. </p>
</li>
<li>
<p>Second, confidence and strength are needed to stick to their own path until the day the ecosystem explodes. In the short term, we need to endure the suppression of other competitors, withstand the pressure of cash flow for a long time, and ignore the incomprehension of the world. </p>
</li>
</ul>
<p>Focus on the research and development of underlying infrastructure until various creative applications appear and increase the number of participants in the ecosystem. The increase in quantity leads to the further emergence of new ideas and applications. This forms a positive feedback loop, making the ecosystem spontaneously more prosperous and more complex: </p>
<p>Scalability / Zero marginal cost / Open system ‚Üí Increase in number of applications ‚Üí Exponential increase in various connections ‚Üí Valuable ideas emerge ‚Üí Form applications ‚Üí System complexity ‚Üí Quantity continues to increase exponentially ‚Üí Positive feedback loop ‚Üí Ecosystem prosperity. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20230716235313525.png" style="zoom:40%;" />
</div>
<p>All technological development options have advantages and disadvantages. Judging who will eventually win based on the partial and one-sided technological advantages and disadvantages is naive and dangerous. The ultimate winner on the blockchain will be the one with the richest ecosystem, the largest number of developers, software applications, and end users.</p>
<p>The key words for the future of blockchain are: zero latency, zero marginal cost, open ecosystem, huge network effects, extremely low unit cost, and an extremely complex and rich ecosystem.</p>
<p>The huge changes in industries brought about by technological revolutions are sudden for most ordinary people. But behind this suddenness are years, even decades, of gradual evolution.</p>
<p>Once a few critical parameters affecting the industrial pattern cross the critical point, the ecosystem enters a period of great prosperity, and changes are extremely rapid. The profound impact on most people is completely unexpected. After the change ends, the industry enters a new long-term balance. For some time, almost no competitors can catch up with the leaders in the industry.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/d906dc0876066d58bf33d4a2c619bc20-1674887452159-35.jpg" style="zoom: 33%;" />
</div>
<p>After 2 years of development, the IC ecosystem has emerged with many excellent applications. The front end and back end are all on-chain, and Dapps that do not rely on centralized services at all.</p>
<p>In the social Dapp (SocialFi) field, there are <a href="https://h5aet-waaaa-aaaab-qaamq-cai.icp0.io/">DSCVR</a>, <a href="https://az5sd-cqaaa-aaaae-aaarq-cai.ic0.app/">Distrikt</a>, <a href="https://mora.app/">Mora</a>, <a href="https://oc.app/">Openchat</a>, etc. DSCVR is an end-to-end decentralized Web3 social media platform. Distrikt is a Web3 microblogging platform that allows everyone to share content or participate in discussions in a decentralized network. Mora can deploy a smart contract for each user to store the user's blog data. Mora allows users to publish blogs on the blockchain and permanently store their own data. <a href="https://mora.app/planet/fohs7-baaaa-aaaan-qdcga-cai/7RCY77KRAC4NX8AQ98T2RGGJZB">Here</a> is more about Mora. Openchat provides decentralized instant messaging services and is a decentralized chat Dapp.</p>
<p>In the decentralized finance (DeFi) field, the IC ecosystem also has some very good Dapps: <a href="https://avjzx-pyaaa-aaaaj-aadmq-cai.raw.ic0.app/ICDex">ICLightHouse</a>, <a href="https://app.infinityswap.one/swap">InfinitySwap</a> and <a href="https://app.icpswap.com/">ICPSwap</a>. 2022 was a year of collapse of trust in centralized institutions. 3AC, Celsius, Voyager Digital, BlockFi, Babel Finance, FTX and other leading hedge funds, lending platforms and exchanges were defeated and went bankrupt this year. Not only that, DCG grayscale, Binance and Huobi and other giants also suffered varying degrees of <a href="0.JourneytoWeb3/../Glossary.html#fud">FUD</a>. Centralized institutions cannot achieve complete transparency. Their trust depends on the reputation of the founders and the external image of the company's brand. Decentralization is based on &quot;code is law&quot; and &quot;Don't trust, verify!&quot;. Without breaking, there is no standing. Under this revolutionary idea, the myth of centralization has been completely shattered, paving the way for a decentralized future. Decentralized financial services allow users to borrow, trade and manage assets without intermediaries, enhancing the transparency and accessibility of the financial system.</p>
<p><a href="https://astrox.me/">AstroX ME</a> wallet is a highly anticipated wallet app. The ME wallet can securely and reliably store and manage digital assets, allowing users to easily manage their IC tokens and various digital assets.</p>
<p>There is also the decentralized NFT market <a href="https://tppkg-ziaaa-aaaal-qatrq-cai.raw.ic0.app/">Yumi</a>. Users can create, buy and trade digital artworks, providing artists and collectors with new opportunities and markets.</p>
<p>The IC ecosystem has already emerged with many impressive Dapps, covering social, finance, NFT markets and wallets, providing rich and diverse experiences and services. As the IC ecosystem continues to grow and innovate, we look forward to more excellent applications. There are more interesting projects waiting for you to discover on the <a href="https://internetcomputer.org/ecosystem">official website</a>.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20230704224645360.png" style="zoom: 35%;" />
</div>
<p>Switzerland is now a prominent &quot;Crypto Valley&quot;, where many well-known blockchain projects have been born. DFINITY is the first completely non-profit foundation here.</p>
<p>Dominic has assembled a very strong team of blockchain developers, including cryptography, computer science, and mathematics professors, PhDs and postdocs, cryptocurrency experts, senior engineers, and professional managers.</p>
<p>The Internet Computer is the crystallization of 5 years of R&amp;D by top cryptographers, distributed systems experts, and programming language experts. Dfinity currently has close to 100,000 academic citations and over 200 patents.</p>
<p>I believe that blockchain will still be one of the most interesting, influential, and fastest-growing technology fields in the next 10 years. üöÄüöÄüöÄ</p>
<p>Currently, there is no other chain better suited for deploying applications than IC.</p>
<p>This is the story I wanted to tell about Dominic, but his own story is far from over, and has just begun... </p>
<p>As Dominic himself said: &quot;Our mission is to push towards a blockchain singularity, where the majority of the world's systems and services are created using smart contracts, and run entirely on chain, a transformation that will also take years.&quot;</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/WeCha(1)@1.5x.jpg" style="zoom: 23%;" />
</div>
<p>Who could have imagined that a blog post from distant 1998 would ignite the &quot;crypto movement&quot; that has been sweeping the world for the past twenty years, fueled by Dominic's passion for unlimited distribution...</p>
<p>That was a new world.</p>
<br>
<h3 id="epilogue"><a class="header" href="#epilogue">Epilogue</a></h3>
<p>After completing the conclusion, I perceived a faint disturbance. The rustling, rustling sound approached gradually, rendering the entire room utterly silent. The source of the sound remained indistinct and unfathomable - it could have been the hum of the computer's fan, the gentle sway of tree branches outside the window, or simply a figment of my own imagination.</p>
<p>The sound became clearer and clearer. It sounded like it was coming from inside the computer?</p>
<p>I hurriedly pressed my ear against the computer's motherboard, but the sound did not emanate from there. I turned my gaze towards the window - could it be coming from outside? Yet everything outside appeared perfectly normal.</p>
<p>Then the sound came again, louder this time. It was a buzzing sound! That's it!</p>
<p>Suddenly, time came to a standstill. Everything around me froze in place. Neurons expanded and burst, releasing pheromones that catalyzed other neurons. My head began to shake uncontrollably, then suddenly expanded. My eyes bulged like a mouse's, and my ears twisted into pretzels... The sound seemed to be accompanied by the sound of breaking glass, footsteps on the ground, and the sound of birds and dogs barking...</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/cfc9f9909024db41734c7a23eb881472.jpeg" style="zoom:33%;" />
</div>
<p>A burst of white light coursed through my mind, quickly swelling into a vast, shimmering expanse of brilliance. All around me, an endless canvas of blue unfurled, adorned with intricate squares and lines of every hue. Then, a radiant spark flickered to life, blossoming into a majestic orb that engulfed all else in its path. As the light dissipated, the blue canvas gave way to an immaculate vista of pristine white.</p>
<br>
<p>Now, I don't remember anything.</p>
<p>Maybe it was just a dream.</p>
<p>Or maybe it was something that could change the world.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20230705214715102.png" style="zoom: 67%;" />
</div>
<p>That's it for now, it's time to sleep. Goodnight.</p>
<p>By the way, the structure of the article is as follows:</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/JourneyoftheDreamWeaver/image-20230717003625783.png" style="zoom:40%;" />
</div>
<p>If there are any parts you don't understand, feel free to take a break from the main storyline and explore them.</p>
<p>Next, let's delve into <a href="0.JourneytoWeb3/../1.OverviewofIC/1.html">the technical architecture of IC</a>.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-future-has-come"><a class="header" href="#the-future-has-come">The Future Has Come</a></h1>
<p>I read through a lot of thoughts about blockchain, and summarise them into this article. Which I hope to give a relatively objective view about blockchain and internet technologies in the future.</p>
<h2 id="turkeys-on-the-farm"><a class="header" href="#turkeys-on-the-farm">Turkeys on the Farm</a></h2>
<p>Blockchain is all the rage these days. It seems like everyone is buying cryptocurrencies.</p>
<p>The quadrennial bull market, digital gold Bitcoin, red-hot IXOs, meme coins with hundredfold increases... </p>
<p>Hold on, let me check the calendar. It's May 2023... Looks like we're almost due for another bull market, if it comes on schedule. Last time was 2020, so maybe this time it'll be 2024.</p>
<br>
<p>But don't get too excited, let me tell you a story: </p>
<p>In a farm, there was a group of turkeys. The farmer fed them every day at 11 a.m. One turkey, the scientist of the flock, observed this phenomenon for almost a year without any exception. </p>
<p>So, it proudly announced its great discovery: every day at 11 a.m., food would arrive. The next day at 11 a.m., the farmer came again, and the turkeys were fed once more. Consequently, they all agreed with the scientist's law. </p>
<p>But on Thanksgiving Day, there was no food. Instead, the farmer came in and killed them all.</p>
<p>This story was originally put forth by British philosopher Bertrand Russell to satirize unscientific inductive reasoning and the abuse of induction. </p>
<br>
<p>Let's not talk about whether the bull market will come or not. </p>
<p>Instead, let's look at some similar situations from history and see what happened: </p>
<p>During the late '90s Internet bubble, the market experienced several ups and downs. In '96, '97, and '98, there were several fluctuations. The last and largest surge occurred from October '98 to March 2000 when the Nasdaq index rose from just over 2000 points to around 4900 points. This gradual climb instilled a resolute belief in speculators: no matter how badly the market falls, it will always bounce back. </p>
<img src="0.JourneytoWeb3/assets/NavigatingtheFrontiersofTomorrow/image-20230603203923583.png" alt="image-20230603203923583" style="zoom:65%;" />
<p>As people went through several bull and bear cycles, this unwavering belief was further reinforced. When the real, prolonged bear market began, they continued to follow their own summarized experience, doubling down and buying at what they thought were the dips... </p>
<img src="0.JourneytoWeb3/assets/NavigatingtheFrontiersofTomorrow/image-20230603205835532.png" alt="image-20230603205835532" style="zoom:65%;" />
<p>When the bubble burst, stock prices plummeted more than 50% in just a few days, with most stocks eventually losing 99% of their value and going straight to zero. Many people who had quickly become wealthy by leveraging their investments bet their entire net worth on bottom-picking during the bear market, only to end up losing everything.</p>
<br>
<p>The essence of the Internet is to reduce the cost of searching and interacting with information to almost zero, and on this basis, it has given birth to many highly scalable, highly profitable, and monopolistic business models that traditional economists cannot comprehend. However, many projects and ideas from the '90s were launched prematurely, before the necessary hardware and software infrastructure was in place, and before personal computers and broadband internet became widespread. As a result, they ended up failing miserably, like Webvan, founded in 1996 and bankrupt by 2001, with a total funding of around $800 million.</p>
<p>After the dot-com bubble burst in 2001, the maturation of infrastructure and the decrease in various costs led to the emergence of new applications (such as Taobao, YouTube, Netflix, Facebook, Amazon, AWS, iPhone, Uber, TikTok). Their explosive growth and massive scale far surpassed even the most pessimistic imaginations.</p>
<img src="0.JourneytoWeb3/assets/NavigatingtheFrontiersofTomorrow/image-20230603211039212.png" alt="image-20230603211039212" style="zoom:60%;" />
<p>Similarly, a large number of overly advanced blockchain projects that cannot directly generate value for end users will eventually wither away, giving rise to various pessimistic and negative emotions.</p>
<p>However, once the infrastructure matures, many of the boasts and dreams of the past will ultimately be realized by entrepreneurs who appear at the right time and place.</p>
<br>
<p>When bitcoin was viewed by the public as an Internet payment in 2014, the actual throughput of bitcoin could not support payment when shopping in supermarkets. Ethereum initially called itself &quot;a world computer&quot;. Many initially believed that Ethereum could replace Bitcoin because it had programmability. But this is actually a misconception, which can also easily lead to another mistaken view: That another next-generation smart contract platform is the killer of Ethereum, just because it provides more scalability.</p>
<p>Similarly, just as Ethereum cannot replace Bitcoin, the next &quot;cloud service&quot; blockchains are also unlikely to kill Ethereum, but expand adjacent possibilities and carry different applications, utilizing their unique characteristics. This does not mean that Bitcoin and Ethereum have established their position permanently. Bitcoin and Ethereum also have their own existing problems. More advanced technology does not necessarily replace existing technology, but is more likely to create a complex, specialized tech stack.</p>
<p>Today Ethereum's purpose is no longer for general computation on a large scale, but as a battle-tested, slow and secure computer for token-based applications like crowdfunding, lending, digital corporations and voting - a global accounting system for those worlds. Even if the Ethereum network is a bit congested, Gas is super expensive and it takes a few minutes to complete a transaction, these Dapps can still compete with banks, shareholder voting and securities firms.</p>
<p>Because these smart contracts allow completely free transactions between strangers without going through centralized institutions, and make the large personnel establishments of centralized institutions redundant. Automated market makers on Ethereum, like Uniswap, have only about 20 employees, currently worth about 20 billion. In comparison, Intercontinental, the parent company of the New York Stock Exchange, has nearly 9,000 employees and a market value of over $600 billion. Renowned blockchain investor Raoul Pal estimates that the global user base of blockchains is currently growing at over 110% per year, while global Internet users grew only 63% in 1997. Even following the trajectory of Internet development after 1997, the global user base of blockchains will grow from the current approximately 200 million to around 430 million by 2030.</p>
<br>
<p>Blockchain technology's essence is to reduce the barriers and costs of value exchange between global individuals and machines to almost zero.</p>
<p>However, Ethereum currently does not achieve this vision and ultimately still requires the maturity and popularity of various infrastructures.</p>
<p>Imagine what it would look like if blockchain technology successfully solves scalability, security and usability issues. Eventually there may be only a few public chains that can represent the future and go worldwide, carrying the decentralized dreams of people around the world.</p>
<br>
<p>Blockchains sit at the intersection of three major themes in modern society: technology, finance and democracy. Blockchains are a technology that uses the progress of encryption and computing to &quot;democratize&quot; money and many aspects of our daily lives. Its purpose is to improve the way our economy works, make it easier for us to control our own information, data and ultimately take control of our lives. In this tech age, this is what democracy should look like. <a href="0.JourneytoWeb3/Whathappenedtomyprivacyontheinternet.html">We often hear people complain about tech giants (like Apple, Google and Facebook) snooping on our privacy data</a>. The best way to solve this problem and give power back to the people.</p>
<br>
<h2 id="the-coachman-and-the-driver"><a class="header" href="#the-coachman-and-the-driver">The Coachman and the Driver</a></h2>
<p>The Coachman and the Driver
History repeats itself in a spiral ascent:</p>
<p>Now everyone can drive cars as long as they have money to buy one. üöó</p>
<p>In the past, everyone could ride horses as long as they had money to buy one. üêé</p>
<p>So the car is just a means of transportation for this era. In the future, people may rarely drive cars. Similar to how people ride horses now, only at riding clubs and some tourist spots. After self-driving technology matures, people will not need to drive at all, and those who can drive will become fewer and fewer. One has to go to racetracks to experience the joy of driving.</p>
<p>In the ancient times there were common horses, blood horses, war horses, and racetracks.</p>
<p>Now there are common cars, supercars, tanks, and racetracks.</p>
<p>Horses did not disappear, they were just replaced by cars.</p>
<br>
<p>When cars first appeared, they were looked down upon and hated for a long time due to noise, slow speed, frequent accidents, often breaking down, lack of gas stations, and lack of parking lots. Later, as more roads were built, more gas stations emerged, cars improved in quality, traffic rules were promoted, and horse carriages were completely replaced.</p>
<p>Tesla nowadays works the same way: it runs out of power quickly; catches fire; the autopilot drives into the sea or into trees; lacks charging poles; brake failures are exaggerated by the media to be a joke, oh no, it has become a laughing stock and meme. When the battery life extends, self-driving algorithms improve, charging poles become more common, and charging time shortens, what can oil cars do? üòÑ Moreover, electricity will become cheaper and cheaper with technological progress, through solar, wind, geothermal, and eventually controlled nuclear fusion...</p>
<br>
<p>The negative media coverage to attract eyeballs is also an obstacle for people to objectively recognize new things. In order to attract attention, the media selectively reports negative news about new inventions much more than positive reports, especially for new things. When the iPhone came out, the media first ridiculed the Apple fans as brainwashed, then accused people of selling kidneys to buy phones, and then attacked the poor signal.Every time a Tesla catches fire, experiences brake failure, or gets into an accident, there are always people who are inexplicably happy about it, without objectively comparing the accident rate with other cars. While people curse the various problems of shared bicycles, they fail to notice that shared bicycles are changing the commuting habits of urbanites, reducing gasoline consumption, and even affecting real estate prices.</p>
<p>Constant bombardment of negative news makes it almost impossible for most people to really delve into and study the full logic behind new things. Judging that a technology has no future because of its current limitations is like continuing to burn oil lamps for fear of the danger of electric shock. In fact, oil lamps also have the risk of fire! If we can remain objective and curious, we will have many different views on the world, especially in this era of rapid technological development.</p>
<br>
<p>Similarly, many people do not understand the underlying operating principles of IC, do not know the innovations of Chain Key cryptography, do not know that IC solves the scalability problem, do not know BLS threshold signatures, and do not know IC's consensus algorithm. It is difficult to truly understand the concept of IC because it is a completely new and complex system without analogies. Even for those with a computer background, it takes months to fully and deeply understand all the concepts by delving into various forums, collecting materials, and keeping up with new developments every day. If you are just looking for short-term benefits and blindly following the trend, investing in ICP at the price peak and then labeling this thing as &quot;scam&quot; or &quot;garbage&quot; because of huge losses and lack of understanding is very natural. All the losing retail investors become disappointed and gradually join the FUD army on social media, leading more people who do not understand IC to develop prejudices. More importantly, people often do not know the information they missed due to ignorance. Individual prejudices are common. Each person has different learning and life experiences and different thinking models, which will automatically ignore things that they are not interested in or do not understand.</p>
<p>For more related reading: <a href="https://mora.app/planet/ljlzk-viaaa-aaaan-qdpkq-cai/7XX5TVR413QFAH4917425QE3G8">Were attacks on ICP initiated by a master attack ‚Äî multi-billion dollar price manipulation on FTX?</a> <a href="https://mora.app/planet/ljlzk-viaaa-aaaan-qdpkq-cai/7XXA1V7TGHV3WGGRQQ9ZGGMHPM">How The New York Times promoted a corrupt attack on ICP by Arkham Intelligence</a> ,<a href="https://mora.app/planet/5mpju-nyaaa-aaaan-qdmrq-cai/7XX4638VYN7R860MBS042715T7">Interview with DFINITY: ICP is a victim of SBF's capital operation; much of the future of Web3 is in Asia.</a></p>
<br>
<br>
<p>Human society's productivity moves forward in cycles:</p>
<p>A new technology emerges ‚Üí A few people first come into contact with and try it ‚Üí More people are hired to develop and maintain this technology ‚Üí Organizations (companies or DAOs) grow and develop ‚Üí More and more people start to try it and improve productivity ‚Üí Until another new technology sprouts, trying to solve problems and facilitate life in a more advanced and cutting-edge way ‚Üí Old organizations gradually decline and die (those that change faster die faster, those that do not change just wait to die, and a few organizations can successfully reform) ‚Üí A large number of employees lose their jobs and join new jobs ‚Üí New organizations continue to grow and develop...until one day! People really don't have to do anything at all, fully automated, abundant materials...life is left with enjoyment only~</p>
<br>
<p>The essence of blockchain technology is that innovation can be carried out by everyone without the review and approval of authoritative institutions. Anyone can protect their rights and interests through blockchain technology without infringement by the powerful. Everyone is equal in cryptography. As long as the private key is properly kept, personal assets can be fully controlled by themselves without relying on anyone's custody.</p>
<p>Visa's TPS is 2400, Bitcoin's is 7. Even at Bitcoin's slow speed, it has gained the support of enthusiasts, organizations and some governments around the world. If the previous centralized applications, such as Telegram and Dropbox, can be transferred to a decentralized blockchain, what kind of scenario would that be? Productivity will definitely be improved.</p>
<br>
<p>Despite the widespread application and development of blockchain technology in recent years, there are still some obvious drawbacks. One of the main issues is scalability. As blockchain technology is widely applied in areas such as digital currencies, smart contracts, and supply chain tracing, the transaction and data volume in blockchain networks are growing rapidly, presenting significant challenges to the scalability of the blockchain. The current blockchain architecture faces problems such as low throughput and high latency, making it difficult to support large-scale application scenarios. This is because the traditional blockchain technology adopts distributed consensus algorithms, which require all nodes to participate in the process of block verification and generation, thus limiting the network throughput and latency. Additionally, as blockchain data is stored on each node, data synchronization and transmission can also become bottlenecks for scalability. </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/NavigatingtheFrontiersofTomorrow/image-20230705184046350.png" style="zoom:30%;" />
</div>
<p>Therefore, solving the scalability problem of blockchain has become one of the important directions for the development of blockchain technology. Researchers have proposed many solutions to improve the throughput and latency performance of blockchain networks, such as sharding technology, sidechain technology, and Lightning Network. These technologies are designed to decompose the blockchain network into smaller parts, allowing for separate processing of transactions and data, and can be interoperable through cross-chain communication protocols. Through these innovative technologies, blockchain scalability can be improved to better meet the needs of actual application scenarios.</p>
<br>
<p>Once blockchain solves the problems of scalability and throughput, achieves breakthroughs in underlying technology, it may become the new infrastructure of the Internet and reshape the future Internet landscape.</p>
<br>
<p>Dfinity elected to reinvent blockchain's underlying technology, developed a superior decentralized network service through innovation, and fostered more Dapps to cultivate an entirely new decentralized Internet ecosystem.</p>
<br>
<p>This realm is so novel, encompassing such a vast knowledge domain, that no one person reigns supreme. Success springs from observing broadly, learning ceaselessly. Only then unveils insights inaccessible and incomprehensible to most.</p>
<br>
<p>Continue reading <a href="0.JourneytoWeb3/./JourneyoftheDreamWeaver.html#engineers-turned-entrepreneurs-entrepreneurs-turned-engineers">Dominic's story</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>To talk about this, we have to start before Bitcoin.</p>
<p>If you're not familiar with Bitcoin, you can take a look at <a href="0.JourneytoWeb3/Bitcoin.html">this</a> first.</p>
<br>
<p>Bitcoin is completely virtual. It has no actual value and cannot create any value; it's just a virtual currency. Why do people go crazy sending money to buy Bitcoin? Let's dig a bit deeper: why does Bitcoin even exist?</p>
<p>Bitcoin was born against the backdrop of the 2008 financial crisis. The financial crisis spread globally, with no country immune. Fiat currencies became less reliable. Imagine the underlying relationship: governments issue legal tender backed by national credit. But the world is not always stable and peaceful, with wars, natural disasters and financial crises impacting society, which in turn affects the economy.</p>
<br>
<p>About wars: Society relies on governments, governments control armies, armies maintain society. Nations fund their armies through taxation. Conflicts between nations can arise if the benefits outweigh the costs, leading to war. Taxpayers fund the armies to launch wars. When the cannons boom, gold weighs a thousand taels. Some nations profit, some lose money.</p>
<p>About finance: Most countries in the world, like Europe and North America, have economic cycles. Small cycles make up large cycles, like a sine wave function. Periodic financial crises are like a sword hanging overhead; we can only pray: &quot;Dharma, spare me!&quot;</p>
<p>About natural disasters: They are difficult to predict. Though technological advances have reduced their impact on humans, threats remain for the next few decades. Viruses, floods, volcanoes - the economy suffers in response.</p>
<br>
<p>Since the economy will be impacted one way or another, can we find a type of money that is not devalued? It doesn't have to withstand all crises until mankind's destruction; it just needs to survive some natural disasters and human troubles. Money, I beg you, don't let a financial crisis on one end of the Earth affect people's normal lives on the other end.</p>
<br>
<p>There really is such a magical thing.</p>
<p>This kind of money originates from an &quot;anarchist&quot; idea. The previous b-money already reflects this idea.</p>
<p>The basic position of &quot;anarchism&quot; is to oppose all forms of domination and authority, including government, advocate self-help relations between individuals, and focus on individual freedom and equality. For anarchists, the word &quot;anarchy&quot; does not represent chaos, emptiness, or a state of moral degeneration, but a harmonious society established by the voluntary combination of free individuals to build mutual assistance, autonomy and anti-dictatorship, which is an autonomous system with authority but without government. They believe the root lies in &quot;government&quot;, in the current pyramid structure from top to bottom. The layer-upon-layer management model not only has problems of inaction, corruption and waste, more importantly, there is always an organization above managing and maintaining order, which can easily lead to turmoil due to major conflicts of interest.</p>
<br>
<ul>
<li>Further analysis, you see that primitive society was very peaceful. People lived together spontaneously in large families, hunted together and cooperated. There was no so-called government or nation, only small-scale wealth accumulation and division of labor, and no laws or police. Because primitive society had no private property, everyone was a piece of meat that could run and jump, naked.</li>
<li>Later, with private property came violence. The reason is simple, because you can profit from it .Through violent plunder of wealth, there will be &quot;brave men&quot; who do it for profit.</li>
<li>Then, when there are a large number of &quot;profitable&quot; organizations, someone will stand up to protect everyone. The emergence of violent organizations to prevent violence - the army. Everyone pays a little money (taxes) in exchange for protection. People form governments to provide protection services more efficiently. People deposit their money in banks because banks can provide protection: vaults, safe deposit boxes, security guards, police, etc. This system relies on the government to operate, banks, police, either accept government regulation or are established by the government. My money is not on me, it's in the bank, haha you can't rob it.</li>
<li>In this way, two large organizations (governments) will engage in larger-scale wars due to collective interest conflicts if the benefits outweigh the costs of launching the war. Recruit more armies to protect collective property...The violent conflicts become larger and larger, where is the peace? Nuclear deterrence.</li>
</ul>
<br>
<p>By the 21st century, people's property, including social and entertainment, gradually shifted to the Internet. So the organizations that protect people's property also migrated online: online banks, Alipay.</p>
<p>No problem, leave your money with us, haha. Just pay a small fee, haha. It's the protection organization that helps everyone keep it, if you lose money, solve it with the platform! Wars have also become online attacks and defenses, protection organizations and hackers fight back and forth, desperately holding on to everyone's money.</p>
<p>In the past, protection organizations only provided physical protection and would not station troops in your home to guard you. But it's different online, all your data is uploaded to the server in one go. My data is also my asset! The data contains privacy, property, what you bought today, who you like to chat with, what you like to watch, what you want to eat at night ... All can be analyzed from the data. This is equivalent to a &quot;network army&quot; stationed in your home, monitoring your every move day and night. And how the data is processed is up to them. Because the protection organization controls the server, if they think it's not good, disadvantageous to someone, they can directly delete it without your consent.</p>
<br>
<p>Is it possible to flatten the &quot;pyramid&quot; and build a system of &quot;personal sovereignty&quot; for each person to represent equal and independent individuals, not dependent on protection organizations?</p>
<p>It is possible. There is a way for you to safely hold your own private property by yourself. You don't need a bank to protect your wealth, don't need a safe to protect, and don't need protection organizations, you can keep it by yourself.</p>
<p>But how can you protect your property yourself? The answer is to use modern cryptography through mathematics!</p>
<p><strong>Bombs can blow open safes, but they cannot blow open cryptography!</strong></p>
<p>Bitcoin is just that kind of money! You generate your own private key, as long as the private key is not leaked, no one can take your bitcoins from you. Receiving and sending bitcoins are peer-to-peer transfers that bypass third-party centralized platforms (banks). Of course, if you lose the private key, you'll never be able to find your bitcoins again.</p>
<p>Your private key, mastering your own data, not dependent on third parties, perfect.</p>
<br>
<p>Of course, encrypted currency was not Satoshi Nakamoto's own idea.</p>
<p>David (Wei Dai) mentioned Tim May, who was one of the three people who jointly initiated the Cypherpunk research group in California Bay Area in 1992 along with Eric Hughes and John Gilmore. At the first meeting, the word &quot;cypherpunk&quot; was born by combining the roots of &quot;cipher&quot; and &quot;cyberpunk.&quot;</p>
<p>They found in cryptography and algorithms a potential solution to the excessive centralization of the Internet. Cryptographers believed that to reduce the power of governments and companies, new technologies, better computers and more cryptographic mechanisms were needed. However, their plans faced an insurmountable obstacle: ultimately, all of their projects needed financial support, and governments and banks controlled that money. If they wanted to realize their plans, they needed a form of currency not controlled by the government. So the race for encrypted currency began. But the result was the exact opposite. All the initial efforts failed, including the legendary cryptographer David Chaum's ECash, as well as various encrypted currencies like Hashcash and Bit Gold.</p>
<p><img src="0.JourneytoWeb3/assets/ThingsaboutCryptoPunks/1.jpeg" alt="1" /></p>
<p>Wei Dai is a Chinese American computer engineer and an alumnus of the University of Washington. In the late 1990s and early 2000s, he worked in the cryptography research group at Microsoft. During his time at Microsoft, he was involved in researching, designing and implementing cryptographic systems. Previously, he was a programmer at TerraSciences in Massachusetts.</p>
<br>
<p>In 1998, he published an informal white paper called &quot;B-money, an anonymous distributed electronic cash system&quot; on his personal website weidai.com. He is known for his contributions to cryptography and cryptocurrencies. He developed the Crypto++ cryptographic library, created the B-Money cryptocurrency system, and co-proposed the VMAC message authentication code algorithm. Wei Dai's pioneering work in the blockchain and digital currency field laid the foundation for later Bitcoin technology and was of milestone significance.</p>
<p>In November 1998, just after graduating from university, he proposed the idea of B-money in the community: &quot;Effective cooperation requires an exchange medium (money) and a way to enforce contracts. In this paper, I describe a protocol whereby untraceable anonymous entities can cooperate more efficiently... I hope this protocol can help move encrypted anarchism forward, both theoretically and practically. &quot; The design goal of B-money was an anonymous, distributed electronic cash system.</p>
<p>In the eyes of the Cyberpunks community, the problem with this approach was that the government could control the flow of money through policy management, and using these institutional services (banks or Alipay) required exposing one's identity. So Dai provided two alternative solutions (proof of work and distributed bookkeeping).</p>
<blockquote>
<ol>
<li>Proof of work creates money. Anyone can calculate some mathematical problems, and the person who finds the answer can broadcast it to the entire network. After each network node verifies it, they will add or destroy work equivalent value encrypted currency in the account of this person in their own account book.</li>
<li>Distributed bookkeeping tracks transactions. Neither the sender nor the receiver has a real name, only public keys. The sender signs with the private key and then broadcasts the transaction to the entire network. Each new transaction generates, everyone updates the account book in their hands, so that no one can stop the transaction and ensure the privacy and security of all users.</li>
<li>Transactions are executed through contracts. In B-money, transactions are achieved through contracts. Each contract requires the participation of an arbitrator (third party). Dai designed a complex reward and punishment mechanism to prevent cheating.</li>
</ol>
</blockquote>
<p>We can see the connection with Bitcoin. Money is created through POW proof of work, and the account book work is distributed to a peer-to-peer network. All transactions must be executed through contracts. However, Dai believed that his first version of the solution could not be truly applied in practice, &quot;because it requires a very large real-time tamper-resistant anonymous broadcast channel.&quot; In other words, the first solution could not solve the double spending problem, while Bitcoin solved the Byzantine Generals problem through incentives.</p>
<p>Dai later explained in the Cyberpunks community: &quot;B-money is not yet a complete viable solution. I think B-money can at most provide an alternative solution for those who do not want or cannot use government-issued currencies or contract enforcement mechanisms.&quot; Many of the problems of B-money have remained unresolved, or at least have not been pointed out. Perhaps most importantly, its consensus model is not very robust. After proposing B-money, Dai did not continue to try to solve these problems. He went to work for TerraSciences and Microsoft.</p>
<br>
<p>But his proposal was not forgotten. The first reference in the Bitcoin white paper was B-money. Shortly before the publication of the Bitcoin white paper, Adam Back of Hashcash suggested that Satoshi Nakamoto read B-money. Dai was one of the few people Satoshi Nakamoto contacted personally. However, Dai did not reply to Satoshi Nakamoto's email, and later regretted it.</p>
<p>He wrote on LessWrong, &quot;This may have been partly my fault, because when Satoshi emailed me asking for comments on his draft paper, I didn't reply. Otherwise I might have been able to successfully persuade him not to use a fixed money supply.&quot;</p>
<p>B-money was another exploration by the cypherpunk community to develop an independent currency in the digital world. In his memory, two cryptocurrencies were named &quot;Dai&quot; and &quot;Wei&quot; respectively, of which Wei was named by Vitalik in 2013 as the smallest unit of Ethereum.</p>
<br>
<p>However, with each new attempt and each new failure, the &quot;cypherpunks&quot; gained a better understanding of the difficulties they faced. Therefore, with many previous attempts to explore, Satoshi Nakamoto learned from the problems encountered by his predecessors and launched Bitcoin on October 31, 2008.</p>
<p>As Satoshi Nakamoto said in his first email on this issue, &quot;I've been working on a new electronic cash system that's fully peer-to-peer, with no trusted third party.&quot; He believed that his core contribution was: creating a virtual currency managed and maintained by users; governments and businesses have almost no say in how the currency operates; it will be a completely decentralized system run by users.</p>
<br>
<p>Satoshi Nakamoto was well aware of the inglorious history of cryptocurrencies. In an article shortly after the release of Bitcoin in February 2009, Satoshi Nakamoto mentioned Chaum's work but distinguished Bitcoin from Chaum's work. Many people mistakenly regarded electronic money as a failed venture because all companies had failed since the 1990s. In my view, the failure of those digital currencies was because their systems were not decentralized. I believe Bitcoin is our first attempt to build a decentralized, trustless virtual currency system.</p>
<p>To ensure trust between participants, Satoshi Nakamoto designed a public chain that allows people to enter and check to ensure their money still exists. To protect privacy, Bitcoin uses an encrypted private key system that allows users to tell others their account without revealing their identity. To incentivize users to maintain the system, Bitcoin introduced the concept of mining, in which users can create new transaction blocks and earn rewards with newly minted bitcoins. To prevent hacking, blocks are cryptographically linked to previous blocks, making the transaction history essentially immutable. Bitcoin's real innovation is that its monetary system is completely decentralized, that is, there is no ultimate decision maker or authority to resolve disputes or determine the direction of currency development, but users collectively determine Bitcoin's future as a whole.</p>
<br>
<p>Cypherpunks remain vigilant about these threats. They are trying to weaken the government's and companies' surveillance capabilities by creating a set of privacy-enhancing programs and methods, including strong cryptography, secure email, and cryptocurrencies. Their ultimate goal is to decentralize decision making on the Internet. Cypherpunks do not concentrate power in the hands of a few but seek to distribute power to the masses so that everyone can decide together how the entire system should operate.</p>
<p>In the eyes of cypherpunks, the main problem of the Internet age is that governments and companies have become too powerful, posing a serious threat to individual privacy. In addition, the US government and companies abuse their power and status, charging consumers too much and imposing heavy taxes. The answer lies in decentralizing power‚Äîdistributing power and decision making from a few to many. But before Bitcoin appeared, it was unclear how to achieve this, and Satoshi Nakamoto provided the solution.</p>
<img src="0.JourneytoWeb3/assets/ThingsaboutCryptoPunks/OIG.jpeg" alt="OIG" style="zoom:30%;" />
<p>Is Bitcoin absolutely safe? Of course not. If you want to rob someone's Bitcoin, put a knife to his throat and ask him to hand over the private key. Whoever has the private key owns the Bitcoin. The encryption algorithm only recognizes the private key. This is the charm of decentralization. <strong>We believe in Bitcoin not because Satoshi Nakamoto will not sell his huge amount of Bitcoin, but because we believe in individual sovereignty and cryptography.</strong></p>
<br>
<p>People will say that when Satoshi Nakamoto invented Bitcoin, he could not foresee the astonishing consequences at all. Of course, to some extent, it was indeed impossible for him to foresee &quot;Bitcoin pizza&quot;, &quot;Silk Road&quot;, Mt.Gox or the crazy bull market in 2017.</p>
<p>However, Satoshi Nakamoto had an amazing vision for the development of this technology. For example, he wrote that although blockchain technology cannot solve privacy issues on the Internet, if successful, users will &quot;win a major battle in an arms race and gain new freedom over the next few years.&quot; He also foresaw that blockchain technology would be difficult to shut down. As he wrote, &quot;Governments are good at cutting off the heads of centrally controlled networks like Napster, but pure peer-to-peer networks like Gnutella and Tor seem to be holding their own.&quot; He also saw that the blockchain itself is a flexible technology that can be developed into endless applications by users. &quot;Once it gets going, there are going to be applications nobody ever dreamed possible, no sooner than you can install a plug-in on a website for pennies if you wanted too, it will be that easy.&quot;</p>
<p>At the same time, Satoshi Nakamoto was also worried about the consequences he brought to the world. He worried about how governments would deal with his virtual currency. When blockchain users pushed WikiLeaks to use Bitcoin to avoid government sanctions, Satoshi Nakamoto strongly opposed it, saying: &quot;You would likely do more harm than good at this point.&quot; He was also worried about the emergence of super miners. He wrote: &quot;We should have an gentleman's agreement to postpone the GPU arms race as long as we can for the good of the network.&quot; His biggest concern may have been network security. After detailing improvements to virtual currencies, he summarized in his last public message: &quot;There are still more ways to attack than I can calculate.&quot;</p>
<br>
<p>The mystery surrounding Satoshi Nakamoto will only increase people's curiosity about him and his technology. Although journalists have tried their best to uncover his mysterious veil, we may never know who he is. Satoshi Nakamoto is like a star shining in the middle of the night, always twinkling in our sight but unattainable. <strong>This is very punk and poetic. The inventor of Bitcoin refuses to become the centre of his invention.</strong> Blockchain technology is a technology that removes trusted intermediaries from our lives and empowers everyone. He refused to become the focus of people's attention. The success or failure of the blockchain must depend on its own advantages - relying on the characteristics of the technology itself and the efforts of users to make it work.</p>
<br>
<p>Satoshi Nakamoto's idea may be quite innovative, but the rise of Bitcoin was not inevitable. Bitcoin was born against the backdrop of the 2008 financial crisis. The financial crisis swept the globe, and no country could stand alone. Fiat currencies became unreliable. Satoshi Nakamoto and his supporters often pleaded over and over again to convince others to believe in Bitcoin. They often said one sentence: Imagine if Bitcoin became the world's currency. Imagine how much each Bitcoin would be worth then! And all you have to do is download the software and run it on your home computer to earn hundreds of them. Of course, most people believed that this was a pyramid scam under Satoshi Nakamoto's tireless efforts.</p>
<p>But it did not prevent some tech geeks from becoming interested in Bitcoin eventually. Satoshi Nakamoto's efforts paid off, and people began to use and accept Bitcoin in the real world. Then on May 22, 2010, programmer Laszlo Hanyecz bought 2 boxes of pizza for 10,000 bitcoins.</p>
<img src="0.JourneytoWeb3/assets/ThingsaboutCryptoPunks/v2-78c9d1428dbc9b7dd0ea56ad20ab40f0_1440w.webp" alt="v2-78c9d1428dbc9b7dd0ea56ad20ab40f0_1440w" style="zoom:50%;" />
<p>Then, fundamental changes began to happen in the entire Internet world: once people started using Bitcoin in the real world, an ecosystem surrounding Bitcoin emerged. Cryptocurrency exchanges like Mt.Gox, Binance, and Coinbase were born to make it easier for people to buy and sell this currency. To solve the difficult mathematical problems behind the currency, professional miners began to build mines around the world. Chip manufacturers began to produce dedicated chips.</p>
<p>People's growing interest in Bitcoin stimulated the development of the Bitcoin and cryptocurrency market. The value of Bitcoin began to soar wildly. In 2010, Bitcoin was less than 1 cent. By mid-2021, it rose to $60,000. This crazy surge led many outsiders to compare it with historical bubbles such as the Tulip Mania in the 17th century and the South Sea Bubble in the 18th century. Concerns about the collapse of Bitcoin prices began to spread. Secondly, the emergence of competitive cryptocurrencies.</p>
<img src="0.JourneytoWeb3/assets/ThingsaboutCryptoPunks/3.jpg" alt="3" style="zoom:30%;" />
<p>Seeing the success of Bitcoin, some entrepreneurial-minded computer scientists have launched cryptocurrencies based on blockchain technology. For example, Litecoin, Dogecoin, and Ethereum. Ethereum built a new type of computer on top of Bitcoin that runs on decentralized virtual machines around the world. It cannot be tampered with, shut down by governments, or controlled by governments. People of different races, living in different regions and with different lifestyles from all over the world come together to form a decentralized network. Unless the United Nations shuts down the Internet on Earth, as long as the Internet is up, this decentralized organization will continue to exist.</p>
<p>In 2017, initial coin offerings (ICOs), where individuals or groups raise funds by selling cryptocurrencies or &quot;tokens&quot;, became popular very quickly. However, most of them ended in failure. About half of the initial coin offerings went bankrupt within a year despite widespread media attention on virtual currencies.</p>
<br>
<p>However, the network speed of almost all electronic devices is too slow. Think about it, in the early days, any ordinary computer could join the Bitcoin network to mine, but now with more and more people mining Bitcoin and the increasing difficulty of hash, people have to buy more high-performance graphics cards and combine more computers to mine. This is equivalent to a decentralized server room.</p>
<p>Dominic thought, why not let data centre server rooms act as nodes, which can also improve performance!</p>
<p>As a result, IC has become &quot;server room chain&quot;, a decentralized network composed of server rooms around the world. Ethereum is better at financial dapps, while IC is good at general dapps. This has led to a &quot;personal sovereignty&quot; revolution in various Internet applications: envisioning <a href="0.JourneytoWeb3/NavigatingtheFrontiersofTomorrow.html">the future of blockchain</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-blockchain"><a class="header" href="#what-is-blockchain">What Is Blockchain?</a></h1>
<p>What is blockchain?</p>
<p>Blockchain is a decentralized distributed system formed through cryptography.</p>
<p>Wait, what does decentralization mean?</p>
<p>Don't worry, let me explain it one step at a time.</p>
<br>
<br>
<p>Suppose a few neutron star beings want to establish an online banking system called &quot;Neutron Star Bank.&quot; They purchase a server to handle all requests. The balance and transaction information for all users are stored on this single server. Thus, Neutron Star Bank begins its operations.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/WhatistheBlockchain/image-20230512185621148.png" style="zoom:40%;" />
</div>
<p>As online payments become increasingly popular, the number of users and use cases continue to grow, leading to exponential growth in transaction data.</p>
<p>The capabilities of a single server are continuously challenged, and it starts to struggle: </p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/WhatistheBlockchain/image-20230512162525366.png" style="zoom:33%;" />
</div>
<p>For one thing, storage capacity is insufficient to meet the massive storage demands of transaction data; for another, during shopping frenzies like Double 11 and 618, system access volume surges, CPU loads continue to climb, and overload situations occur frequently. Even more severe, server failures sometimes occur, resulting in the entire system becoming paralyzed and transaction data being lost.</p>
<br>
<p>The growth in business is putting a heavy strain on the system, and to prevent system paralysis, the neutron star beings decide to scale and optimize the system:</p>
<p>They purchase one server to act as an &quot;administrator&quot; and several additional servers dedicated to data storage. When the administrator server receives transaction data, it forwards it to the servers responsible for data storage. Once one server is full, the data is stored in another server.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/WhatistheBlockchain/image-20230717094647994.png" style="zoom:40%;" />
</div>
<p>If the administrator becomes overwhelmed, more administrator servers can be added. In this way, the system is finally expanded.</p>
<p>However, at this point, a group of hackers set their sights on Neutron Star Bank. After all, money is just a string of numbers, and by secretly infiltrating the bank's database to modify account balances and transaction records, they could achieve financial freedom.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/WhatistheBlockchain/image-20230717095157658.png" style="zoom:35%;" />
</div>
<p>Initially, the bank's system lacked proper protection measures, making it vulnerable to attacks.</p>
<p>After paying a heavy price, the bank realized the severity of the issue and began implementing a series of measures to protect their system: first, they purchased several servers for data backup, backing up data every 3 hours. Then, they deployed an independent sentinel monitoring system on the network, dedicated to protecting the system's security.</p>
<br>
<p>With these security forces in place, the system's safety was greatly enhanced, and hackers could no longer use their previous attack methods.</p>
<br>
<p>Since all of the servers were located within Neutron Star Bank's building, the hackers thought: if they couldn't break into the system, they might as well physically attack it üòé. They planned to borrow a large sum of money from the bank, then destroy the bank's servers. Alas, the servers would be dead, and there would be no evidence left.</p>
<p>Fortunately, the security at the bank's entrance was not to be trifled with; who would bring a bomb to a bank? The security intercepted the bomb, successfully preventing the hackers from physically destroying the servers.</p>
<br>
<p>This incident frightened the bank, as it became apparent that having the servers in the bank building was not safe. What should they do?</p>
<p>They needed to come up with a foolproof plan to ensure the security of the servers.</p>
<br>
<p>So, Neutron Star Bank decided to establish a dedicated data centre and independently protect all network devices, such as routers, switches, and interfaces.</p>
<p>The requirements for building the data centre were very strict: it could not be near railways, highways, airports, chemical plants, landfills, nuclear power stations, munitions factories, gas stations, or any other facilities posing safety risks. It also couldn't be located in flood-prone or earthquake-prone areas, nor could it be in areas with high crime rates. Despite these precautions, the bank still feared sudden natural disasters, so they built the data centre with flood protection and 8-level earthquake resistance.</p>
<p>In addition to finding a suitable location, the data centre had to meet many strict construction standards, including building materials, internal heating, ventilation, and air conditioning systems, lighting systems, fire suppression systems, lightning protection measures, and constant temperature and humidity control, among others.</p>
<br>
<p>If the hackers managed to cut off the power supply to the data centre, the entire system would be paralyzed, and even the most secure equipment wouldn't function without electricity.</p>
<p>To address this concern, two power plants were set up near the data centre to provide electricity simultaneously. Each power plant could meet the data centre's entire power demand, with a backup power supply in case both power plants experienced outages. Each power plant was equipped with an independent power distribution room.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/WhatistheBlockchain/image-20230717092740474.png" style="zoom:40%;" />
</div>
<p>No, it's still not reassuring enough. What if, after a city-wide power grid interruption, both power plants experience accidents and can't generate electricity?</p>
<p>No worries, the data centre is also equipped with a UPS room. This room houses a multitude of batteries that can support the data centre's full-load operation for over 15 minutes.</p>
<br>
<p>Even if hackers cut off the power supply to the data centre, it can still maintain operation for a period through the UPS uninterrupted power supply.</p>
<p>Can power be restored within 15 minutes? There's no rush. That's because the data centre is also equipped with generators and fuel storage tanks, capable of supporting full-load operation for more than 12 hours.</p>
<p>Additionally, the bank has signed agreements with at least two nearby gas stations to ensure diesel supply within 4 hours. Though relying on fuel delivery is not a long-term solution, it's more than enough to support operations for a week.</p>
<br>
<p>What if the fuel storage tanks catch fire, as they're full of oil?</p>
<p>The data centre's fire detection system consists of a temperature sensing system, a video system, and on-duty personnel keeping watch. Upon detecting a fire, the fire suppression system extracts a portion of gas and then releases heptafluoropropane. This substance is colorless and odorless, killing stealthily and invisibly ‚Äî wait, no, it's actually colorless, odorless, low-toxicity, non-conductive, non-polluting, and non-corrosive.</p>
<br>
<p>Won't people inside be suffocated?</p>
<p>When the data centre's fire suppression system is activated, alarm bells ring, and the access control system automatically cuts off power, allowing personnel to evacuate the affected area. Even if they cannot leave in time, the data centre is equipped with a sufficient number of oxygen masks.</p>
<br>
<p>However, no matter how many safety measures are taken, a single data centre cannot guarantee the system's absolute security.</p>
<p>During the 9/11 attacks in 2001, Morgan Stanley's data centre in the World Trade centre was completely destroyed. However, thanks to a mature disaster recovery system, all business operations were restored the next day. Despite the total destruction of their 25-story office space in the World Trade centre and the emergency evacuation of over 3,000 employees, a secondary office was established within half an hour at the disaster recovery centre, and all business operations resumed the following day. Conversely, some companies had to file for bankruptcy due to inadequate backup disaster recovery systems.</p>
<br>
<p>You see, having another data centre would be beneficial in such situations.</p>
<p>This is what's known as a &quot;dual-active data centre,&quot; where two data centres operate simultaneously. If one is destroyed, the other continues to function, leaving the system virtually unaffected.</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/WhatistheBlockchain/image-20230717094041999.png" style="zoom:35%;" />
</div>
<p>What if, by chance, an asteroid strikes the very area where the data centre is located? Wouldn't everything be wiped out in one fell swoop?</p>
<p>No worries, there's a remote disaster recovery data centre. If both primary data centres fail, operations can be switched to the remote disaster recovery centre, which has the same configuration and is ultra-secure.</p>
<br>
<p>What if the remote disaster recovery data centre is also destroyed?</p>
<p>At that point, the system would truly be down, but the data would still be safe. That's because there's a cold backup in place, which doesn't run within the system but operates independently. The backup system performs incremental backups every 2 hours and is housed in several other cities.</p>
<br>
<p>Have you noticed? After all these preparations, the ultimate goal is singular: <strong>to ensure the smooth operation of the system and maximize its reliability as much as possible</strong>.</p>
<br>
<p>Although distributed systems are geographically distributed in different places with multiple data centres undertaking business. But all servers still need banks for protection. This is a centralized approach, and many people are calling for visibility, choice and reasonable control over existing networks and data. Users need the right to know who can access their data, how their data is used, and if users don't want to share certain data, we also have the right to refuse. Perhaps most importantly, users want their own data to be used for their own benefit. If you are interested in the history of this, you can take a look <a href="0.JourneytoWeb3/ThingsaboutCryptoPunks.html">here</a> first.</p>
<br>
<p>So what is the essence of blockchain?</p>
<p>A globally distributed network, a &quot;decentralized&quot; system, a &quot;shared distributed&quot; system, a &quot;fault tolerant, disaster tolerant&quot; system.</p>
<br>
<p>The concept of blockchain consists of two parts: &quot;blocks&quot; and &quot;chains&quot;. Let's start with &quot;blocks&quot;. Blocks are like pages in a ledger that contain some information. In the blockchain world, this information is usually transaction records, such as A transfers 10 bitcoins to B, which is a transaction. Packaging a certain number of transactions together forms a block.</p>
<p>Now let's look at &quot;chains&quot;. The concept of chains is very simple, just connect these blocks in a certain order. With chains, we can trace the connection between each block. Each newly generated block is connected to the previous block to form a chain.</p>
<br>
<p>Looking at the birth and development of digital currencies, although we have achieved efficient circulation of money in digital form, this digitalization is still quite primitive. We have to rely on numerous third-party intermediaries to ensure the circulation of digital money, which not only introduces risks of centralization, but also increases transaction costs.</p>
<p>It is against this background that blockchain was born. Given the inseparability of information and value, after having a global efficient and reliable information transmission system like the Internet, we would inevitably require a value transmission system to match it. In other words, the emergence of blockchain is not accidental, but has profound underlying logic. The name &quot;blockchain&quot; may be incidental, but the emergence of a system to realize blockchain functions is inevitable.</p>
<p>Credit is the true raw material for creating currency. Blockchain makes possible a peer-to-peer electronic cash system - Bitcoin - by constructing an economic system that can quantify credit. Or in other words, blockchain creates a digital, peer-to-peer transmittable credit system for value.</p>
<br>
<p>The full picture of the blockchain is: a series of blocks arranged in chronological order, connected together by a specific algorithm. This structure ensures the security and integrity of the data.</p>
<p>Next, we need to understand an important concept - encryption. In the blockchain, each block has a unique digital string called a &quot;hash value&quot;. The hash value is generated by an algorithm called a &quot;hash function&quot;. This algorithm is magical, even if only a small piece of information is changed, the hash value will change dramatically. This ensures the security of the blockchain, because tampering with any block information will change the hash value and affect all subsequent blocks.</p>
<br>
<p>Another key concept is &quot;decentralization&quot;. In a traditional database, data is controlled by a centralized institution. This means that if there is a problem with this institution, the security of the entire system will be affected. The blockchain is different, it is jointly maintained by tens of thousands of computers around the world. These computers are called &quot;nodes&quot;.</p>
<p>The decentralized nature of the blockchain means that it does not rely on a single centralized entity to maintain the data. Traditional databases are controlled by a centralized institution. In this way, if there is a problem with this institution, the security of the entire system will be affected. The blockchain, on the other hand, is jointly maintained by tens of thousands of computers around the world. These computers are called &quot;nodes&quot;. For a transaction to be recorded on the blockchain, it must reach a consensus from most nodes. This brings many advantages, such as higher security, better privacy protection, lower operating costs, etc. On the blockchain, for a transaction to be recorded on the blockchain, it must reach a consensus from most nodes. This consensus mechanism ensures the transparency and security of the blockchain.</p>
<br>
<p>So how to reach a consensus? Here we take Bitcoin as an example. Bitcoin uses a consensus mechanism called &quot;Proof of Work&quot; (PoW). The core idea of Proof of Work is to let nodes participate in competition and compete for the right to keep accounts by solving a complex mathematical problem. Whoever solves this problem first has the right to package transactions into a new block and add it to the blockchain. At the same time, other nodes will verify this block and accept it after confirming that it is correct. This process is known as &quot;mining&quot;.</p>
<br>
<p>The mining process ensures the security and decentralization of the blockchain. However, this method also has some problems. For example, it requires a lot of computing power and energy consumption. To solve this problem, other consensus mechanisms have emerged, such as &quot;Proof of Stake&quot; (PoS) and &quot;Delegated Proof of Stake&quot; (DPoS).</p>
<p>Proof of Stake (PoS) is a more environmentally friendly consensus mechanism. In a PoS system, a node's right to keep accounts depends on the amount of currency it holds. Nodes with more currency have a higher probability of obtaining the right to keep accounts. This method reduces energy consumption but may lead to uneven distribution of currency.</p>
<p>Delegated Proof of Stake (DPoS) is a variant of PoS. In a DPoS system, token holders can delegate their token interests to other nodes, allowing them to keep accounts on their behalf. This can further reduce energy consumption while improving system efficiency and security.</p>
<br>
<p>Blockchain is like a public, secure, distributed ledger. It can be used to record transactions, store data, and more. Blockchain technology has already been applied in many fields, such as finance, the Internet of Things, healthcare, and more. Blockchain technology has a lot of potential for the future. Other technologies such as AI and VR improve productivity. Blockchain changes the way that work is organized.</p>
<p>There are two main points:</p>
<p>First, use technology to solve the &quot;trust&quot; problem.</p>
<p>Second, achieve &quot;autonomy&quot; based on technology.</p>
<br>
<p>For example, in a massive multiplayer online game set many years in the future like Ready Player One, character and equipment assets must be stored on the blockchain, otherwise game companies or hackers could tamper with the data at will.</p>
<br>
<p>In the world of blockchain, you only need a blockchain account identity to join any network without permission, without sacrificing privacy or paying costs to use a service. Unlike the Web2 era when commercial value was completely controlled by major platforms, Web3 is built on decentralized networks. Application developers are responsible for developing and deploying to the blockchain platform. Once deployed on the blockchain, they cannot monopolize and use user data. This will fundamentally change business logic and the attribution of commercial value, creating a fairer internet business environment and breaking the monopoly of industry giants.</p>
<p>The blockchain emphasizes equality, fairness, democracy and autonomy more, which is completely inherited from the idea of communist society. In the blockchain network, the mechanisms of shared interests and democratic autonomy will curb the emergence of all monopolistic giants. The way to accumulate wealth by exploiting the surplus value of users and content creators has been completely subverted.</p>
<br>
<p>The application scenarios of the blockchain are very extensive, covering all aspects of daily life, health care, energy charity, elections and finance:</p>
<ul>
<li>Digital currency: The most famous application of blockchain is digital currency, such as Bitcoin and Ethereum. Digital currency is a kind of virtual currency based on blockchain technology, which can be used for point-to-point transactions without going through centralized financial institutions.</li>
<li>Smart contract: A smart contract is a blockchain-based, automatically executed contract. It can automatically trigger corresponding operations when certain conditions are met, thereby reducing the cost and risk of contract execution. Platforms such as Ethereum support smart contracts, enabling developers to build various decentralized applications (DApps) on the blockchain.</li>
<li>Supply chain management: Blockchain can be used to track the circulation of goods in the supply chain. This can improve the transparency of the supply chain, prevent counterfeit products, and reduce costs.</li>
<li>Identity authentication: The blockchain can be used as a decentralized identity authentication system to help users verify their identity on the network. This can reduce dependence on centralized institutions and improve privacy protection.</li>
<li>Copyright protection: Blockchain can be used to store and verify intellectual property information to prevent piracy and counterfeiting. This is very valuable for creators and intellectual property owners.</li>
<li>Cross-border payments: Digital currencies can be used to make cross-border payments, which can reduce the fees and time costs of remittances.</li>
</ul>
<ul>
<li>Internet of Things: The blockchain can be used to record and verify the data of Internet of Things devices to ensure data security and integrity.</li>
<li>Healthcare: Blockchain can be used to store and share medical data, improve data security and availability. This helps to improve medical standards and reduce medical costs.</li>
<li>Energy trading: Blockchain can be used to record and verify energy transactions, such as solar energy and wind energy. This helps to achieve decentralization of the energy market and improve energy utilization efficiency.</li>
<li>Election voting: Blockchain can be used to build a transparent and secure election voting system. This can prevent election fraud and increase democratic participation.</li>
<li>Charity: Blockchain can be used to track the flow of charitable donations to ensure that donations are truly used for those in need. This helps to increase the transparency of charities and enhance public trust in charitable organizations.</li>
<li>Financial services: Blockchain can be used to build decentralized financial service platforms such as lending, insurance, and securities. This can reduce the cost of financial services and improve the efficiency and security of the financial system.</li>
<li>Automotive industry: Blockchain can be used to record the life cycle information of vehicles such as production, sales, and maintenance. This helps to improve the transparency of the automotive industry and prevent fraud in the used car market.</li>
<li>Real estate: Blockchain can be used to record real estate transaction information, simplify real estate transaction processes, and reduce transaction costs. In addition, real estate transactions can be automated through smart contracts.</li>
<li>Education: Blockchain can be used to store and verify educational information such as degrees and certificates. This helps to prevent degree fraud and improve the credibility of the education system.</li>
<li>Social media: Blockchain can be used to build decentralized social media platforms to protect users' privacy and data security. In addition, blockchain can also be used to incentivize content creators and achieve fair income distribution.</li>
<li>Game industry: Blockchain can be used in the game industry for virtual asset transactions, copyright protection, and more. Through blockchain technology, players can have truly digital assets in the game and realize cross-game asset circulation. resources: Blockchain can be used for human resource management, such as recording employees' work experience, skills, and performance. This helps simplify the recruitment process, improve recruitment efficiency and accuracy.</li>
<li>Legal services: Blockchain can be used to store and verify legal documents such as contracts and wills. This helps improve the efficiency of legal services and reduce the cost of legal services.</li>
<li>Food safety: Blockchain can be used to track the circulation of food in the supply chain to ensure food safety and quality. This helps prevent food safety issues and boost consumer confidence.</li>
</ul>
<br>
<p>The above are only some of the applications of blockchain technology across different fields. As the technology develops and innovates, blockchain will unleash great potential in even more areas. At the same time, we should also pay attention to the challenges brought by blockchain technology, such as energy consumption, network congestion, privacy protection, etc. Continued discussion and improvement of blockchain technology will contribute to creating a more secure, transparent and efficient value internet digital world.</p>
<br>
<p>The value internet is an emerging concept that arose after the maturation of the information internet, especially after the spread of the mobile internet. The core characteristic of the value internet is enabling interconnection and intercommunication of funds, contracts, digitalized assets and other forms of value. Just as the information internet enabled interconnected information sharing, in the era of the value internet, people will be able to transfer value on the internet as conveniently, securely and inexpensively as transferring information. The relationship between the value internet and information internet is not one of replacement, but rather the value internet builds on top of the information internet by adding attributes of value, gradually forming a new internet that enables both information and value transfer.</p>
<p>Broadly speaking, the prototype of the value internet can be traced back to the 1990s, when the First Security Bank of the United States began providing online financial services in 1996. China also saw its first online payment in 1998. After that, many financial institutions leveraged internet technology to expand payment services, giving rise to models like third-party payments, big data finance, online financial portals, etc. The value internet-related industries represented by online finance continued to develop, and characteristics of the value internet gradually emerged. Especially since 2010, with the explosive growth of online finance, the scope and degree of interconnected value continued to increase, and the scale and capabilities of the value internet saw preliminary development.</p>
<p>The emergence of blockchain has opened up new room for development of the value internet, triggering a new stage of development. It can be said that before the appearance of blockchain, the value internet was still in a very primitive stage of development, basically adopting a fragmented development model centered around some intermediary institutions. Blockchain has inherent characteristics like decentralization, transparency, trust and self-organization, making its applications easier to proliferate globally without geographical boundaries, injecting new meaning into the value internet. With the gradual development of applications, blockchain will promote the formation of a large-scale, true value internet.</p>
<p>Blockchain applications in various fields, built on top of the information internet, have derived new mechanisms for value storage and transfer, promoting rapid development of the value internet. Blockchain application cases and models in different fields demonstrate that it can effectively facilitate value internet construction by providing infrastructure, expanding user base, and reducing societal transaction costs. It is a key technology for the future development of the value internet.</p>
<br>
<p>Cloud computing is a model that enables convenient, on-demand access to computing resources (including networks, servers, storage, applications and services, etc.) through a network on a pay-as-you-go basis, improving their availability. These resources come from a shared, configurable resource pool, and can be acquired and released with minimal effort and no human intervention.</p>
<p>At present, cloud computing encompasses distributed computing, utility computing, load balancing, parallel computing, network storage, hot backups, redundancy and virtualization and other computer technologies. It is the result of the integration and evolution of these technologies. There are still some problems in the industrial development of current cloud computing technologies: first, the cloud computing market is highly centralized, with a few internet tech giants monopolizing the entire market relying on their highly centralized server resources; second, the over-centralization of cloud computing leads to high prices of computing services, making computing power a scarce resource, greatly limiting enterprise demand for cloud adoption.</p>
<p>Cloud computing is a pay-as-you-go model, while blockchain is a distributed ledger database, a system of trust. From their definitions, they do not seem directly related, but blockchain as a resource has on-demand supply needs, and is also a component of cloud computing, so their technologies can be mutually integrated.</p>
<br>
<p>Relying on blockchain to achieve distributed cloud computing architectures, blockchain-based distributed cloud computing allows on-demand, secure and low-cost access to the most competitive computing capabilities. Decentralized applications (DApps) can automatically search, locate, provide, use and release all required computing resources through the distributed cloud computing platform, while also making it easier for data providers, consumers and others to obtain required computing resources. Using blockchain's smart contracts to describe the characteristics of computing resources can achieve on-demand scheduling. Blockchain-based distributed cloud computing is likely to become the future direction of cloud computing development.</p>
<p>The &quot;decentralized cloud&quot; aims to build a universally scalable computing substrate that does not require trust. This is a long wished-for technology that would make developing Dapps incredibly simple - people would just need to apply their imagination to innovate, unconstrained by scale or communication complexity, so that innovation could continue to compound without diminishing returns.</p>
<br>
<p>At this stage, blockchain is mostly software innovation. When the public starts to accept the &quot;decentralized cloud&quot;, composability with trust will become a superpower for developers. When developers can do more with fewer resources, we will all benefit from more collaboration, creativity and choice on the internet.</p>
<br>
<p>Continue reading <a href="0.JourneytoWeb3/JourneyoftheDreamWeaver.html#point-line-surface-solid">Dominic's story</a>.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><p>Ethereum is a decentralized platform that allows developers to build various applications on top of it. You can imagine it as a global computer that does not rely on any central server. This computer runs smart contracts - programs that automatically execute predetermined tasks.</p>
<br>
<p>Smart contracts are a concept proposed by Nick Szabo in the 1990s, almost as old as the internet itself. Due to the lack of a trustworthy execution environment, smart contracts were not applied in real industries until the birth of Bitcoin. People realized that the underlying technology of Bitcoin, blockchain, provides a native trustworthy execution environment for smart contracts.</p>
<p>Ethereum is a platform that provides various modules for users to build applications on, which is the core of Ethereum technology. The applications built on top of the platform are essentially contracts. Ethereum offers a powerful contract programming environment, enabling the implementation of complex business and non-business logics through contract development. By supporting contract programming, blockchain technology provides many more commercial and non-commercial use cases beyond just issuing cryptocurrencies.</p>
<br>
<p>You can think of it as a huge computer that can run all kinds of applications. But this computer is not a physical entity, it is a virtual network maintained collectively by many people. We call these people &quot;nodes&quot;, distributed around the world, jointly maintaining the Ethereum network.</p>
<br>
<p>So what's the difference between Ethereum and computers we commonly use? The biggest difference is that Ethereum is decentralized. That means data is not stored on a central server, but distributed across many different nodes. This makes the data difficult to tamper with and attack because an attacker would need to compromise thousands of nodes simultaneously.</p>
<p>Now we know Ethereum is a decentralized and giant computer. So how do we run applications on this computer? The applications running on Ethereum are called smart contracts. A smart contract is essentially a piece of program code that executes automatically when certain conditions are met. This automatic execution feature makes smart contracts applicable in many fields like finance, gaming, and voting.</p>
<p>As a simple example, we can use a smart contract to implement an automatic payment system. For example, you need to pay someone but you want to pay only after they complete a task. You can deposit the money into the smart contract and set a trigger condition. When the other party completes the task, the smart contract will automatically transfer the money to them. This way you don't have to worry about them taking the money without doing the work or you forgetting to pay.</p>
<p>In order to run smart contracts on Ethereum, we need a digital currency as &quot;fuel&quot;. This currency is called &quot;Ether&quot; (ETH for short). Every time we execute an operation on Ethereum, we need to consume a certain amount of Ether. This Ether is awarded to the nodes that maintain the Ethereum network as a reward. This process is called &quot;mining&quot;.</p>
<p>Smart contracts on Ethereum can not only perform simple transfers, they can also create an entirely new digital currency, which we call a token. Tokens can represent anything, like stocks, points, properties, etc. Through smart contracts, we can easily issue our own tokens on Ethereum and then use these tokens to transact.</p>
<p>There are many types of tokens on Ethereum, the most common being ERC-20 tokens. ERC-20 tokens are tokens that follow a uniform standard, which specifies how the tokens are created and transacted. With this standard, different tokens can interexchange and transact with each other, just like fiat currencies from different countries can still be exchanged.</p>
<p>In addition to ERC-20 tokens, there is also a token standard called ERC-721. These tokens are unique in that they represent unique and non-fungible assets. These assets can be artwork, collectibles, properties, etc. With ERC-721 tokens, we can transact unique assets on Ethereum without worries of forgery or replication. This is also why many crypto arts and collectibles are traded on Ethereum.</p>
<br>
<p>So what are the practical applications of Ethereum? In fact, Ethereum has had an impact in many fields. For example:</p>
<p>Ethereum can be used for financial services. Through smart contracts, we can create decentralized financial products such as lending, insurance, and derivatives. These financial products do not require intermediaries, so they can reduce costs and improve efficiency. At the same time, the transparency of smart contracts can also reduce the risk of fraud.</p>
<p>Ethereum can be used for supply chain management. Through smart contracts, we can track information about the source and distribution channels of goods in real time. This allows consumers to ensure that the products they buy are genuine and reliable, and allows companies to better monitor supply chains and improve efficiency.</p>
<p>Ethereum can also be used for identity authentication. Through smart contracts, we can create a decentralized identity system that allows users to share authentication information across different platforms. This way, users do not have to resubmit their personal information each time, while still being able to protect their privacy.</p>
<br>
<p>Although Ethereum has many advantages, it also has some limitations. For example, Ethereum's current transaction speed and scalability still needs to improve. In order to solve these problems, the Ethereum team is carrying out a series of upgrades. Ethereum 2.0 aims to address the performance bottlenecks and scalability issues in Ethereum 1.0. This upgrade will have the following impacts on Ethereum's performance:</p>
<ol>
<li>Higher throughput: Ethereum 1.0's current transaction processing speed is limited to around 30 transactions per second. Ethereum 2.0 introduces sharding technology, which splits the network into multiple independent sub-chains, greatly improving the overall network's transaction processing capability. Ethereum 2.0's throughput is expected to reach thousands of transactions per second.</li>
<li>Lower latency: In Ethereum 1.0, each block takes about 15 seconds to produce. This means that users have to wait for their transactions to be confirmed. Ethereum 2.0 will adopt a new consensus mechanism to reduce block time and thus reduce users' waiting time for transaction confirmation.</li>
<li>More eco-friendly consensus mechanism: Ethereum 1.0 uses the energy-intensive Proof of Work (PoW) consensus mechanism. Ethereum 2.0 will gradually transition to the more eco-friendly and efficient Proof of Stake (PoS) consensus mechanism. Under the PoS mechanism, validating nodes (validators) have to stake a certain amount of Ether as collateral to gain block production rights, which reduces energy consumption and improves network security.</li>
<li>Higher security: Ethereum 2.0 introduces a new role called &quot;validators,&quot; which replaces the miners in Ethereum 1.0. By requiring validators to stake a certain amount of Ether to participate in consensus, it becomes more costly to attack the Ethereum 2.0 network, thus improving security.</li>
<li>Higher scalability: Ethereum 2.0's sharding technology and other optimizations can improve the network's scalability.</li>
</ol>
<br>
<p>While Ethereum has brought many innovations to the blockchain world, it still has some shortcomings, mainly including the following points:</p>
<ol>
<li><strong>Scalability issues</strong>: Although Ethereum has upgraded its scalability, this does not mean that the scalability issue is permanently solved. This is not a one-time engineering effort, if the number of users continues to increase, engineers still need to further scale and improve Ethereum.</li>
<li><strong>Transaction fees are still relatively high</strong>: Because Ethereum's processing capacity is limited, users usually have to pay higher fees for their transactions to be processed faster. This has led to expensive transaction fees on Ethereum, making it difficult for some users and developers to bear. During network congestion, transaction confirmation may take a long time, which can also lead to rising transaction fees.</li>
<li><strong>Centralization issues</strong>: Although the original intent of blockchain is decentralization, traditional blockchain technology has some degree of centralization issues, which gives some nodes too much control over the entire network, bringing security and manipulation risks.</li>
<li><strong>Privacy protection issues</strong>: Traditional blockchain technology has privacy protection issues. Once transaction data is recorded on the blockchain, it will be permanently saved, which will pose a great risk of privacy leakage.</li>
<li><strong>Development and maintenance costs</strong>: Building and maintaining blockchain applications may require high development and operational costs. In addition, the constant development of blockchain technology means that developers need to continually update and optimize existing applications.</li>
</ol>
<br>
<p>Compared to Ethereum, IC has the following features that can solve some of Ethereum's issues:</p>
<ol>
<li><strong>Infinite scalability</strong>: IC uses a technology called &quot;Chain Key&quot; that allows the network to run more efficiently. IC also divides the network into many subnets, each subnet handling a portion of messages.This greatly improves the network's processing capability to better cope with high transaction volume.</li>
<li><strong>Lower transaction fees</strong>: Due to IC's better scalability, the network can process more transactions, meaning users no longer need to pay high fees to speed up transactions. Therefore, Dfinity's transaction fees will be relatively low.</li>
<li><strong>Consensus algorithm</strong>: IC uses a consensus algorithm called PoUW, which is a random consensus algorithm based on BLS threshold signatures. Compared to other Proof-of-stake (PoS) or Proof-of-work (PoW) systems, PoUW aims to provide higher security and performance.</li>
<li><strong>Scalability and performance</strong>: IC's design gives it a high degree of scalability and performance. Through adopting a tiered architecture, subnets and parallel processing technologies, IC's Internet Computer can support a large number of concurrent transactions and smart contract executions. IC's goal is to achieve higher throughput and lower latency compared to other public chains.</li>
<li><strong>Interoperability</strong>: IC's Internet Computer is designed to be a platform that supports various decentralized applications and services. Although interoperability is not its primary focus, IC's design allows developers to easily build and deploy various applications on the Internet Computer, thereby enabling interoperability across applications.</li>
<li><strong>Simpler development process and easier maintenance</strong>: IC aims to lower the learning cost and development difficulty for developers. It allows developers to write smart contracts using more familiar programming languages. This makes it easier for developers to get started and develop decentralized applications.</li>
<li><strong>Better security</strong>: IC also provides a network autonomy mechanism whereby the network can self-repair and upgrade, which helps improve the overall security and stability of the network.</li>
<li><strong>Security and decentralization</strong>: IC's consensus algorithm and network design aims to achieve a high degree of security and decentralization. Compared to other public chains, IC uses some innovative technologies such as threshold relays and distributed key generation to improve the network's resistance to attacks.</li>
<li><strong>Developer experience</strong>: IC provides a set of friendly development tools and resources, including the Motoko programming language and SDK. Code debugging can also be done locally without the need for a testnet. This makes it easier for developers to build and deploy applications to the Internet Computer. Compared to other public chains, IC is committed to simplifying the development process of decentralized applications.</li>
</ol>
<p>IC aims to become an infinitely scalable, decentralized global compute infrastructure. <strong>IC's goal and vision</strong>: IC's goal is to create a new type of Internet infrastructure that can support various decentralized applications while having high scalability, security and performance. Like other public chains, IC is committed to solving the limitations of traditional blockchain technology; but its vision is to create a larger Internet ecosystem, not just a blockchain platform.</p>
<div style="break-before: page; page-break-before: always;"></div><p>This is a rather serious problem. Although the Internet can store your data, your data will not necessarily be permanently preserved by the Internet. Because now most applications' back-ends are &quot;independent&quot;. Each company has its own maintained servers, either self-built computer rooms or cloud services. All users transmit network information and interact with other users by accessing their servers. Once the company announces service termination, your data will be gone.</p>
<p>For example, TikTok is like this:</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/Whathappenedtomyprivacyontheinternet/QmdntMWgDMfqHCyCzZWfDDrcvwHQoCLempCAk3rCdh3CkH.png" style="zoom:25%;" />
</div>
<p>Each company's servers provide users with their own network services:</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/Whathappenedtomyprivacyontheinternet/QmRbMqtLf8Y7eYWeUdmRxeswrmRRUHLnc5UPMTuaCnBnPH.png" style="zoom:21%;" />
</div>
<p>While data brings convenience to the information age, it also leads to data abuse, personal privacy leaks, infringement of corporate trade secrets and many other problems. Your data has been dumped into their servers in one swoop. They control the servers and have the final say in how to handle the data in the servers. Although engineers are only responsible for studying AI recommendation algorithms and do not peek at your data. Only AI knows what you like, stored in servers, and there are too many user data to see. But when they want to find someone, the management can still see all kinds of data.</p>
<br>
<p>The data contains your privacy, <strong>what you bought today, what you chatted about, what you like to watch, what you want to eat at night, taste preferences, height and weight when buying clothes, map positioning</strong>... can all be analysed through data. They can completely monitor your every move on the network.</p>
<p>You may say: Who asked them to see my data! Indecent! Help! Is anyone in charge?</p>
<br>
<p>But I still have to say a fair word. In fact, when you first installed the app, they would let you check a &quot;User Agreement&quot; or more euphemistically called &quot;User Experience Improvement Program&quot;. Although almost no one will read the entire &quot;User Agreement&quot; in full, you have already &quot;agreed&quot; to give them your usage data. Otherwise, you can't use it!üò°</p>
<p>Although on the surface, you agreed to the &quot;User Agreement&quot; first, and then they used your data to improve the experience.</p>
<p>No one knows what they will have done with the data.</p>
<p>We already know about PRISM, Facebook's leak of hundreds of millions of user data in 2018, Amazon was fined 746 million euros by the EU privacy regulator in July 2020 for violating the EU General Data Protection Regulation, which was also the largest data privacy leak fine in EU history. Chinese takeaway platforms such as Meituan and Ele.me have also been exposed to user information leaks and resales, down to order contents, addresses and other private information; Li Yanhong: Chinese people can be more open to data privacy and are willing to exchange privacy for efficiency...</p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/Whathappenedtomyprivacyontheinternet/Leeqj.png" style="zoom:70%;" />
</div>
<p>(Screenshot of Li Yan Hong's claim on the internet:&quot;Users are willing to exchange privacy for efficiency!)</p>
<p>And they think that unfavorable content to them can be deleted directly without your consent. (Of course, illegal content must be deleted)</p>
<br>
<p>The current situation of the Internet can be said to be: <strong>When I open my mobile phone, my apps want to read through my private information. Otherwise, you can't use it.</strong></p>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/Whathappenedtomyprivacyontheinternet/7q6n5u.jpg" style="zoom: 67%;" />
</div>
<p>The large-scale disclosure of personal privacy data has become a major global social problem in the era of big data. Internet platforms massively collect user data and centrally store users' personal information for a long time. Once the data is leaked, it will be a large-scale group incident, not only violating the user's right to privacy, infringing on the life and property safety of citizens, but also causing unpredictable economic losses to Internet companies themselves. The negative impact on corporate reputation after data leakage is also difficult to eliminate.</p>
<br>
<p>Just last week, on March 21, 2023, Pinduoduo was forcibly removed from Google Play and prompted existing Pinduoduo users to uninstall it as soon as possible. This was the first time Google prompted users to uninstall an app. Subsequently, the well-known antivirus software laboratory Kaspersky confirmed that Pinduoduo recklessly collected user information by exploiting vulnerabilities in the Android system, cracked system shielding mechanisms, tampered with mobile phone system records, concealed its own whereabouts, ran in the background of the system to monitor mobile phones, evaded system cleanup processes, and read mobile phone input method information.</p>
<p><img src="0.JourneytoWeb3/assets/Whathappenedtomyprivacyontheinternet/125.png" alt="125" /></p>
<p>(A famous shopping app in China: Pinduoduo. Had been exposed that they implemented malicious code in users' device for purpose of tracking and collecting users' information)</p>
<br>
<div class="center-image">
    <img src="0.JourneytoWeb3/assets/Whathappenedtomyprivacyontheinternet/QmQ3RstyXP52LdWbDLdmrLyTKLbz8kkaKeEN3mbsBpRKxV.png" style="zoom:63%;" />
</div>
<blockquote>
<p>The malicious behaviours and functions of Pinduoduo including:</p>
<ol>
<li>Collect user's images and social relationships.</li>
<li>Install apps in the background when users clicked on certain links</li>
<li>Reading information from user's phone keyboard.</li>
<li>Produce fake notifications by hijacking Alarm,wallpaper and calander.</li>
<li>Making fake icons in the main page which users are unable to uninstall, keep running and consume battery in the background.</li>
<li>Delete record of access to system information when Pinduoduo's app is running, or a virus detecting app is on.</li>
<li>Act as communication app such as Wechat and mislead users to run it.</li>
<li>Stealing message records from communication apps, browser history, ban users from using apps from competitors. </li>
</ol>
</blockquote>
<br>
<p>Damn it! It's so hard to store information, it's better to engrave it on stone!</p>
<p>The essence of this phenomenon lies in the fact that users do not have their own data rights. Your own data, you don't even have the data rights!</p>
<p>Users should have the right to know how their personal information is collected, used and shared, the right to decide how their personal information is used and shared, and the right to control how their personal information is collected, stored and used. Then if I want to delete some privacy data, hey hey, you don't even know if they will really delete the content you want to delete. They can even hide the information and secretly save it themselves.</p>
<br>
<p>Continue exploring <a href="0.JourneytoWeb3/NavigatingtheFrontiersofTomorrow.html#the-coachman-and-the-driver">the future of blockchain technology</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Unlike traditional currencies, Bitcoin is completely virtual.</p>
<p>Bitcoins exist hidden within the exchange of value between senders and recipients. Bitcoin users have keys that allow them to prove within the Bitcoin network that they have authority to transact bitcoins, which can then be spent, bought, sold and exchanged for other currencies once decrypted. Due to Bitcoin's fast, secure and borderless nature, in some sense Bitcoin represents the perfect form of an internet currency.</p>
<p>Bitcoin is a decentralized peer-to-peer network system. Therefore, there are no &quot;central&quot; servers or central points of control.</p>
<p>Bitcoin pioneered a solution to the problem of distributed computing.</p>
<p>Satoshi Nakamoto's invention was also a feasible solution to the &quot;Byzantine Generals Problem&quot;, an unsolved problem in distributed computing. In simple terms, the problem involves trying to achieve consensus on an action protocol through communication within an untrustworthy network that has potential threats. Nakamoto's solution was to achieve consensus without a central authority using the concept of proof-of-work, which represented a breakthrough in distributed computing science and has far surpassed mere currency applicability.</p>
<p>There is a lot of information about Bitcoin online, so I won't go into a detailed explanation here. </p>
<br>
<p>Speaking of the origins of Bitcoin, we have to talk about a rather mysterious group: the Cypherpunks. This was a loose alliance of cryptographic geniuses, and Bitcoin's innovations drew heavily from contributions by Cypherpunk members. The term Cypherpunk comes partly from &quot;cipher&quot;, which in cryptography refers to algorithms used for encryption and decryption, and partly from Cyberpunk, referring to the then-popular sci-fi genre. This combination has very subtle connotations, exuding a radical ideal of changing society.</p>
<p>The Cypherpunks' view was that modern society was experiencing an ever-growing erosion of individual privacy and rights. They exchanged views on this issue amongst each other, and believed that in the digital age, protecting privacy was crucial to maintaining an open society. This philosophy was embodied in Bitcoin ‚Äì the pursuit of decentralization and the embrace of anonymity. The Cypherpunks themselves were among the earliest propagators of digital currencies. Discussions of digital currencies were common on their email lists, with some ideas put into practice. People like David Chaum, Adam Back, Nick Szabo, Hal Finney and others did extensive early explorations in the digital currency sphere.</p>
<p>Bitcoin was not the first attempt at digital currency. Statistics show dozens of failed digital currencies or payment systems prior to Bitcoin's birth. It was these explorations that provided a wealth of experience for Bitcoin to draw from.</p>
<p>David Chaum was a cryptographic expert and a leading &quot;bishop&quot;-level figure among the Cypherpunks of the 1980s and 1990s. He invented many cryptographic protocols, and his 1981 research laid the foundations for anonymous communications. In 1990 he founded DigiCash and experimented with a digital currency system called Ecash. Payments were anonymous in his system, but recipients were not. More precisely, Ecash was a system for individuals to pay merchants. The currency system he invented also had some characteristics of bypassing intermediaries ‚Äì DigiCash acted as a trusted third party to confirm transactions and prevent double-spending, ensuring the honesty of the system.</p>
<p>Adam Back is a British cryptographer who invented Hashcash in 1997, which used a proof-of-work system. The prototype of this mechanism could be used to solve spam on the internet, for example as an anti-spam solution. It required computers to perform a certain amount of computational work before gaining permission to send information. This would have virtually unnoticeable impact on normal information transmission, but for computers mass-distributing spam to the entire network, the computations would become unbearable. This proof-of-work mechanism later became a core component of Bitcoin.</p>
<p>Haber and Stornetta proposed a protocol in 1997 that used timestamps to ensure the security of digital documents. The simple explanation is to record the chronological order of document creation with timestamps. The protocol required that timestamps could not be altered after a document's creation, making the possibility of tampering zero. This protocol became a prototype for Bitcoin's blockchain protocol.</p>
<p>Wei Dai is a cryptographer with diverse interests who invented B-money in 1998. B-money emphasized peer-to-peer transactions and tamper-proof transaction records, with each transactor in the network keeping track of transactions. However, in B-money each node maintained its own ledger, which would inevitably lead to inconsistencies between nodes. Wei Dai designed complex incentive and penalty mechanisms to prevent nodes from cheating, but did not fundamentally solve the problem. When Satoshi Nakamoto invented Bitcoin, he borrowed a lot from Wei Dai's design and had extensive email exchanges with him. </p>
<p>Hal Finney was a top developer at PGP Corporation and an important early member of the Cypherpunk movement. In 2004, Finney introduced his own electronic currency that used a reusable proof-of-work system (RPOW). Hal Finney was the recipient of the first ever Bitcoin transaction, and interacted extensively with Satoshi Nakamoto during Bitcoin's early days. Suffering from a terminal illness, Hal Finney passed away in 2014.</p>
<h2 id="the-birth-of-bitcoin"><a class="header" href="#the-birth-of-bitcoin">The Birth of Bitcoin</a></h2>
<p>Bitcoin was born in September 2008, beginning with the collapse of Lehman Brothers, when the financial crisis erupted in the United States and spread around the world. In response to the crisis, governments and central banks around the world adopted unprecedented fiscal stimulus and expansionary monetary policies, providing emergency assistance to financial institutions. These measures were also met with widespread skepticism. </p>
<p>At 2:10 pm on October 31, 2008, several hundred members of an ordinary cryptography mailing list all received an email from someone calling himself Satoshi Nakamoto: &quot;I've been working on a new electronic cash system that's fully peer-to-peer, with no trusted third party.&quot; He then directed recipients to a 9-page whitepaper describing a new currency system. On November 1, 2008, the person calling himself Satoshi Nakamoto published the Bitcoin whitepaper &quot;Bitcoin: A Peer-to-Peer Electronic Cash System&quot; online, laying out an electronic cash system based on distributed ledger technology, Proof of Work consensus, cryptography and other technologies ‚Äì marking the birth of Bitcoin. </p>
<p>Two months later on January 3, 2009, the first (numbered 0) genesis block was born, taking Bitcoin from theory into practice. A few days later on January 9, 2009, block number 1 appeared and connected to the genesis block number 0 to form a chain, marking the birth of the blockchain.</p>
<p>In 2015, The Economist magazine ran a cover story titled &quot;Blockchains, The Trust Machine&quot;, pointing out the technology behind Bitcoin could change economic operating models, calling it ‚Äúa trust machine that allows people who have no particular confidence in each other to collaborate without having to go through a neutral central authority. Simply put, it is a machine for creating trust.‚Äù This resulted in increasingly more public attention on Bitcoin and blockchain.</p>
<br>
<p>Continue exploring <a href="0.JourneytoWeb3/./ThingsaboutCryptoPunks.html">the early stories of the cypherpunks movement</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<img src="1.OverviewofIC/assets/1/image-20230717100301496.png" style="zoom:50%; float: right; margin-left: 35px;" class="zoom-img"/>
<p>What are IC and ICP?</p>
<ul>
<li>
<p>IC is a high-speed blockchain network specifically designed for decentralized applications.</p>
</li>
<li>
<p>ICP is both the name of the Internet Computer Protocol and the native token.</p>
</li>
</ul>
<p>The emergence of the Internet Computer (IC) has brought revolutionary changes to software development. It allows developers to build applications directly on a decentralized cloud, free from dependence on traditional centralized cloud services, reducing development and operating costs. The security and high performance of IC greatly improves the security of applications and services.</p>
<p>The vision for IC is to become a global computing platform providing unlimited scalability, security and decentralized governance.</p>
<p>IC is built with high performance and decentralized cloud services through technologies such as sharding, VRF random numbers, BLS threshold signatures, DKG, and embedded DAO governance models.</p>
<p>How high is its performance?</p>
<p>The current confirmed block rate of subnets is 36 blocks per second.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230218171608203.png" style="zoom:67%;" />
</div>
<p>For every second, 6,355 transactions could be handled.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230218171944539.png" style="zoom:95%;" />
</div>
<p><a href="https://dashboard.internetcomputer.org/">Here</a> you can see the real-time statistics of the IC network. While the number of the subnet keeps growing, the performance of the network will also get higher. (TPS is unlimited!)</p>
<p>Currently (June 2023), each shard contains 1000 entries, meaning a subnet can process 1000 update calls per second (Actual data is slightly less than 1000 msgs/sec, around 970/sec). Each subnet does around 970 updates/sec, 4000 queries/node.</p>
<h2 id="the-new-era-of-software-development"><a class="header" href="#the-new-era-of-software-development">The new era of software development</a></h2>
<p>The Internet Computer (IC) is a brand new blockchain design built on the Internet Computer Protocol. Its core part is divided into 4 layers, running on nodes of each subnet. By running the core protocol, the nodes of a subnet implement a blockchain-based replicated state machine that progresses independently of other subnets (but communicates asynchronously with them). IC adopts a multi-subnet shards structure, which overcomes the performance bottlenecks of traditional blockchains while maintaining decentralization. This architecture allows IC to generate subnets (shards) indefinitely, allowing IC to scale almost limitlessly.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708123832309.png" style="zoom: 20%;" />
</div>
<p>In traditional non-sharded blockchains, typically only one block is produced over a period of time, with all miners in the network competing for the sole mining right or reaching consensus on a single block. To increase throughput and lower latency, scaling up often can only be achieved by speeding up block production or increasing block size. Both approaches have downsides (frequent forks or network latency).</p>
<p>IC scales horizontally by creating new subnets, similar to how traditional cloud infrastructure scales by adding new machines. Once IC's Network Nervous System (NNS) decides to create a new subnet, it will select a group of spare nodes that have not been allocated to any subnet and create the initial configuration for the new subnet. Then, the selected nodes form a new subnet blockchain.</p>
<img src="1.OverviewofIC/assets/1/gc5YGvUU_400x400.jpg" style="zoom:50%; float: left; margin-right: 35px;"/>
<p>IC eliminates the speed, storage, and computing limitations faced by smart contracts on traditional blockchains. Making smart contracts fully decentralized, from front-end to back-end can be hosted on the blockchain. IC's smart contracts are called Canisters. Canisters can store data, perform general computing on data, and provide a complete technology stack to provide network access services directly to end users.</p>
<p>Computing and storage overhead uses a &quot;reverse gas model&quot;, and <strong>gas fees</strong> are paid by the developer who deployed the Canister by exchanging native tokens ICP into Cycles. ICP tokens are also used for governance: IC is managed by a decentralized autonomous organization (<strong>DAO</strong>). IC embeds the DAO system as its base: <strong>Network Nervous System</strong>. The DAO can decide to change IC's network topology and upgrade the IC protocol.</p>
<p>IC can also interoperate with other blockchains. IC's chain key cryptography enables it to interact with other blockchains and integrate other cryptocurrencies.</p>
<p>IC uses WebAssembly (Wasm) as the standard for code execution, so developers can write smart contracts in a variety of popular programming languages (such as Rust, Motoko, Java, etc.).</p>
<p>Traditional IT developers face many problems: they have to go through a series of hurdles such as multiple commercial cloud services, cloud tools, proprietary and open source variants of operating systems, databases and firewalls, virtualization technologies, software development platforms, etc., to address the high customization of assembling systems, the labor costs of specialist developers needed to maintain them, and related vendor relationships, making it expensive and difficult to change, migrate and adjust old systems as needs change. The result is high development and operating costs, and security issues with centralized data storage.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230705124029401.png" alt="image-20230705124029401" style="zoom:33%;" />
</div>
<p>IC allows developers to build applications, enterprise systems and Internet service apps in an open world. Based on the decentralized blockchain concept, it ensures that it can operate safely and stand the test of time. IC can automatically scale, resist attacks, and never go down. This novel design allows developers to focus on creating new applications and services without worrying about the security, cost and scalability of the underlying infrastructure. This will have a profound impact on the new era of software development.</p>
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<p>IC's architecture is unique:</p>
<p>The <strong>nodes</strong> in each <strong>data centre</strong> are <strong>virtualized into replica</strong> <strong>through the node software IC-OS</strong>, and then some replicas are randomly selected to form a <strong>subnet</strong> .</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/Data Center.jpg" alt="Data Center" style="zoom:33%;" />
</div>
<p>A subnet consists of nodes from multiple data centres. Each node establishes a TCP session with IPv6 and connects to NNS nodes and other nodes in the same subnet.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230612165423635.png" style="zoom: 33%;" />
</div>
<p><strong>NNS (Network Nervous System)</strong> is the governance system embedded in IC, a DAO. Anyone who staked ICP can vote on proposals on NNS.</p>
<p>The nodes of the Bitcoin network can join whenever and wherever they want, but the problem is that the confirmation of transactions is too slow; the consortium blockchain first determines several nodes in the network, and then these few fixed nodes reach consensus, the speed is fast. IC combines the advantages from both, like a consortium blockchain composed of several fixed nodes to form subnets, the consensus speed between nodes (replicas) is very fast, and controlled by a DAO: NNS, to control subnets and nodes (replicas). Win-win.</p>
<p>IC integrates a DAO at the bottom layer of the blockchain protocol: a <strong>DAO-controlled network</strong>. This DAO controls each subnet, configures the network topology, creates subnet public keys, and upgrades the protocol version of replicas. Therefore, all NNS decisions are made by community members, and the voting weight of community members is determined by the amount of IC native governance tokens they stake in NNS.</p>
<p>If the proposal is approved by voting, the Canister in NNS will automatically execute the according decision. For example, if a proposal to change the network topology is approved, the NNS will automatically update the registry Canister with the new configuration.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/023-06-12-2125.png" alt="2023-06-12-2125" style="zoom:33%;" />
</div>
<p>NNS is also a decentralized governance system that helps the IC network achieve self-evolution. The purpose of NNS is to manage the Internet Computer network in an open, decentralized and secure manner. It is a system subnet of IC that controls IC subnets. It can also upgrade node protocols; adjust the exchange ratio of Cycles to ICP; in extreme cases, it can even freeze malicious Canisters to protect the network.</p>
<p>Replicas can be understood as &quot;virtual nodes&quot; virtualized in subnets. In the following content, we will call IC &quot;nodes&quot; as replicas.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/111111.png" alt="111111" style="zoom:80%;" />
</div>
<p>IC's subnets are similar to the idea of sharding. Sharding is a blockchain scalability solution. Take Bitcoin as an example. Nodes all over the world are competing for the accounting rights of a block, which is equivalent to a network covering the entire earth. If all nodes in Asia constitute a &quot;Bitcoin subnet&quot;, Europe, Africa, America and Oceania also constitute their own subnets. Then consensus is reached within the subnet, with relatively fewer nodes and shorter communication distances, which can improve performance.</p>
<p>IC consists of many subnets, without the concept of parent network, main chain, side chain, beacon chain, etc. Each subnet is equal (except NNS). Each subnet runs independently, reaches consensus within the subnet, and there is no &quot;global consensus&quot; like Bitcoin. Different subnets synchronize and generate blocks in parallel. It can be understood that each subnet is a blockchain, and many chains together constitute IC. Cross-subnet communication is solved by <strong>Chain Key</strong> at the bottom layer of IC. Developers and users do not need to worry about which subnet the smart contract is deployed in, how to communicate across subnets, etc.</p>
<p><strong>Chain Key</strong> is the core technology behind the Internet Computer that solves the problem of inter-subnet communication of IC. Chain Key allows each subnet to generate its own unique <strong>subnet public key</strong> (or Subnet Key) based on the <strong>root key</strong>. This is the underlying technology for IC's unlimited scalability.</p>
<p>Dude, this is so freakin' cool! Each subnet on the IC network has a public key that's just 48kb in size. Anyone can easily verify that a message they receive actually came from the IC network and wasn't tampered with. All kinds of IoT devices and other blockchains can also verify info from IC, so handy! Compared to that, verifying stuff from traditional blockchains like ETH is a pain - cuz each block is signed by different nodes, so devices gotta sync hundreds of GBs of signature data to complete verification. But on IC, all the nodes sign each block together, so devices only need to store one unique 48kb public key to verify any message from a subnet. This design is just ingenious!</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708130720418.png" style="zoom:25%;" />
</div>
<p>Subnets can dynamically increase, delete, merge and split according to the network resource usage. The number of subnets has no upper limit, so theoretically it supports &quot;infinite expansion&quot; by adding subnets around the world.</p>
<p>But who decides the splitting and reorganization of subnets? NNS!</p>
<p>NNS is a special subnet, just like other subnets composed of some nodes. <strong>NNS can manage other subnets</strong>. However, NNS has more nodes than other subnets, so its security is naturally higher than other subnets. Becoming a node in a data centre, which subnet a node joins, which nodes make up a subnet, selecting a few nodes to create a new subnet, splitting a subnet into several subnets, etc., these operations require NNS permission.</p>
<p>The architecture of many subnets allows IC to scale infinitely.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708131321649.png" alt="image-20230708131321649" style="zoom:33%;" />
</div>
<p>The core part of the IC protocol is divided into 4 layers, running on the nodes of each subnet. Now we turn our perspective into the interior of the subnet to take a look at the core protocol of IC. For easy understanding, I change the top view of the subnet to a side view; the purple square blocks represent subnets, and the blue spheres represent replicas in the subnet.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708131813975.png" alt="image-20230708131813975" style="zoom:37%;" />
</div>
<p>The IC core protocol has a total of 4 layers, and each replica has this 4-layer structure. From bottom to top are the P2P layer, consensus layer, message routing layer, and execution layer:</p>
<ul>
<li><strong>P2P layer</strong> collects and sends messages from users, other replicas in the subnet and other subnets. It ensures that messages can be delivered to all nodes in the subnet to ensure security, reliability and elasticity.</li>
<li><strong>Consensus layer</strong> reaches consensus within the subnet on the order in which various messages are processed. Then these blocks are passed to the message routing layer.</li>
<li><strong>Message routing layer</strong> forwards messages. After the consensus layer finalizes the block, the corresponding payload will be passed to the message routing layer. The message routing inputs the execution layer.</li>
<li><strong>Execution layer</strong> is where the Canister runs. The execution layer updates the state of the corresponding Canister in the replicated state machine, completes the computing task of the smart contract and passes the output to the message routing layer for processing.</li>
</ul>
<h2 id="p2p-layer"><a class="header" href="#p2p-layer">P2P layer</a></h2>
<p>The P2P network is like a large party, and the participants in the party are replicas in the subnet. At this party, people want to share the latest news and hope that as many people as possible can hear this news. However, it is tiring for everyone to shout out the complete message loudly (occupying network resources). We can adopt a more efficient approach.</p>
<p>This approach is the advertise-request-deliver mechanism. Just like at a party, someone (replica) loudly announces: &quot;Hey, I have big news to share!&quot; This is a small announcement. After hearing this announcement, others (other replicas) who heard and think that the message is important will come over (request) and ask that person to tell them the specific content of the message (deliver). This process may sacrifice some time (delay) but can save energy (reduce bandwidth usage).</p>
<p>If this party is very large, such as a huge music festival. In such a huge event, the advertise-request-deliver mechanism will run on an <strong>overlay network</strong>. This overlay network is like a large circle of friends, and everyone only shares messages with their good friends (peers).</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/1577.png" alt="1577" style="zoom:20%;" />
</div>
<p>When someone wants to broadcast a message, he will first tell his good friends about the announcement of the message. Those good friends, upon receiving the announcement, may request the delivery of the message and, under certain conditions, tell their good friends about the announcement of the message. This is like a gossip network.</p>
<p>The P2P layer can effectively reduce bandwidth usage and achieve high throughput at the cost of some latency by using the advertise-request-deliver mechanism and running on the overlay network.</p>
<p>Learn more about how the IC P2P layer works <a href="1.OverviewofIC/../2.CoreProtocol/P2Player.html">here</a>.</p>
<h2 id="consensus"><a class="header" href="#consensus">Consensus</a></h2>
<p>Consensus is reached within the subnet by replicas.</p>
<p>The task of the IC consensus layer is to sort incoming messages to ensure that all replicas process incoming messages in the same order. These messages are communications between users and Canisters, communications between Canisters, and the order of these communications.</p>
<p>By sorting replicas with unpredictable random numbers, select who to make blocks first. If the selected replica is honest and has no problems, it will package the block and broadcast to everyone for verification. If everyone agrees that there is no problem, they will provide their own notarization shares. After the threshold of two-thirds of the notarization shares is reached, a notarization of this block is formed. If most replicas have only made a notarization for one block, everyone will finalize and make a confirmation of the block.</p>
<p>The consensus protocol of IC satisfies: low latency (almost instant finality); high throughput; robustness (in the event of replica or network failures, latency and throughput will drop slightly instead of directly crashing and shutting down).</p>
<p>Learn more about how the IC consensus layer works <a href="1.OverviewofIC/../2.CoreProtocol/IntroductiontoConsensusLayer.html">here</a>.</p>
<h2 id="message-routing"><a class="header" href="#message-routing">Message routing</a></h2>
<p>In each round of IC, the consensus layer packs incoming messages into block payloads. After the consensus layer's final confirmation, the corresponding payload is passed to the message routing layer. The message routing component receives a message to be processed from consensus. Message routing routes the message to the corresponding Canister input queue. It then triggers execution. After execution is complete, the Canister places the result in the output queue. Finally, the output is passed to the message routing layer to send out.</p>
<br>
<p>The message routing layer can also communicate between subnets. This is called cross-subnet messages or XNet messages for short.</p>
<p>Another key function implemented by the message routing layer is state authentication. In each round, the subnet performs BLS threshold signature on the state changed by the subnet in this round. This authentication can be used by subnets to verify the authenticity of a data flow from one subnet to another, and also allows users to submit responses to messages submitted previously before reading. State authentication and secure XNet protocols enable Canisters to communicate securely and transparently between subnets, a challenge faced by any sharded blockchain.</p>
<br>
<p>Note that the consensus layer and the message routing layer are independent. Forks happened in consensus have already been resolved before incoming payloads. And the consensus layer can proceed to the next round in advance without keeping exactly the same progress as the message routing layer.</p>
<p>Learn more about how the IC message routing layer works <a href="1.OverviewofIC/../2.CoreProtocol/Messageroutinglayer.html">here</a>.</p>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>The basic computing unit in IC is called a Canister. IC provides a runtime environment that allows programs to run in Canisters and communicate (via messages) with other Canisters and external users.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708133700851.png" style="zoom: 50%;" />
</div>
<p>The execution layer has many functions that other blockchains do not have:</p>
<ul>
<li>
<p><strong>Deterministic time slicing (DTS)</strong>: For large messages requiring billions of Wasm instructions to execute, they can be split up and completed gradually over multiple consensus rounds. This ability to execute messages over multiple consensus rounds is unique to IC.</p>
</li>
<li>
<p><strong>Concurrency</strong>: Execute multiple Canisters simultaneously on multiple CPU cores. Since each Canister has its own isolated state.</p>
</li>
<li>
<p><strong>Pseudo-random number generator</strong>: The execution layer can access unpredictable and unbiased pseudo-random number generators. Now Canisters can execute algorithms that require randomness.</p>
</li>
</ul>
<p>Learn more about how the IC execution layer works <a href="1.OverviewofIC/../2.CoreProtocol/executionlayer.html">here</a>.</p>
<h2 id="boundary-node"><a class="header" href="#boundary-node">Boundary node</a></h2>
<p>As mentioned earlier, IC (Internet Computer) is a decentralized cloud, capable of directly providing complete network services to users without reliance on any centralized services.</p>
<p>So, how are users' requests dispatched to replicas (nodes) within a subnet? How does IC protect against DDoS attacks? Is there a firewall? CDN caching, perhaps? üòè You know what I mean.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708134432946.png" style="zoom:30%;" />
</div>
<p>These services are provided by the boundary nodes of IC.</p>
<p>Boundary nodes are tasked with forwarding requests to the corresponding subnets, protecting the subnets, and providing caching.</p>
<p>When a user accesses the IC via a browser, we utilize the URL link on the ic0.app domain to locate the canister. Initially, the browser checks for the DNS record related to the URL link and obtains the IP address of the boundary node. Subsequently, it sends an HTTPS request to the boundary node. The boundary node, in return, delivers a JS library, the &quot;Service Worker&quot;, to run on the browser.</p>
<p>One of the primary tasks of this service worker is to employ chain key cryptography to validate the response from IC. To facilitate this function, the public verification key of the NNS (Network Nervous System) is hard-coded into the service worker.</p>
<p>The boundary node assumes the responsibility of routing our requests to the target canister's subnet replica. It retrieves the necessary routing information from the NNS and arbitrarily selects one from a list of real-time response replicas. The security of communication between the user and the boundary node, as well as between the boundary node and the replica, is assured by TLS.</p>
<p>Beyond interacting with the main network, boundary nodes also provide services like caching, load balancing, rate limiting, firewall, and verification of IC response messages, thereby enhancing the user experience.</p>
<p>More details about boundary nodes can be found <a href="1.OverviewofIC/">here</a>.</p>
<br>
<h2 id="message-request-workflow"><a class="header" href="#message-request-workflow">Message request workflow</a></h2>
<p>With these 4 core protocol layers, let us take a look at the flow of a user request on IC:</p>
<p>User requests are divided into query calls and update calls.</p>
<br>
<p>Query call:</p>
<p>The client sends a request message to the boundary node wanting to access a Canister. The boundary node forwards this message to replicas in the subnet hosting the target Canister. After receiving the message, the replicas return a response and send it to the user through the boundary node.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708205341898.png" style="zoom:37%;" />
</div>
<p>Update call:</p>
<p>The client sends a request message M to the boundary node, targeting Canister C. The boundary node forwards the message M to the subnet replica hosting Canister C.</p>
<p>Upon receiving message M, the replica broadcasts message M to all replicas in the subnet through the P2P layer.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708205602606.png" style="zoom:39%;" />
</div>
<p>The main node that receives message M will package message M and other inputs into a block B.</p>
<p>After a while, the block B is finalized, and the contents are sent to the message routing layer for processing.</p>
<p>The message routing layer puts the message into Canister C's input message queue.</p>
<p>The execution layer processes message M and updates Canister C's internal state.</p>
<p>Subsequently, the message routing layer takes out the response R and returns it to the boundary node, which returns it to the user.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708205753787.png" alt="image-20230708205753787" style="zoom:37%;" />
</div>
<p>Sometimes processing a request message M requires calling canisters from other subnets. For example, Canister C needs to initiate a request M' to Canister C' in another subnet. Request M' will be placed in Canister C's output queue, and then the following steps are performed:</p>
<ul>
<li>The message routing layer moves the call request M' to the corresponding cross-subnet data stream, which eventually transports it to the subnet hosting Canister C'.</li>
<li>Upon receiving request M', the second subnet processes it through the consensus layer and message routing layer, and finally the execution layer updates the state of Canister C' and generates a response R' to request M'. Response R' enters Canister C's output queue and is eventually passed back to the first subnet.</li>
<li>Upon returning to the first subnet, after receiving the response R' from the second subnet, it is processed through the consensus layer, message routing layer, and execution layer. The execution layer updates the state of Canister C and generates a response R to the original request M. This response R is recorded in the ingress history data structure.</li>
</ul>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708210008700.png" alt="image-20230708210008700" style="zoom:35%;" />
</div>
<br>
<h2 id="chain-key"><a class="header" href="#chain-key">Chain Key</a></h2>
<p>IC uses an advanced cryptographic toolkit called Chain Key cryptography. This technology enables IC to achieve functionality and scalability that other blockchains cannot.</p>
<p>A key component is the threshold signature scheme, similar to ordinary digital signature schemes, but with the difference that the secret signature keys are distributed among the subnet replicas, making the keys less prone to leakage or get stolen.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708163522799.png" alt="image-20230708163522799" style="zoom:33%;" />
</div>
<p>Chain Key brings many benefits. For example:</p>
<ul>
<li>Anyone (mobile phone, tablet, laptop) can easily verify signatures to validate content received from IC without synchronizing the entire blockchain.</li>
<li>It allows IC's topology to evolve autonomously, such as adding new replicas and subnets, recovering failed replicas, and autonomous protocol upgrades.</li>
<li>It also provides unpredictable and unbiased pseudo-random numbers to allow Canisters to securely run algorithms that require randomness.</li>
</ul>
<br>
<p>A key innovation of IC is that subnets act as separate consensus islands. Chain Key allows subnets to communicate securely and validate each other's messages without downloading other blocks. This allows IC to achieve high scalability and security while remaining lightweight and easy to validate.</p>
<p>This unique Chain Key technology provides a powerful foundation for building the next generation of distributed applications.</p>
<br>
<h2 id="network-nervous-system-nns"><a class="header" href="#network-nervous-system-nns">Network Nervous System (NNS)</a></h2>
<p>IC's decentralization is slightly different from Bitcoin and Ethereum. Its nodes do not join and leave as they please. Instead, to join or leave IC network, no third-party centralized agency's approval is needed. Before nodes join the IC network, they need to obtain approval through voting in the NNS. IC's underlying protocols have a built-in DAO for governance.</p>
<p>To explain in detail:</p>
<p>Early consensus protocols such as PBFT were permissioned. That is, the network topology and nodes were fixed, not open for anyone to join. Although such protocols are more efficient, they violate the spirit of decentralization. Therefore, permissionless consensus protocols such as Bitcoin and Ethereum now use proof-of-work or proof-of-stake mechanisms. Although fully decentralized, these protocols are relatively inefficient.</p>
<p>IC combines the advantages of both. It has the efficiency of permissioned protocols and the benefits of permissionless PoS protocols. You can call it a DAO-controlled network (semi-permissioned network).</p>
<br>
<p>Each subnet runs a permissioned consensus protocol with fixed replicas (nodes) in the subnet. When the network topology needs to be adjusted, a DAO called the <strong>Network Nervous System (NNS)</strong> determines which nodes can join a subnet, configures the network topology, configures public keys, and controls the protocol version deployed by replicas. <strong>NNS decisions are made by community members voting, with voting rights related to the ICP they stake in the NNS. The more ICP, longer period they stake, the more votes, the greater the weight they have.</strong></p>
<br>
<p>Through this governance system, IC can add or remove replicas in existing subnets; deploy software updates; upgrade replicas; create new blockchain subnets for expansion; split subnets to balance network load; configure economic parameters such as adjusting the exchange ratio of Cycles to ICP and the Cycles burn rate; in extreme cases, it can freeze malicious Canisters to protect the network, and so on. The NNS runs on a specific subnet, similar to other subnets. However, it has more replicas, is more secure, and the NNS subnet is a system subnet that only deploys a few of the most critical Canisters.</p>
<p>The Canisters in the system subnet do not charge Cycles fees because only a few of IC's own Canisters are deployed. Ordinary developers cannot deploy Canisters on the system subnet. So IC is managed by a DAO across all subnets.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708141930460.png" style="zoom: 60%;" />
</div>
<p>The NNS maintains a database called the <strong>registry</strong> to track the network topology of the IC, such as which replicas belong to which subnets, the public keys of the replicas, etc.</p>
<br>
<p>The DAO-governed IC network allows the IC to enjoy the benefits of permissioned networks in efficiency while retaining the advantages of decentralized networks under DAO governance. Moreover, the replicas running the IC protocol are hosted in geographically distributed and independently operated data centres, which also enhances the security and decentralization of the IC.</p>
<h2 id="canister"><a class="header" href="#canister">Canister</a></h2>
<p>After I understood the IC, I saw the first time a blockchain that can directly deploy web pages.</p>
<p>The IC is the only blockchain that can host complete dapps (front end, back end and data). The IC can securely provide HTTP requests.</p>
<br>
<p>A canister is the IC's smart contract that can store code logic, data state, and front-end resources. Developers do not need to care about the underlying communication. As long as the code is deployed in the Canister, users can directly access the application through the URL.</p>
<p>For example, there is a canister dedicated to front-end pages in the project and a back-end canister. After the client sends a request, the browser first downloads a Service Worker from the boundary node to check whether the browser supports Wasm, whether the network environment is secure, etc. The Service Worker can verify whether the front-end page comes from the IC and whether it has been tampered with. The request message passes through the IC protocol to locate a front-end canister, and the front-end canister directly sends an HTML page to the client. Then it interacts with the back-end canister through the official JS proxy library. Canisters can also call and interact with each other.</p>
<p>ETH is a synchronous state update machine triggered by transactions, and then reaches consensus; IC is an asynchronous state update machine. As long as the client sends a message to the IC, a result will be returned: success or failure.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708142450951.png" style="zoom:25%;" />
</div>
<p>IC simplifies both Ethereum Dapp and traditional web development. Developing Dapps does not require third-party wallets, nor do developers need to consider load balancing and firewalls, which are solved by the IC protocol layer.</p>
<p>Above is just the simplest Dapp project example. In actual development, a Dapp usually has many canisters.</p>
<br>
<p>The meaning of Canister is a jar or container. On IC, it is a lightweight Wasm (WebAssembly) container.</p>
<p>Canisters automatically persist data in memory, eliminating the need for separate database servers and storage management. This improves computational efficiency and simplifies development. In theory, all languages that can be compiled into Wasm bytecode can be used to write IC smart contracts: Motoko, Rust, C, C++, Go, JavaScript, etc. (Now Motoko and Rust's CDKs are more mature, and the SDKs of other languages are under development) Therefore, both front-end and back-end can be compiled into Wasm and installed in the container for on-chain deployment. Of course, only browsers that support Wasm can open Dapps, but more and more browsers will support Wasm in the future.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230708164544441.png" style="zoom: 80%;" />
</div>
<p>In addition,with integration on HTTP, Canisters could access to webpages outside IC without the use of Oracle!</p>
<p>See <a href="1.OverviewofIC/">here</a> for more content about Canister.</p>
<br>
<h2 id="internet-identity"><a class="header" href="#internet-identity">Internet Identity</a></h2>
<p>On the Internet, we usually use usernames and passwords to identify and authenticate identities, but these methods are difficult to manage and have many security vulnerabilities. To solve these problems, IC has created a more advanced and secure encrypted authentication method called <strong>Internet Identity</strong>, which can be used on Dapps in the IC ecosystem. When logging in to Dapps, no password is required, nor do you need to remember complicated private keys or recoverys to easily control your decentralized identity.</p>
<p>When users use Internet Identity, websites will not collect information about the user's online activities. Since it will help you create and manage anonymous, independent accounts on each website, allowing you to enjoy the privacy protection of having many different accounts without worrying about managing these accounts. It not only frees you from complex username and password management but also makes you safer and more private when using network services.</p>
<br>
<p>Users can perform face scanning, fingerprint recognition, Ledger or <a href="https://en.wikipedia.org/wiki/YubiKey">Yubikey</a> hardware wallets to create a decentralized identity. This identity can be used to log in/register to various Dapps.</p>
<p>Logging in to different Dapps with this identity will have different accounts. That is to say, it is isolated, and the identities are not interoperable (different from ETH). This identity is a completely isolated account in different Dapps. In each Dapp, it is like a split derived from the main identity. Use one DID identity to control all Dapps.</p>
<br>
<p>We like to call it &quot;ii&quot;.</p>
<p>ii is an identity authentication mechanism. The underlying principle is still private keys, public keys, and things like that.</p>
<p>The user's mobile phone and computer have a TPM security chip that can generate a pair of keys. The public key is uploaded and stored in the ii Canister. The private key is saved by the TPM chip of the device, and no one can get it (including the user).</p>
<p>On the IC, user and Dapp interactions require signature authentication each time. Since the private key exists in the security chip, of course, the user cannot use fingerprint signature for each interaction request. So ii uses a delegated key to form a delegated key chain. Set an expiration time for the delegated key and then sign with the private key of the delegated key.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230710130244492.png" alt="image-20230710130244492" style="zoom:67%;" />
</div>
<p>So what exactly does this delegated key mean?</p>
<p>You see, the device security chip generates a pair of keys, and then let the browser generate a pair of keys (Session key). Let the private key generated by the security chip sign the public key, expiration time, and other information generated by the browser. The generated signature is the delegation. With this delegation, you can sign the request with the private key of the browser.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230717101308922.png" style="zoom:37%;" />
</div>
<p>As shown in the figure above. The recipient receives the blue public key, Delegation, the pink private key signed content, and the pink public key. Unlock the Delegation with the blue public key and find the pink public key inside, indicating that the blue private key has signed the pink public key. That is, the blue private key has granted permission, just like a general holding the emperor's tiger symbol to dispatch troops and generals. The tiger symbol represents the emperor's authorization.</p>
<p>Since the domain names of each Dapp are different, the generated <a href="1.OverviewofIC/">pid</a> (Principal id) are also different. Pid is a user's identity identifier in a Dapp. This will be described in detail later.</p>
<br>
<p>An anchor is equivalent to a username, that is, the User number in the above figure. Each device saved by the user in ii is a private key. The user can add or delete devices, that is, the user can add or delete private keys. So if the user's phone is lost, it is equivalent to losing a private key. As long as you log in to anchor on other devices, you can delete the phone device.</p>
<p>One thing ii does is to add the user's different devices and bind them to the anchor's corresponding Master key. This Master key is hosted on the Canister. As long as one device can be added, the devices saved in ii can be changed. The user does not need to contact the private key. The Master key can be understood as a total private key. As long as the device is bound to this total private key, there is no need to worry about losing the ii identity. If all are lost, only the recovery phrase can be recovered. If the recovery phrase is lost, there is no way to recover it. All lost üòù.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230710004109053.png" alt="image-20230710004109053" style="zoom:30%;" />
</div>
<p>So ii is an identity authentication mechanism. ii does not save user information, only the user's ii identity. User related information is saved by Dapp itself.</p>
<p>The Canister stores anchors and the corresponding Master keys. Anchors start from 10000 and increment.</p>
<p>This gives ii the following two characteristics:</p>
<ul>
<li>When an anchor logs in to different Dapps, the identities are different. As for the user information corresponding to this identity, such as username, ii will not save it.</li>
<li>When logging into Dapp on different devices with the same anchor, the identity is the same.</li>
</ul>
<p>More information about ii can be found <a href="1.OverviewofIC/">here</a>.</p>
<h2 id="icp-tokenomics"><a class="header" href="#icp-tokenomics">ICP tokenomics</a></h2>
<p>The IC network is governed by the Network Nervous System (NNS), and the governance token is called ICP. There is another token called Cycles, which is used to pay for the storage, transmission and calculation fees of Canisters on the IC network, similar to Ethereum's gas fee.</p>
<p>Cycles are used to pay for the Canister (smart contract) operations. ICP can only be burned into Cycles in one direction and cannot be changed back to ICP. The exchange rate between ICP and Cycles is dynamically adjusted according to the ICP price to always maintain a stable exchange of a certain amount of Cycles. In this way, ICP will become less and less. As the number of IC network users increases, more people will buy ICP to run smart contracts, and the value of the IC network will continue to increase.</p>
<p>Data centres who want to become nodes need to buy a large amount of ICP as collateral. If the data centre goes evil, ICP will be fined from them.</p>
<p>As the ecology on IC becomes more and more prosperous, and more and more enterprises and organizations deploy decentralized applications Dapp on IC, ICP needs to be burned into Cycles to pay for the deployment of applications.</p>
<p>ICP holders can pledge ICP in the NNS to create Neurons and then vote. After voting, they will receive ICP rewards, which is one of the inflation mechanisms of ICP. However, the role of NNS is to govern by voting, not to earn interest.</p>
<br>
<p>In addition, NNS will send ICP token incentives to data centre providers every month. This is another inflation mechanism.</p>
<p>The amount of Cycles consumed in the Canisters of these data centres and the amount of ICP obtained by these data centres are dynamically balanced. The amount of ICP incentives depends on the contribution of data centres to the IC network. The more Canisters deployed and the more computing power and storage provided, the more ICP incentives.</p>
<br>
<p>In the process of using Ethereum smart contracts to sign, transfer and trade, cryptocurrency users need to pay a certain amount of gas fee to the network. The gas fee will rise with network congestion. Especially when the De-Fi market is booming, high gas fees have become a barrier for the majority of ordinary users to participate.</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/1688483328530.jpg" alt="1688483328530" style="zoom:77%;" />
</div>
<p>ICP can be exchanged for Cycles tokens. The exchange rate between the two is dynamically changing to ensure the relative stability of the value of Cycles and prevent Gas fees from fluctuating sharply.</p>
<h2 id="blockchain-singularity"><a class="header" href="#blockchain-singularity">Blockchain Singularity</a></h2>
<p>Cross-chain bridges inherently have 51% attack security risks.</p>
<p>However, IC solves this issue by abandoning cross-chain bridges entirely. IC itself is a cloud service. IC can directly integrate other chains.</p>
<br>
<p>Currently, IC has integrated with Bitcoin and Ethereum. Canisters can directly receive, hold, and send Bitcoin. Canisters can perform ECDSA signatures. IC implements ECDSA threshold signatures. This technology allows Canisters to control ECDSA private key fragments, and private key fragments are distributed across replicas in the Bitcoin subnet, similar to BLS threshold signatures.</p>
<p>In this way, cross-chain no longer needs bridges, nor does it need to wrap assets, such as wrapping BTC into WBTC.</p>
<br>
<p>Developers only need to write business logic in Canisters to build Bitcoin DeFi products, like trading and lending platforms. It is very fast, only takes a few seconds, and the cost is very low.</p>
<p>So after saying so much, I don't need to say much about what IC can do üòè. The following content comes from the IC white paper:</p>
<blockquote>
<p>In addition to a smart contract platform, IC is designed as a complete technology stack so systems and services can be built entirely on IC. In particular, smart contracts on the IC can service HTTP requests created by end users, so that smart contracts can directly serve interactive web experiences. This means that systems and services can be created without relying on corporate cloud hosting services or private servers, thus providing all of the benefits of smart contracts in a true end-to-end fashion.</p>
<p>Realizing the vision of Web3. For end users, accessing IC-based services is a seamless experience. Their personal data is more secure than when accessing applications on a public or private cloud, but the experience of interacting with the application is the same. For the people creating and managing those IC-based services, however, the IC eliminates many of the costs, risks, and complexities associated with developing and deploying modern applications and microservices. For example, the IC platform provides an alternative to the consolidation driven by large technology companies that are monopolizing the Internet. In addition, its secure protocol guarantees reliable message delivery, transparent accountability, and resilience without relying on firewalls, backup facilities, load balancing services, or failover orchestration.</p>
</blockquote>
<p>That's why I believe that IC will start a new era on the internet. The singularity!</p>
<br>
<p>Dominic Williams was very excited in his blog post on January 6, 2021:</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230704200917524.png" " style="zoom:67%;" />
</div>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230704201553626.png" alt="image-20230704201553626" style="zoom:67%;" />
</div>
<p>You could see the structure of this chapter below, which links to different chapters:</p>
<div class="center-image">
    <img src="1.OverviewofIC/assets/1/image-20230717102623881.png" style="zoom:30%;" />
</div>
<br>
<p>WAGMI!!</p>
<br>
<p>Continue delving deeper into <a href="1.OverviewofIC/../2.CoreProtocol/P2Player.html">the four core protocols of IC</a>.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="icp--web-30"><a class="header" href="#icp--web-30">ICP = Web 3.0</a></h2>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<p><em>Note: This article reflects the author's personal views at this stage. Some thoughts may contain factual errors and biases. They are shared solely for the purpose of discussion and I look forward to corrections from other readers.</em></p>
<ul>
<li><strong><a href="https://bitcoin.org/en/">BTC</a></strong> proposed electronic cash, pioneering the blockchain industry from 0 to 1.</li>
<li><strong><a href="https://ethereum.org/en/">ETH</a></strong> introduced smart contracts, leading the blockchain industry from 1 to 100.</li>
<li><strong><a href="https://internetcomputer.org/">ICP</a></strong> proposed Chainkey technology, driving the blockchain industry from 100 to 100,000,000.</li>
</ul>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>On January 3, 2009, the first BTC block was mined, marking the start of a tumultuous 14-year development in the blockchain industry.</p>
<p>Looking back over the past 14 years, the ingeniousness and greatness of BTC, the meteoric rise of Ethereum, the passionate crowdfunding of EOS, the inevitable conflict between PoS &amp; PoW, the interconnection of multiple chains by Polkadot - all of these awe-inspiring technologies and intriguing stories have made countless people in the industry bow in admiration.</p>
<p>Currently, in the year 2023, what is the landscape of the entire blockchain industry? Here are my thoughts, please refer to the <a href="https://mirror.xyz/0xkookoo.eth/BF7jfmieDL4AxzQKRuyCF0MzZ7mmmrVlCuF5CRoAbAk">public chain landscape interpretation section in this article</a>.</p>
<ul>
<li>BTC, by introducing the electronic cash, stands unshakeable and legitimacy as a <strong>cornerstone</strong> of the industry.</li>
<li>ETH, by introducing the programmability of smart contracts and the composability of the L2 ecosystem, blooms like a hundred flowers in the garden, establishing itself as the <strong>leader</strong> of the industry.</li>
<li>Cosmos, Polkadot, and others, with their cross-chain interoperability, are attempting to unite the world under one banner.</li>
<li>Various &quot;Ethereum killers&quot; keep emerging, each dominating in their small domains.</li>
</ul>
<p>But how will the entire blockchain industry develop in the next 10 years? Here are my thoughts:</p>
<ul>
<li><strong>Sovereignty</strong> is the only issue that blockchain needs to address, including asset sovereignty, data sovereignty, and speech sovereignty. Otherwise, there is no need for blockchain;</li>
<li><strong>Immutability</strong> is a sufficient condition, but not a necessary condition. As long as you can ensure that my sovereignty is not damaged, I don't care if you tamper. What difference does it make if everyone's assets in the world are doubled in same proportion?</li>
<li><strong>Complete decentralization</strong> is impossible to achieve. No matter how it is designed, there will always be &quot;gifted&quot; individuals/interest groups occupying more say, and there will always be people who choose not to participate. &quot;<strong>Decentralization with multiple centers</strong>&quot; is the final pattern;</li>
<li><strong>Transparency</strong> is a must. Isn't this social experiment of all mankind for everyone to have a say and the right to protect their own sovereignty? Although there will always be lazy people, people willing to believe in more professional individuals, and people who choose to give up voting for maximum efficiency, this is also an active choice they make. They have the right but choose not to exercise it. As long as everything is transparent and there are no underhanded maneuvers, I am willing to accept even death. If I lose, it's because my skills are inferior. Survival of the fittest is also in line with market economy;</li>
<li><strong>The control of decentralized code execution</strong> is the core, otherwise, it's just an unnecessary fuss. Public voting for a week, but in the end, the project team still deploys the malicious version of the code, even if it's not malicious, it's still making a mockery of everyone. You could say that half the world is made up of code now. If decentralized entities do not include control over code execution, then how would people, including governments, dare to let the blockchain industry grow?</li>
<li><strong>Linear cost of infinite scalability</strong>. As blockchain becomes more and more closely integrated with real life, more and more people participate, and the demand grows larger and larger. The infrastructure cannot support infinite scalability, or if it is too expensive to expand, it is unacceptable.</li>
</ul>
<h2 id="why-icp"><a class="header" href="#why-icp">Why ICP</a></h2>
<p>Let's start with a story. In 2009, Alibaba proposed the &quot;Remove IOE&quot; strategy, which later became a major milestone in the success of Alibaba's &quot;Double 11&quot; event.</p>
<h3 id="remove-ioe"><a class="header" href="#remove-ioe">Remove IOE</a></h3>
<p>The core content of the &quot;Remove IOE&quot; strategy is to get rid of IBM minicomputers, Oracle databases, and EMC storage devices, and to embed the essence of &quot;cloud computing&quot; into Alibaba's IT DNA. Where:</p>
<ul>
<li><strong>I</strong> stands for IBM p series minicomputers, running the AIX operating system (IBM's proprietary Unix system);</li>
<li><strong>O</strong> stands for Oracle databases (RDBMS);</li>
<li><strong>E</strong> stands for EMC mid-to-high-end SAN storage.</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/1.png" alt="img" style="zoom:100%;" />
<p>The reasons for removing IOE mainly include the following three points, but the first is the fundamental reason, and the latter two are more indirect:</p>
<ul>
<li><strong>Unable to meet demand</strong>, traditional IOE systems struggle to adapt to the high concurrency demands of internet companies and cannot support large-scale distributed computing architectures;</li>
<li><strong>Costs are too high</strong>, maintaining IOE is too expensive, for example, IBM minicomputers cost 500,000, Oracle's annual guarantee is several hundred thousand, and so on;</li>
<li><strong>Strong Dependency</strong>, IOE systems are highly dependent, &quot;held hostage&quot; by manufacturers such as IBM and Oracle, making it difficult to adapt flexibly according to their own needs.</li>
</ul>
<p>Why was the &quot;Remove IOE&quot; strategy proposed in 2009 and not earlier?</p>
<ul>
<li>Before that,
<ul>
<li>Alibaba's business scale and data volume had not yet reached a level that made the traditional IOE system difficult to adapt to, so there was no urgent need to remove IOE;</li>
<li>Chinese domestic database products were not yet mature enough in terms of technology and quality to effectively replace IOE;</li>
<li>Internet thinking and cloud computing concepts had not yet become widespread in China, and distributed architecture had not become a popular direction;</li>
<li>Management and technical personnel may have needed a period of practical accumulation before they realized the problems that existed and the measures that had to be taken.</li>
</ul>
</li>
<li>In 2009,
<ul>
<li>As Alibaba rapidly expanded its business, the IOE system struggled to support the scale, and cost issues became more apparent;</li>
<li>Some open-source database products, such as MySQL, had reached a high level of maturity and could serve as replacements;</li>
<li>Internet-level thinking and cloud computing began to spread widely and be applied in China, which facilitated the promotion of the &quot;Remove IOE&quot; concept;</li>
<li>Former Microsoft tech guru, Wang Jian, joined Alibaba in 2008 with a global tech perspective, and deeply trusted by Jack Ma, he proposed &quot;Remove IOE&quot;.</li>
</ul>
</li>
</ul>
<p>However, &quot;Remove IOE&quot; is not simply about changing the software and hardware itself, replacing old software and hardware with new ones, but replacing old methods with new ones, and using cloud computing to completely change the IT infrastructure. In other words, this was driven by industry changes, not just a simple technology upgrade.</p>
<h3 id="three-stages-of-a-business"><a class="header" href="#three-stages-of-a-business">Three stages of a business</a></h3>
<p>The development of a business can be divided into 3 stages:</p>
<ol>
<li>Shaping the DNA and building the organizational culture, also called the <strong>Start-up stage</strong>, is about going from <strong>0 to 1</strong>.</li>
<li>Rapid growth, or &quot;small steps, fast running&quot;, is called the <strong>Scale-up stage</strong>, about going from <strong>1 to 100</strong>.</li>
<li>Infinite expansion, or broadening boundaries, is called the <strong>Scale-out stage</strong>, about going from <strong>100 to 100,000,000</strong>.</li>
</ol>
<p>Now, let's analyze the entire blockchain industry as if it is a single business.</p>
<h3 id="start-up--blockchain-10--btc"><a class="header" href="#start-up--blockchain-10--btc">Start-up / Blockchain 1.0 / BTC</a></h3>
<p>The innovation of Bitcoin lies in its solution to a problem that has perplexed computer scientists for decades: how to create a digital payment system that can operate without the need to trust any central authority.</p>
<p>However, there are indeed some limitations in the design and development of BTC, which have provided market opportunities for subsequent blockchain projects such as Ethereum (ETH). Here are some of the main limitations:</p>
<ul>
<li><strong>Transaction Throughput and Speed</strong>: The block generation time of Bitcoin is about 10 minutes, and the size limit of each block leads to an upper limit on its transaction processing capacity. This means that during busy network times, transaction confirmation may take a long time, and higher transaction fees may be required.</li>
<li><strong>Limited Smart Contract Functionality</strong>: Bitcoin is designed primarily as a digital currency, and the types of transactions it supports and the functionality of its scripting language are relatively limited. This limits Bitcoin's application in complex financial transactions and decentralized applications (DApps).</li>
<li><strong>Difficulty in Upgrading and Improving</strong>: Due to Bitcoin's decentralized and conservative design principles, major upgrades and improvements usually require broad consensus from the community, which is difficult to achieve in practice. This also means that Bitcoin's progress is relatively slow.</li>
<li><strong>Energy Consumption</strong>: Bitcoin's consensus mechanism is based on Proof of Work (PoW), which means that a lot of computing resources are used in the competition among miners, leading to a lot of energy consumption. This has been criticized in terms of environmental protection and sustainability. On this point, you can also pay attention to <a href="https://eprint.iacr.org/2020/1117">EcoPoW</a>, which somewhat alleviates this limitation.</li>
</ul>
<h3 id="scale-up--blockchain-20--eth"><a class="header" href="#scale-up--blockchain-20--eth">Scale-up / Blockchain 2.0 / ETH</a></h3>
<p>Indeed, the current Layer 2 scaling solutions for Ethereum can be seen as a form of &quot;vertical scaling&quot;, which relies on the security and data availability guarantees of the underlying Layer 1. Although it seems like a 2-layer structure, it is ultimately limited by the processing capacity of Layer 1. Even if it is changed to a multi-layer structure and Layer 3 and Layer 4 are built, it just increases the complexity of the entire system and only delays a little time to expose the main issue. Moreover, according to the law of diminishing marginal returns, the more layers added, the more overhead will cause the scaling effect to be greatly reduced. This layered vertical expansion can be seen as a single-machine hardware upgrade, and this single machine refers to the entire ETH ecosystem.</p>
<p>Moreover, as usage increases, user demand for low fees and high performance will also increase. As an application on Layer 1, the cost of Layer 2 can only be reduced to a certain extent and is ultimately subject to the basic cost and throughput of Layer 1. This is similar to the theory of demand curves in economics - as prices fall, the total demand will increase. Vertical scaling is difficult to fundamentally solve the scalability problem.</p>
<p>Ethereum is a towering tree, and everyone relies on that root. Once the speed at which the root draws nutrients cannot keep up, people's needs will not be met;</p>
<p><strong>Therefore, only horizontal expansion is more likely to be infinite.</strong></p>
<p>Some people think that multi-chain and cross-chain is also a form of horizontal expansion,</p>
<ul>
<li>Take Polkadot as an example, it is a heterogeneous kingdom. Each country looks different, but you have to build a kingdom for everything (e.g. a DEX) you do;</li>
<li>Cosmos is a homogenous kingdom, the meridians and bones of each country look the same, but the same, you have to establish a kingdom every time you build an application;</li>
</ul>
<p>However, from the perspective of Infra, the modes of these two are a bit strange. Every time you build an application, you have to construct a whole kingdom? Let's give an example to see how strange it is,</p>
<ul>
<li>I bought a Mac 3 months ago and developed a Gmail application on it;</li>
<li>Now I want to develop a Youtube application, but I have to buy a new Mac to develop it, which is very strange.</li>
</ul>
<p>And both of these methods face the problem of high complexity of cross-chain communication when adding new chains, so they are not my first choice.</p>
<h3 id="scale-out--blockchain-30--icp"><a class="header" href="#scale-out--blockchain-30--icp">Scale-out / Blockchain 3.0 / ICP</a></h3>
<p>Indeed, to achieve scale-out, a complete set of underlying infrastructure is needed to support rapid horizontal expansion without reinventing the wheel.</p>
<p>A typical example of supporting scale-out is cloud computing. The underlying templates such as &quot;VPC + subnet + network ACL + security group&quot; are exactly the same for everyone. All machines carry labels and types, and core components such as RDS, MQ, etc. at the upper layer support unlimited expansion. If more resources are needed, they can be quickly initiated with a click of a button.</p>
<p>One of my leader once shared with me, if you want to understand what infrastructure and components Internet companies need, you just need to go to AWS and look at all the services they provide. That's the most complete and powerful combination.</p>
<p>Similarly, let's take a high-level look at ICP to see why it meets the requirements for Scale-out.</p>
<p>Here are a few concepts to clarify first:</p>
<ul>
<li><strong>Dfinity Foundation</strong>: It is a non-profit organization dedicated to promoting the development and application of decentralized computing technology. It is the developer and maintainer of the Internet Computer Protocol, aiming to realize the comprehensive development of decentralized applications through innovative technology and an open ecosystem.</li>
<li><strong>Internet Computer (IC)</strong>: It is a high-speed blockchain network developed by Dfinity Foundation, specifically designed for decentralized applications. It uses a new consensus algorithm that can achieve high throughput and low latency transaction processing while supporting the development and deployment of smart contracts and decentralized applications.</li>
<li><strong>Internet Computer Protocol (ICP)</strong>: It is the native token in the Internet Computer Protocol. It is a digital currency used to pay for network usage fees and reward nodes.</li>
</ul>
<h2 id="whats-icp"><a class="header" href="#whats-icp">What‚Äôs ICP</a></h2>
<p>Let's dive into the more complex aspects of the topic. I'll do my best to keep the explanations as understandable as possible. If you want to discuss more detailed issues or have any questions, feel free to contact me. I'm here to make this complex topic more digestible for everyone.</p>
<h3 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h3>
<ul>
<li>Let's break down the architecture of the Internet Computer (IC) into its various layers from the bottom up:
<ul>
<li><strong>P2P Layer</strong>: This layer is responsible for collecting and sending messages from users, other replicas within the subnet, and other subnets. It ensures that messages can be delivered to all nodes within the subnet, ensuring security, reliability, and resilience.</li>
<li><strong>Consensus Layer</strong>: The main task of this layer is to sort the inputs, ensuring that all nodes within the same subnet process tasks in the same order. To achieve this goal, the consensus layer uses a new consensus protocol, which is designed to ensure security and liveness, and has the ability to resist DOS / SPAM attacks. After reaching consensus on the order of processing various messages within the same subnet, these blocks are passed to the message routing layer.</li>
<li><strong>Message Routing Layer</strong>: Based on the tasks delivered from the consensus layer, it prepares the input queues for each Canister. After execution, it is also responsible for receiving the output generated by the Canister and forwarding it to local or other Canisters as needed. In addition, it is responsible for recording and verifying responses to user requests.</li>
<li><strong>Execution Layer</strong>: This layer provides a runtime environment for Canisters, reads inputs in an orderly manner according to the scheduling mechanism, calls the corresponding Canister to complete tasks, and returns the updated state and generated output to the message routing layer. It utilizes the non-determinism brought by random numbers to ensure fairness and auditability of computation. In some cases, the behavior of Canisters needs to be unpredictable. For example, when performing encryption operations, random numbers are used to increase the security of encryption. In addition, the execution results of Canisters need to be random to prevent attackers from discovering vulnerabilities or predicting Canister behavior by analyzing the execution results of Canisters.</li>
</ul>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/2.png" alt="4-layers of ICP" style="zoom:77%;" />
<p>4-layers of ICP</p>
<h3 id="key-components"><a class="header" href="#key-components">Key Components</a></h3>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/3.png" alt="img" style="zoom:37%;" />
<ul>
<li>Let's take a look at the components of the Internet Computer (IC) architecture:
<ul>
<li><strong>Subnet (Subnetwork)</strong>: Supports infinite expansion, each subnet is a small blockchain. Subnets communicate with each other through Chain Key technology. Since consensus has already been reached within the subnet, it only needs to be verified through Chain Key.</li>
<li><strong>Replica</strong>: There can be many nodes in each subnet, and each node is a replica. The consensus mechanism in IC ensures that every replica in the same subnet will process the same input in the same order, making the final state of each replica the same. This mechanism is called Replicated State Machine.</li>
<li><strong>Canister</strong>: A Canister is a type of smart contract. It is a computational unit that runs on the ICP network, can store data and code, and can communicate with other Canisters or external users. ICP provides a runtime environment for executing Wasm programs in Canisters and communicating with other Canisters and external users through message passing. It can be simply regarded as a Docker used for running code, and then you inject your own Wasm Code Image to run inside it.</li>
<li><strong>Node</strong>: An independent server. Canisters still need a physical machine to run, and these physical machines are the actual machines in the server room.</li>
<li><strong>Data Center</strong>: The nodes in the data center are virtualized into a replica (Replica) through the node software IC-OS, and some replicas are randomly selected from multiple data centers to form a subnet (Subnet). This ensures that even if a data center is hacked or hit by a natural disaster, the entire ICP network can still run normally. It's kind of like an upgraded version of Alibaba's &quot;Two Places, Three Centers&quot; disaster recovery high-availability solution. Data centers can be distributed all over the world, and even a data center could be set up on Mars in the future.</li>
<li><strong>Boundary Nodes</strong>: Provide entrances and exits between the external network and IC subnets, and verify responses.</li>
<li><strong>Principal</strong>: External user identifier, derived from the public key, used for access control.</li>
<li><strong>Network Nervous System (NNS)</strong>: An algorithmic DAO for governance using staked ICP, used to manage IC.</li>
<li><strong>Registry</strong>: A database maintained by NNS, containing the mapping relationship between entities (such as Replica, canister, Subnet), a bit like the working principle of DNS today.</li>
<li><strong>Cycles</strong>: Local tokens, representing CPU quotas for paying for resources consumed during canister runtime.</li>
</ul>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/4.png" alt="img" style="zoom:50%;" />
<h3 id="key-innovative-technologies"><a class="header" href="#key-innovative-technologies">Key Innovative Technologies</a></h3>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/5.png" alt="img" style="zoom:37%;" />
<ul>
<li>Let's explore the Chain-key technology, a key component of the Internet Computer (IC) protocol:
<ul>
<li><strong>Threshold BLS signatures</strong>: ICP has implemented a threshold signature scheme. For each subnet, there is a publicly verifiable public key, and its corresponding private key is divided into multiple shares. Each share is held by a replica within the subnet, and only when replicas in the same subnet exceed the threshold number for message signing is it considered valid. In this way, messages sent between subnets and replicas are encrypted but quickly verifiable, ensuring both privacy and security. The BLS algorithm is a well-known threshold signature algorithm that can generate simple and efficient threshold signature protocols and its signature is unique, meaning that for a given public key and message, there is only one valid signature.</li>
<li><strong>Non-interactive Distributed Key Generation (NIDKG)</strong>: To securely deploy the threshold signature scheme, Dfinity designed, analyzed, and implemented a new DKG protocol. This protocol runs on an asynchronous network and has high robustness (even if up to a third of the nodes in the subnet crash or are damaged, it can still succeed), while still providing acceptable performance. In addition to generating new keys, this protocol can also be used to reshare existing keys. This feature is crucial for the autonomous evolution of the IC topology, as subnet memberships change over time.
<ul>
<li><strong>Publicly Verifiable Secret Sharing scheme (PVSS Scheme)</strong>: The PVSS scheme is used in the Internet Computer protocol's white paper to implement the decentralized key generation (DKG) protocol, ensuring that node private keys are not leaked during the generation process.</li>
<li><strong>Forward-secure public-key encryption scheme</strong>: A forward-secure public-key encryption scheme ensures that even if the private key is leaked, previous messages cannot be decrypted, thereby enhancing system security.</li>
<li><strong>Key resharing protocol</strong>ÔºöA key sharing scheme based on threshold signatures, used to implement key management in the Internet Computer protocol. The main advantage of this protocol is that it can share existing keys with new nodes without creating new keys, thereby reducing the complexity of key management. Moreover, the protocol uses threshold signatures to secure key sharing, thereby enhancing the system's security and fault tolerance.</li>
</ul>
</li>
<li><strong>PoUW</strong>: <a href="https://medium.com/dfinity/proof-of-useful-work-is-vastly-superior-to-other-consensus-mechanisms-ff18c37a3201">PoUW</a>, where U stands for Useful, improves performance and reduces wasted computation by nodes. Unlike PoW, which artificially creates difficult hash computations, PoUW focuses computational power as much as possible on serving users. The majority of resources (CPU, memory) are used for the execution of code within actual canisters.</li>
<li><strong>Chain-evolution technology</strong>: A technology used for maintaining blockchain state machines, consisting of a series of techniques to ensure blockchain security and reliability. In the Internet Computer protocol, chain-evolution technology primarily includes the following two core technologies:
<ol>
<li><strong>Summary blocks</strong>: The first block of each epoch is a summary block, which contains some special data for managing different threshold signature schemes. A low-threshold scheme is used to generate random numbers, while a high-threshold scheme is used to authenticate the replicated state of subnets.</li>
<li><strong>Catch-up packages (CUPs)</strong>: CUPs is a technology used for quickly synchronizing node states. They allow newly joined nodes to quickly get up to speed with the current state without having to rerun the consensus protocol.</li>
</ol>
</li>
</ul>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/6.png" alt="img" style="zoom:40%;" />
<p>My <strong>logical deduction</strong> for the entire IC (Internet Computer) underlying technology is as follows:</p>
<ul>
<li>In traditional public key cryptography, each node has its own pair of public and private keys. This means that if a node's private key is leaked or attacked, the security of the entire system will be threatened. However, the threshold signature scheme divides a key into multiple parts, which are distributed to different nodes. A signature can only be generated when a sufficient number of nodes cooperate. This way, even if some nodes are attacked or leaked, it will not pose a significant threat to the security of the entire system. Moreover, the threshold signature scheme can also improve the decentralization of the system, because it does not require a centralized institution to manage the keys, but instead distributes the keys among multiple nodes, thus avoiding single point of failure and centralization risks. Therefore, IC uses the threshold signature scheme to enhance the security and decentralization of the system, hoping to use threshold signatures to achieve a highly secure, scalable, and quickly verifiable general-purpose blockchain.</li>
<li>The BLS is a famous threshold signature algorithm. It is the only signature scheme that can produce very simple and efficient threshold signature protocols. One advantage of BLS signatures is that they do not require the preservation of signature states. As long as the message content remains the same, the signature is fixed, which means that for a given public key and message, there is only one valid signature. This ensures extremely high scalability, hence ICP chose the BLS scheme.</li>
<li>Because the threshold signature is used, there needs to be a distributor to distribute key fragments to different participants. However, this person who distributes the key fragments is a single point, which can easily lead to a single point of failure. Therefore, Dfinity designed a distributed key distribution technology, also known as NIDKG. During the initialization period of subnet creation, all participating Replicas non-interactively generate a public key A. For the corresponding private key B, each participant calculates and holds one of the derived secret shares through mathematical methods.</li>
<li>To implement NIDKG, it is necessary to ensure that every participant in the distribution has not cheated. Therefore, each participant can not only get their own secret share but can also let others publicly verify whether their secret share is correct. This is a very important point in realizing distributed key generation.</li>
<li>After NIDKG, if a certain secret share is held by a node for a long time, once the nodes are gradually eroded by hackers, the entire network may have problems. Therefore, it is necessary to continuously update the keys. However, key updates should not require all participating Replicas to gather together for interactive communication, but must also be conducted non-interactively. But because the public key A has already been registered in the NNS, other subnets will use this public key A for verification, so the subnet public key should preferably not change. But if the subnet public key does not change, how can the secret shares between the nodes be updated? Therefore, Dfinity designed a Key Resharing Protocol. Without creating a new public key, all Replicas holding the current version of the secret share non-interactively generate a new round of derived secret shares for the holders of the new version of the secret share. This way, it ensures that:
<ul>
<li>The new version of secret share is certified by all current legal secret share holders.</li>
<li>The old version of secret share is no longer legal.</li>
<li>Even if the new version of secret share is leaked in the future, the old version of secret share will not be leaked, because the polynomials between the two are completely unrelated and cannot be reverse engineered. This is also the forward security just introduced.</li>
<li>It also guarantees efficient redistribution at any time when trusted nodes or access control changes, allowing access policies and controllers to be modified without the need to restart the system. This greatly simplifies the key management mechanism in many scenarios. For example, it is very useful in scenarios where subnet members change, because resharing will ensure that any new member has the appropriate secret share, and any replica that is no longer a member will no longer have a secret share. Moreover, if a small amount of secret share is leaked to the attacker in any period or even every period, these secret shares are also of no benefit to the attacker.</li>
</ul>
</li>
<li>What if the subnet key at a certain moment in history is leaked? How to guarantee the immutability of historical data? Dfinity has adopted a forward-secure signature scheme. This ensures that even if the subnet key at a certain moment in history is leaked, the attacker cannot change the data of the historical block, thus preventing the threat of late-stage corruption attacks on the historical data of the blockchain. If this restriction is stronger, it can also ensure that information will not be eavesdropped on during transmission, because if the timestamps do not match, even if the key is cracked in a short time, past communications cannot be cracked.</li>
<li>Traditional blockchain protocols require the storage of all block information from the genesis block onward. As the blockchain grows, this can lead to scalability issues, making it troublesome for many public chains to develop a light client. To solve this problem, the Internet Computer (IC) developed the Chain-evolution Technology. At the end of each epoch, all processed inputs and consensus-required information can be safely cleared from the memory of each replica. This greatly reduces the storage requirements of each replica, enabling IC to scale to support a large number of users and applications. In addition, the Chain-evolution technology includes the CUPs (Canister Update Protocol) technology, which allows newly joined nodes to quickly obtain the current state without having to rerun the consensus protocol. This significantly lowers the barriers and synchronization time for new nodes to join the IC network.</li>
<li>In summary, all of IC's underlying technologies are interconnected, based on cryptography (from theory), and also fully consider industry challenges such as fast node synchronization (from practice). Truly, it is a comprehensive solution!</li>
</ul>
<h3 id="key-features"><a class="header" href="#key-features"><strong>Key Features</strong></a></h3>
<ul>
<li>In terms of features:
<ul>
<li><strong>Reverse Gas Model</strong>: Traditional blockchain systems generally require users to hold native tokens first, such as ETH or BTC, and then consume these tokens to pay for transaction fees. This increases the barrier to entry for new users and does not align with people's usage habits. Why should I have to own stocks in TikTok just to use the app? The Internet Computer (ICP) introduced a reverse gas model design, where users can directly use the ICP network, and the project side will cover the transaction fees. This reduces the usage threshold and aligns more closely with internet service habits, favoring a broader network effect and thus <strong>supporting the addition of more users</strong>.</li>
</ul>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/7.png" alt="img" style="zoom:70%;" />
<ul>
<li><strong>Stable Gas</strong>ÔºöFor other public chains on the market, to ensure the security of the chain and facilitate transfers, people will buy native tokens. Miners then strive to mine as much as possible, or people hoard native tokens, thus contributing computational power to the chain as in the case of Bitcoin, or providing pledge economic security as with Ethereum. It can be said that our demand for BTC/ETH actually comes from the Bitcoin/Ethereum public chains' requirements for computational power/pledges, which are essentially security requirements for the chain. Therefore, as long as the chain uses native tokens to pay for gas directly, it will become expensive in the future. Even if the native tokens are cheap now, they will become expensive once the chain's ecosystem gets established. However, the Internet Computer (ICP) is different. The gas consumed in the ICP blockchain is called Cycles, which are exchanged by consuming ICP. Cycles are stable under algorithmic adjustment, pegged to 1 SDR (Special Drawing Rights, which can be regarded as a stable unit calculated after integrating multiple national fiat currencies). Therefore, no matter how much the price of ICP increases in the future, the cost of doing anything on the ICP will remain the same as today (not considering inflation).</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/8.png" alt="img" style="zoom:31%;" />
<ul>
<li><strong>Wasm</strong>: WebAssembly (Wasm) is used as the standard for code execution. Developers can write code using a variety of popular programming languages (such as Rust, Java, C++, Motoko, etc.), thereb<strong>y supporting the participation of more developers</strong>.</li>
<li><strong>Support for Running AI Models</strong>: Python language can also be compiled into Wasm. Python has one of the largest user bases in the world and is the primary language for AI, such as vector and large number calculations. Some people have already <a href="https://forum.dfinity.org/t/llama2-c-llm-running-in-a-canister/21991">run the Llama2 model on IC</a>. If the concept of AI + Web3 happens on ICP in the future, I wouldn't be surprised at all.</li>
<li><strong>Web2 Speed Experience</strong>: Many applications on ICP have achieved astonishing results with millisecond-level queries and second-level updates. If you don't believe it, you can directly use <a href="https://oc.app/home">OpenChat</a>, a decentralized chat application that is entirely on-chain.</li>
<li><strong>On-Chain Frontend</strong>: You've probably only heard of writing some parts of the backend as simple smart contracts and running them on-chain to ensure that data assets and core logic cannot be tampered with. However, the frontend also needs to be fully run on-chain for safety, as <a href="https://medium.com/beaver-smartcontract-security/defi-security-lecture-4-front-end-attack-44f32ca0cd68">frontend attacks</a> are a very typical and frequently occurring problem. Imagine you might think that Uniswap's code is very safe. The smart contract has been verified by so many people over so many years, the code is simple, there could be no problems. But what if Uniswap's frontend is hijacked one day? The contract you're interacting with is actually a malicious contract deployed by a hacker, and you might go bankrupt instantly. But if you store and deploy all frontend code in IC's Canister, at least IC's consensus ensures that the frontend code cannot be tampered with by hackers. This protection is more comprehensive, and IC can directly run and render the frontend without affecting the normal operation of the application. On IC, developers can directly build applications without traditional cloud services, databases, or payment interfaces, and there is no need to buy a frontend server or worry about databases, load balancing, network distribution, firewalls, etc. Users can directly access the frontend web pages deployed on ICP through a browser or mobile App, like the <a href="https://0xkookoo.icp.xyz/">personal blog I deployed on IC</a> before.</li>
<li><strong>DAO-Controlled Code Upgrades</strong>: Many DeFi protocols now allow project owners to have complete control, initiating significant decisions such as suspending operations or selling funds without going through community voting and discussion. I believe everyone has witnessed or heard of such cases. In contrast, DAPP code in the ICP ecosystem runs in DAO-controlled containers. Even if a project party occupies a large proportion in voting, it still implements a public voting process, meeting the necessary conditions for blockchain transparency described at the beginning of this article. This process guarantee mechanism better reflects the will of the community, and relatively speaking, achieves <strong>a higher degree of governance</strong> compared to other public chain projects.</li>
<li><strong>Automatic Protocol Upgrades</strong>: When it is necessary to upgrade the protocol, a new threshold signature scheme can be added in the summary block to implement automatic protocol upgrades. This method can ensure the security and reliability of the network, while avoiding the inconvenience and risks brought by hard forks. Specifically, the Chain Key technology in ICP can ensure the network's security and reliability by maintaining a blockchain state machine through a special signature scheme. At the start of each epoch, the network uses a low-threshold signature scheme to generate a random number, and then uses a high-threshold signature scheme to authenticate the replicated state of the subnet. This signature scheme can ensure the security and reliability of the network, while also implementing automatic protocol upgrades, thus <strong>avoiding the inconvenience and risks brought by hard forks</strong>.</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/9.png" alt="Proposal Voting" style="zoom:80%;" />
<p>Proposal Voting</p>
<ul>
<li>
<p><strong>Fast Forwarding</strong>: This is a technology in the Internet Computer Protocol that quickly synchronizes the state of nodes. It allows newly joined nodes to quickly access the current state without having to rerun the consensus protocol. Specifically, the process of Fast Forwarding is as follows:</p>
<ol>
<li>The newly joined node obtains the Catch-up package (CUP) of the current epoch, which contains the Merkle tree root, summary block, and random number of the current epoch.</li>
<li>The new node uses the state sync subprotocol to obtain the full state of the current epoch from other nodes, and uses the Merkle tree root in the CUP to verify the correctness of the state.</li>
<li>The new node uses the random number in the CUP and the protocol messages of other nodes to run the consensus protocol, thereby quickly synchronizing to the current state.</li>
</ol>
<p>The advantage of Fast Forwarding is that it <strong>allows newly joined nodes to quickly access the current state</strong>, and they don't have to start from the beginning like some other public chains. This can speed up the synchronization and expansion of the network. At the same time, it can also reduce the amount of communication between nodes, thereby improving the efficiency and reliability of the network.</p>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/10.png" alt="fast forwarding" style="zoom:59%;" />
<p>fast forwarding</p>
<ul>
<li>
<p><strong>Decentralized Internet Identity</strong>: The identity system on IC really makes me feel that the DID problem can be completely solved, whether it is scalability or privacy. The identity system on IC currently has an implementation version called <a href="https://identity.ic0.app/">Internet Identity</a>, and a more powerful <a href="https://nfid.one/">NFID</a> developed based on it.</p>
<p>Its <a href="https://medium.com/dfinity/internet-identity-the-end-of-usernames-and-passwords-ff45e4861bf7">principle</a> is as follows:</p>
<ol>
<li>At the time of registration, it generates a pair of public and private keys for the user. The private key is stored in the TPM security chip inside the user's device and will never be leaked, while the public key will be shared with services on the network.</li>
<li>When the user wants to log in to a dapp, the dapp creates a temporary session key for the user. This session key will be signed by the user through the authorization of electronic signature, so that the dapp obtains the permission to verify the user's identity.</li>
<li>After the session key is signed, the dapp can use this key to access network services on behalf of the user, and the user does not need to sign electronically every time. This is similar to representative authorization login in Web2.</li>
<li>The session key has a short validity period. After it expires, the user needs to reauthorize the signature through biometric recognition to obtain a new session key.</li>
<li>The user's private key is always stored in the local TPM security chip and will not leave the device. This ensures the security of the private key and the anonymity of the user.</li>
<li>By using temporary session keys, different dapps cannot track user identities with each other. Achieve true anonymity and private access.</li>
<li>Users can easily sync and manage their Internet Identity across multiple devices, but the devices themselves also require corresponding biometric or hardware key authorization.</li>
</ol>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/11.png" alt="img" style="zoom:40%;" />
<ul>
<li>The advantages of Internet Identity are as follows:
<ol>
<li>No need to remember passwords. Use biometrics features such as fingerprint recognition to log in directly, without the need to set and remember complex passwords.</li>
<li>Private keys do not leave the device, making it more secure. The private key is stored in the TPM security chip and cannot be stolen, solving the problem of username and password theft in Web2.</li>
<li>Anonymous login, cannot be tracked. Unlike Web2, which uses email as a username that can be tracked across platforms, Internet Identity removes this tracking.</li>
<li>Multi-device management is more convenient. You can log into the same account on any device that supports biometrics, rather than being restricted to a single device.</li>
<li>Independence from central service providers, achieving true decentralization. This is unlike the Web2 model where usernames correspond to email service providers.</li>
<li>Use a delegated authentication process, no need to sign again every time you log in, providing a better user experience.</li>
<li>Supports logging in using dedicated security devices such as Ledger or Yubikey, enhancing security.</li>
<li>Hide the user's actual public key, and privacy can be ensured by preventing the transaction record from being queried through the public key.</li>
<li>Seamlessly compatible with Web3 blockchain, it can securely and efficiently log in and sign blockchain DApps or transactions.</li>
<li>Advanced architecture, representing the organic integration of the advantages of Web2 and Web3, is the standard for future network accounts and logins.</li>
</ol>
</li>
<li>In addition to providing a new user experience, the following technical measures are also taken to ensure its security:
<ol>
<li>Use the TPM security chip to store the private key. This chip is designed so that even developers cannot touch or extract the private key, preventing the private key from being stolen.</li>
<li>Biometric authentication such as fingerprint or facial recognition and other two-factor authentication mechanisms require verification with the device, so only the user who holds the device can use this identity.</li>
<li>The session key adopts a short-term expiration design to limit the time window for theft, and forces the destruction of the related ciphertext at the end of the session to reduce risk.</li>
<li>Public key encryption technology encrypts data during transmission, and external listeners cannot know the user's private information.</li>
<li>Does not rely on third-party identity providers. The PRIVATE KEY is generated and controlled by the user, not trusting third parties.</li>
<li>Combined with the immutability brought by the IC blockchain consensus mechanism, it ensures the reliability of the entire system operation.</li>
<li>Continuously updating and upgrading related cryptographic algorithms and security processes, such as adding more secure mechanisms such as multiple signatures.</li>
<li>Open source code and decentralized design optimize transparency, which is conducive to community cooperation to enhance security.</li>
</ol>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/12.png" alt="Internet Identity" style="zoom:50%;" />
<p>Internet Identity</p>
<h3 id="core-team"><a class="header" href="#core-team">Core Team</a></h3>
<ul>
<li>The <a href="https://dfinity.org/">team</a> consists of 200+ employees, all of whom are very elite talents. The team has published 1600+ papers, cited 100k+ times, and holds 250+ patents.
<ul>
<li>The founder, <a href="https://www.linkedin.com/in/thedwilliams/">Dominic Williams</a>, is a crypto-theorist and a serial entrepreneur.
<ul>
<li><strong>Academically speaking</strong>, his recent mathematical theories include Threshold Relay and PSC chains, Validation Towers and Trees, and USCID.</li>
<li><strong>From a technical background</strong>, he has a deep background in technology R&amp;D and has been involved in the field of big data and distributed computing in his early years. This has laid a technical foundation for building the complex ICP network.</li>
<li><strong>From an entrepreneurial perspective</strong>, he previously operated an MMO game using his distributed system, which hosted millions of users. In 2015, Dominic started Dfinity, and he is also the president and CTO of String Labs.</li>
<li><strong>From a visionary perspective</strong>, he proposed the concept of a decentralized Internet more than 10 years ago. It is not easy to promote this grand project for a long time, and his design ideas are very forward-looking.</li>
</ul>
</li>
<li>In terms of the technical team, Dfinity's strength is very strong. The Dfinity Foundation has/ha gathered a large number of top cryptography and distributed system experts, such as <a href="https://www.linkedin.com/in/jancamenisch/">Jan Camenisch</a>, <a href="https://inf.ethz.ch/people/person-detail.roscoe.html">Timothy Roscoe</a>, <a href="https://people.mpi-sws.org/~rossberg/">Andreas Rossberg</a>, <a href="https://www.linkedin.com/in/mariadubovitskaya/">Maria D.</a>, <a href="https://www.linkedin.com/in/victor-shoup-a3405284/">Victor Shoup</a>, etc. Even the &quot;L&quot; in the BLS encryption algorithm - <a href="https://www.linkedin.com/in/benjamin-lynn-51832a8/">Ben Lynn</a> is at Dfinity. This provides strong support for ICP's technical innovation. The success of a blockchain project cannot be separated from technology, and the gathering of top talents can bring about technological breakthroughs, which is also a key advantage of ICP.</li>
</ul>
</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/13.png" alt="Dfinity Foundation Team" style="zoom:33%;" />
<p>Dfinity Foundation Team</p>
<h3 id="fund-raising--tokenomics"><a class="header" href="#fund-raising--tokenomics">Fund-raising &amp; Tokenomics</a></h3>
<p>If I discuss this part as well, the article will be too long. Therefore, I've decided to write a separate article later to analyze this in detail for everyone. This article focuses more on why ICP has great potential from the perspective of the development direction of the blockchain industry.</p>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/14.png" alt="img" style="zoom:50%;" />
<h3 id="applications"><a class="header" href="#applications">Applications</a></h3>
<ul>
<li>All types of applications can be developed on ICP, including social platforms, content creator platforms, chat tools, games, and even metaverse games.</li>
<li>Many people say that because it is difficult to achieve global state consistency on IC, it is naturally not suitable for DeFi. But I think this problem itself is wrong. It is not that <strong>global state consistency</strong> is difficult to achieve, but that <strong>global state consistency under low latency</strong> is difficult to achieve. If you can accept a minute's time, 10,000 machines worldwide can also achieve global consistency. Ethereum and BTC now have so many nodes, haven't they already been forced to achieve <strong>global state consistency under high latency</strong>, and therefore they currently can't achieve horizontal infinite expansion. IC solves the problem of <strong>horizontal infinite expansion</strong> by splitting subnets first. As for global state consistency under low latency, it can be achieved through <strong>strong consistency distributed consensus algorithms</strong>, <strong>well-designed network topology</strong>, <strong>high-performance distributed data synchronization</strong>, <strong>effective time stamp verification</strong>, and mature <strong>fault tolerance mechanisms</strong>. But to be honest, building a trading platform at the application level on IC is more difficult than what Wall Street people are doing now with high-performance trading platforms, and it's not just about achieving consistency across multiple data centers. However, the difficulty does not mean that it is completely impossible to do, but that many technical problems must be solved first, and a moderate state will eventually be found that ensures both security and an acceptable user experience. For example, ICLightHouse below.</li>
<li><a href="https://iclight.house/">ICLightHouse</a> is an orderbook dex running fully on chain. What is the concept of fully on chain? How many technical difficulties need to be solved? On other public chains, people don't even dare to think about this, but on IC, at least it's doable and gives us hope.</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/15.png" alt="img" style="zoom:50%;" />
<ul>
<li><a href="https://oc.app/home">OpenChat</a> is a decentralized chat application with an excellent user experience. I haven't seen a second such product in the entire blockchain industry. Many other teams have also attempted in this direction before, but they all ultimately failed due to various technical problems. The root cause is that users feel that the experience is not good, such as the speed is too slow, sending a message takes 10 seconds, and receiving someone else's message also takes 10 seconds. However, a small team of three people on ICP has created such a successful product. Just how smooth it is, you have to experience it for yourself. You're welcome to join the organization, where you can enjoy the collision of ideas and to a certain extent, the pleasure of free speech.</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/16.png" alt="img" style="zoom:50%;" />
<ul>
<li><a href="https://mora.app/">Mora</a> is a platform for super creators, where everyone can create a planet and build their own personal brand. The content you output is always yours, and it can even support paid reading. It can be described as a decentralized knowledge planet, and I now read articles on it every day.</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/17.png" alt="Mora - 0xkookoo" style="zoom:33%;" />
<p>Mora - 0xkookoo</p>
<ul>
<li>OpenChat and Mora are products that I <strong>truly use almost every day</strong>. They give me a sense of comfort that is hard to leave, and if I were to describe it in two words, it would be freedom and fulfillment.</li>
<li>There are already some teams developing gaming applications on IC. I think the narrative of fully-on-chain games may eventually be taken over by IC. As I said in the <a href="https://mirror.xyz/0xkookoo.eth/BF7jfmieDL4AxzQKRuyCF0MzZ7mmmrVlCuF5CRoAbAk">GameFi section of the article</a> I wrote earlier, playability and fun are things that the project team needs to consider, and playability is easier to achieve on IC. Looking forward to the masterpiece from <a href="https://yegk3-bqaaa-aaaae-aajza-cai.icp0.io/">Dragginz</a>.</li>
</ul>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/18.png" alt="img" style="zoom:73%;" />
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<ul>
<li>ICP is like the Earth, with Chainkey technology serving as the Earth's core. Its relationship with ICP is akin to the relationship between TCP/IP protocol and the current entire internet industry. Each Subnet is like a continent such as Asia, Africa, or Latin America. Of course, a Subnet could also be likened to the Pacific or Atlantic Ocean. Within these continents and oceans, there are various buildings and regions (Replicas and Nodes). Each area and building can grow plants (Canisters), and different animals live happily.</li>
<li>ICP supports horizontal expansion. Each Subnet is autonomous and can communicate with other Subnets. No matter what type of application you have‚Äîbe it social media, finance, or even the metaverse‚Äîyou can achieve eventual consistency through this distributed network. It's easy to achieve a global ledger under synchronous conditions, but it's a significant challenge to achieve &quot;global state consistency&quot; under asynchronous conditions. Currently, <strong>only ICP has a chance to do this</strong>.</li>
<li>Note that I'm not referring to &quot;worldwide state consistency,&quot; but &quot;global state consistency.&quot; &quot;Global state consistency&quot; requires all participating nodes to reach consensus on the order of all operations, ensure the final result is consistent, objectively consistent regardless of whether nodes encounter faults, ensure clock consistency, and provide immediate consistency as all operations are processed synchronously. This can be ensured within a single IC Subnet. However, if you want to guarantee &quot;worldwide state consistency,&quot; all Subnets physically all over the world as a whole need to achieve &quot;global state consistency&quot; regarding the same data and state. In practical implementation, this is impossible to achieve with low latency, which is also the bottleneck preventing public chains like ETH from scaling horizontally. Therefore, IC opts to reach consensus within a single Subnet, and other Subnets quickly verify the results to ensure no fraud has occurred, thereby achieving &quot;eventual global state consistency.&quot; This is essentially <strong>a combination of the decentralization of large public chains and the high throughput and low latency of consortium chains</strong>, all while enabling infinite <strong>horizontal expansion</strong> of Subnets through mathematically and cryptographically proven methods.</li>
</ul>
<p>In summary, according to my initial thoughts on the ultimate development direction of blockchain, which involves <strong>Sovereignty</strong>, <strong>Decentralized Multipoint Centralization</strong>, <strong>Transparency</strong>, <strong>Control over Code Execution</strong>, and <strong>Infinite Scalability with Linear Cost</strong>:</p>
<ul>
<li><strong>Sovereignty</strong>: This is the only problem blockchain needs to solve, including asset sovereignty, data sovereignty, and speech sovereignty. Otherwise, there's no need for blockchain.
<ul>
<li><em>IC has completely achieved this.</em></li>
</ul>
</li>
<li><strong>Immutability</strong>: This is a sufficient condition, but not a necessary one. As long as you can ensure that my sovereignty is not compromised, I don't care about tampering. If everyone's assets in the world are tampered with and doubled proportionally, what's the difference?
<ul>
<li><em>IC has also achieved this.</em></li>
</ul>
</li>
<li><strong>Decentralization</strong>: Complete decentralization is impossible. No matter how it's designed, there will always be &quot;gifted&quot; individuals or stakeholders with greater say. There will always be people who voluntarily choose not to participate. <strong>Decentralized multipoint centralization</strong> is the ultimate pattern.
<ul>
<li><em>IC is currently the best among all public chains. It manages to maintain a certain degree of decentralization while fully utilizing the advantages of centralized entities, thereby better facilitating network governance and operation.</em></li>
</ul>
</li>
<li><strong>Transparency</strong>: This is a must. Isn't this grand social experiment involving all of humanity about giving everyone a voice and the ability to protect their own sovereignty? Some people may be lazy, some may prefer to trust professionals, and some may choose to give up voting for maximum efficiency. However, these are choices they actively make. They have the right but voluntarily choose not to exercise it. As long as everything is transparent and there's no underhanded manipulation, I'm willing to accept the outcomes. If I lose, it's because my skills were inferior. Survival of the fittest aligns with the market economy.
<ul>
<li><em>IC has completely achieved this.</em></li>
</ul>
</li>
<li><strong>Control over Code Execution</strong>: This is the core. Without it, the rest is unnecessary. If a vote is publicly announced for a week, and in the end, the project team still deploys a malicious version of the code, or even if it's not malicious, it's still a mockery of everyone.
<ul>
<li><em>Currently, <strong>only IC</strong> has achieved this.</em></li>
</ul>
</li>
<li><strong>Infinite Scalability with Linear Cost</strong>: As blockchain becomes more and more intertwined with real life, more and more people are participating, and the demand is growing. If the infrastructure cannot support unlimited scalability, or if it's too expensive to expand, it's unacceptable.
<ul>
<li><em>Currently, <strong>only IC</strong> has achieved this.</em></li>
</ul>
</li>
</ul>
<p>Based on these facts and my analytical thinking, I believe that <strong>ICP = Web 3.0</strong>.</p>
<p>This article is just to discuss why ICP might be the innovation driver for Web/Blockchain 3.0 from the perspective of the future development direction of the blockchain industry. Admittedly, there are some issues with ICP's tokenomics design, and its ecosystem has not yet exploded. At present, ICP still needs to continue its efforts to reach the ultimate Blockchain 3.0 I envision.</p>
<p>However, don't worry, this task is inherently difficult. Even the Dfinity Foundation has prepared a 20-year roadmap. Only two years after the mainnet launch, it has already achieved great accomplishments. Currently, it's also bridging the BTC and ETH ecosystems using cryptographic methods. I believe that it will reach greater heights in three years.</p>
<img src="1.OverviewofIC/assets/ICP = Web 3.0/19.png" alt="img" style="zoom:50%;" />
<h2 id="future"><a class="header" href="#future">Future</a></h2>
<ul>
<li>ICP has already completed the infrastructure construction from bottom to top, and applications from top to bottom are beginning to emerge. My recent direct impression is that ICP has more and more cards to play, preparing for the next bull market.</li>
<li>ICP represents a paradigm shift, not just a simple technical upgrade. It signifies the transition from standalone computing to distributed computing, and even more so, from standalone systems to distributed systems. The concept of decentralized cloud computing can provide many small companies with a one-stop development experience right from the start.</li>
<li>According to the product value formula by Yu Jun: <strong>Product Value = (New Experience - Old Experience) - Migration Cost</strong>, in the future, as long as some people find that the experience gain of joining the ICP ecosystem outweighs the migration cost, more people, including project parties and users will join. This will make the scale effect of &quot;cloud computing&quot; more evident. Once the &quot;chicken or egg&quot; problem is solved, the positive flywheel of ICP will be established.</li>
<li>Of course, everyone's definition of experience is subjective, so some people will choose to join early, while others will join later. Those who join earlier bear greater risks, but they usually also receive greater average benefits.</li>
<li></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brief-description-of-the-p2p-layer"><a class="header" href="#brief-description-of-the-p2p-layer">Brief Description of the P2P Layer</a></h1>
<p>The P2P layer is primarily responsible for transmitting protocol messages between replicas within a subnet. These messages include those required to reach consensus, such as block proposals and attestations, as well as ingress messages from the message routing layer. When edge nodes send messages, the P2P layer of the replica receives and broadcasts these messages.</p>
<p>There are two main types of these messages: one is the signed messages used to reach consensus, and the other is the input messages sent by user clients. For input messages sent by users, the P2P layer will arrange them in order so that the consensus layer can package the data into payloads and generate blocks in order.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/image-20230709112450955.png" style="zoom:40%;" />
</div>
<h2 id="artefacts"><a class="header" href="#artefacts">Artefacts</a></h2>
<p>For example, we have a Neutron Star Express Company (IC), and the P2P layer is the distribution network of the express company, responsible for transmitting parcels (message) between distribution points (replicas) in region (subnet). </p>
<p>The P2P layer is a broadcast channel. The design of the P2P layer ensures that if an honest distribution point (replica) broadcasts a message, the message will eventually be received by all honest replicas in the subnet. Even if someone tries to maliciously interfere or the network is occasionally interrupted, the parcel can still be delivered efficiently to the recipient. Even if some replicas fail, it cannot affect the mutual communication between honest replicas. </p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/2023-06-12-2125.png" style="zoom:50%;" />
</div>
<p>Each delivery terminal (replica) has some parcels, these parcels are &quot;artefacts&quot;. So each delivery terminal (replica) has an &quot;artefact pool&quot; to store its own information. Artefacts are the information used by the delivery terminals to create, verify and reach consensus. This information can be consensus block proposals, user ingress information or response signatures for HTTPS external calls. The delivery terminals will distribute these parcels to other delivery terminals so that they all know the status of the subnet.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/23-06-12-2125.png" alt="23-06-12-2125" style="zoom:50%;" />
</div>
<p>delivery terminals, the P2P layer is called. This is like a express company manager (such as a component of the consensus layer) notifying the delivery staff that they need to send out a new parcel. For example, now a delivery terminal (replica) has created a new block proposal and needs to send it to other delivery terminals in the subnet. Or, for example, a delivery terminal (replica) receives a parcel from another delivery terminal and then forwards it elsewhere.</p>
<h2 id="advertise-request-deliver"><a class="header" href="#advertise-request-deliver">Advertise-Request-Deliver</a></h2>
<blockquote>
<p>The P2P layer is responsible for ensuring high throughput, which is more important than low latency.</p>
<p>However, in the consensus protocol, some messages, especially block proposals, are very large. And according to the consensus protocol, for security reasons, these messages will be repeatedly broadcast by all replicas.</p>
</blockquote>
<p>They hope to deliver a large number of parcels as fast as possible (high throughput), but also consider transportation costs (bandwidth).</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/2-2125.png" alt="2-2125" style="zoom:50%;" />
</div>
<p>The express company adopts a advertise-request-deliver mechanism to improve efficiency. When a delivery terminal (replica) has an important parcel (large message) to send, they will not send the parcel directly. Instead, they will send a parcel list (adverts) to inform other delivery terminals that there is an important parcel. When other delivery terminals receive this list and confirm that this is the parcel they need, they will actively contact the sending delivery terminal (request) and request to deliver the parcel (deliver). This process may sacrifice some time (latency), but it can save transportation costs (reduce bandwidth usage). For small parcels (messages), it is not worth sacrificing latency to pursue bandwidth. You can skip the advertisement and send the message directly.</p>
<blockquote>
<p>In order to save bandwidth, the P2P layer will create a short message called Advertisements, which is very small and only contains the hash value of the artefact and some metadata. Then these messages are broadcast to other replicas. When other replicas receive the advertisement, they will determine whether they want to download the relevant artefact. If the answer is yes, they will send an explicit request message to the replica that issued the advertisement.</p>
</blockquote>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/image-20230709111757557.png" alt="image-20230709111757557" style="zoom:50%;" />
</div>
<p>If this express company operates well and develops into a very large scale, containing many delivery terminals. At this time, the advertise-request-deliver mechanism can run on an overlay network. In this <strong>overlay network</strong>, each delivery terminal only sends parcels to their partners (peer nodes/peers). When a delivery terminal wants to broadcast a parcel, it will first tell the parcel list to its partners. Those partners may request the delivery of the parcel after receiving the list, and under certain conditions, tell the parcel list to their partners. This is like a gossip network, one passes ten, ten passes a hundred. If the number of replicas in the subnet is small, the advertisement will be sent to all replicas in the subnet.</p>
<p>The express company (P2P network) can effectively reduce transportation costs (bandwidth usage) at the cost of a certain delay, achieving the goal of high throughput. This is very important for an efficient express company (distributed network system).</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/023-06-12-2125.png" alt="023-06-12-2125" style="zoom:50%;" />
</div>
<p>But don't be careless. In order to ensure that each parcel is complete, secure and efficiently delivered, each advertisement contains an integrity hash value, like the barcode of the parcel. After downloading the parcel, the delivery terminal will check the downloaded content to ensure that it matches the hash value in the advertisement, so as to ensure the integrity of the parcel.</p>
<p>Of course, relying solely on hashes is not secure enough. Malicious delivery terminals may send an advertisement and then send a forged parcel with a hash value that matches the hash value in the advertisement. At this time, the delivery terminal needs to check that the parcel meets the requirements (for example, check if the parcel has the correct signature) before further processing or forwarding it to other delivery terminals to ensure that the parcel is secure.</p>
<p>When it is found that the received advertisement has a problem or when joining a new subnet, the delivery terminal will send a retransmission request to other delivery terminals. This request can be sent to a specific delivery terminal or to all delivery terminals. The request contains information about the current status, and other delivery terminals can help the delivery terminal update its status by sending advertisements. Learn more <a href="2.CoreProtocol/Relatedconcepts/P2PLayerAndMaliciousAttack.html">here</a>.</p>
<h2 id="chunks"><a class="header" href="#chunks">Chunks</a></h2>
<p>Sometimes some parcels (such as state synchronization artefacts) are too large to send as a whole. We can cut them into several small data blocks (Chunks), and then use an advertisement to represent these data blocks.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/image-20230706130824275.png" alt="image-20230706130824275" style="zoom:50%;" />
</div>
<p>When downloading these data blocks, the delivery terminal will try to download the corresponding data blocks from multiple delivery terminals that have issued advertisements. This can speed up the download speed and make better use of bandwidth. Blocked parcels will undergo verification of individual blocks and the whole, and the corresponding delivery terminals will be responsible for verifying individual blocks.</p>
<h2 id="re-request"><a class="header" href="#re-request">Re-request</a></h2>
<p>Courier companies need to ensure that parcels are delivered on time. Sometimes, for some reason, the parcel list (announcement) may have problems during the journey, such as the courier forgetting to scan the bar code of the parcel, the delivery is overdue or the parcel list is lost. Or when new delivery terminals are added to the subnet.</p>
<p>At this time, the delivery terminal needs to send a &quot;re-request&quot;, similar to asking: &quot;Hey, did I miss any parcels? Did I miss any information? Please send it to me again.&quot;</p>
<p>Other delivery terminals can send the information he missed to him. Although re-requests are mainly to help delivery terminals synchronize missed parcels, delivery terminals will regularly send such requests to ensure accurate parcel delivery.</p>
<h2 id="transport"><a class="header" href="#transport">Transport</a></h2>
<p>The core business of courier companies is to transport parcels between locations. The transport component at the P2P layer, which is the transport tool (trucks, airplanes, etc.) of the courier company, is responsible for transporting parcels from one place to another. These means of transport create TLS-based TCP connections between delivery terminals, and both parties verify their identities with their own private keys. The transport layer protocol will choose appropriate methods according to network conditions, parcel size and other factors to ensure that parcels can be smoothly transported (Transport). The protocol has certain fault tolerance and ability to handle network failures.</p>
<p>In order for delivery terminals to know which delivery terminals they should connect with, courier companies need to maintain a &quot;roster&quot; (NNS Canister registration) containing information about all delivery terminals. This roster will contain the address of the delivery terminal and a special identifier for identity verification.</p>
<blockquote>
<p>Each replica has its own public key, stored in a place called the &quot;Network Nervous System&quot; (NNS). To prevent DOS attacks, replicas only connect with other replicas in the same subnet. Connections between replicas will be adjusted according to NNS records.</p>
<p>The NNS registry also contains the latest subnet membership information (which replicas belong to which subnet) and historical information. Replicas query the NNS registry to learn about their own membership, replicas, IP addresses, and public keys. When establishing a TLS connection, replicas can ensure that they only connect to other replicas in the same subnet, enabling two-way identity verification.</p>
</blockquote>
<div class="center-image">
    <img src="2.CoreProtocol/assets/P2Player/125.png" alt="125" style="zoom:37%;" />
</div>
<p>Over time, courier companies may open new delivery terminals or close some old delivery terminals. Therefore, the transport component needs to constantly track these changes and accordingly adjust the connections with the delivery terminals.</p>
<p>In addition, the transport component also needs to ensure that communication lines are unobstructed and automatically re-establish contact in case of problems. The transport component provides a mechanism to maintain stable connections, can quickly detect connection problems (through heartbeat mechanisms), and automatically re-establish connections when connections are disconnected. When a TCP connection is idle for more than 200 milliseconds, the system will send a heartbeat message. On the receiving end, if no data (including heartbeat messages) is received within 5 seconds, the connection will be disconnected and reconnection will be attempted. This avoids the possibly very long timeout of the TCP protocol, which sometimes occurs when Internet routing changes. After successfully re-establishing the connection, a retransmission request will be sent to the corresponding replica.</p>
<p>Sometimes, the transport component will also connect with delivery terminals (replicas) that have just been deleted from the registry until the consensus layer no longer needs such connections.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>The P2P layer efficiently transports parcels through the announcement-request-delivery mechanism, while using integrity hash values and other checks to ensure the correctness of parcels. The transport component is responsible for transmitting parcel information between couriers and sorting centres. It uses a method called retransmission request to ensure that no critical information is missed, and performs identity verification and reconnection when needed. It provides an efficient, secure and stable communication basis for information transmission through various mechanisms.</p>
<br>
<p>This is the introduction to the P2P layer, let's now take a look at how <a href="2.CoreProtocol/IntroductiontoConsensusLayer.html">the consensus layer</a> of IC operates!</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-consensus-layer"><a class="header" href="#introduction-to-consensus-layer">Introduction to Consensus Layer</a></h1>
<h2 id="what-pouw-isnt-it-pow"><a class="header" href="#what-pouw-isnt-it-pow">What? PoUW? Isn't it Pow?</a></h2>
<p>Consensus on IC ? Take a look at this term: PoUW, Proof of Useful Work.</p>
<p>Does it looks familiar to you?</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/image-20230131200036914.png" style="zoom:25%;" />
</div>
<p>Proof of Work (PoW) is the consensus algorithm of Bitcoin, which is very inefficient from today's perspective, but still it is relatively secure. </p>
<p>What is Proof of Work ? </p>
<p>Imagine a school organizing an competitive exam, only students who get full marks are eligible to put their names on the &quot;Honor Wall&quot; of the Education Bureau, they will be also rewarded with one full bitcoin! The school is open 24 hours a day, anyone can come and take the exam at any time, and the results will be released automatically after finishing all the questions. After one student gets full marks, the answer sheets of students who are still taking the exam will be immediately invalidated. That is because the answer (full mark paper) has already been born. In addition,other students must copy the full mark paper and then start the next exam.</p>
<p>In the school of PoUW, the candidates are randomly divided into several classes, and the exams are conducted in these classes. This time,not everyone can enter the school but only teachers can join. Each class completes a set of questions together. Since everyone is supposed to be an experienced teacher, they will roll the dice to decide who gets to do the first question, and who gets to do the second ... After finishing the questions, everyone has to discuss and reach a consensus on various opinions, and then hand in the papers eventually. Each person in the class shares the reward equally.</p>
<br>
<p>How efficient it is!üòâüòé</p>
<p>PoUW adds a 'U' to PoW, it significantly improves performance and reduces useless work for node machines. PoUW does not artificially create difficult hash calculations. It tries to put as much computing power as possible into serving users of the network. Most resources (CPU, memory) are used to execute codes in Canisters.</p>
<h2 id="how-is-consensus-reached"><a class="header" href="#how-is-consensus-reached">How is Consensus Reached?</a></h2>
<p>No matter what, Bitcoin is the Patriarch of blockchain. Even though the consensus reaching speed is inefficient, it is a solution to distributed system issues.</p>
<p>Satoshi Nakamoto's Bitcoin is a feasible solution to the &quot;Byzantine generals problem&quot;.</p>
<p>Simply put, this problem involves attempts to reach consensus on a course of action through information exchange in an unreliable network with potential threats. Satoshi Nakamoto's solution used the concept of Proof of Work to reach consensus without a centralized authority that needs to be trusted, representing a scientific breakthrough in distributed computing and transcending the widespread applicability of currency.</p>
<br>
<p>However, can consensus only be reached in this way? Is there a more efficient way with high security?</p>
<p>Let's talk about the essence of consensus.</p>
<br>
<p>The essence of consensus is to maintain data consistency in a globally distributed network.</p>
<p>Bitcoin's approach is that everyone competes for computing power to determine who gets to pack valid blocks, then everyone has to copy the winner's blocks. In this way, Bitcoin transaction ledgers will have multiple copies, and the goal of keeping data consistent across all nodes is achieved. However, the efficiency is very low.</p>
<br>
<p>Let's take a look at the logic of consistency here:</p>
<p>The goal: Maintain data consistency across all nodes.</p>
<p>The method: Rely on some means to select a node to pack the block, and others copy the block packed by that node. The same node cannot be selected repeatedly in a continuous way, and the process of getting selected to generate the blocks is random.</p>
<p>Let us analyse the purpose only. Since the purpose is to maintain data consistency between nodes, as long as the nodes receive messages at the same time, the problem will be solved.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/image-20230531145221186.png" alt="image-20230531145221186" style="zoom:21%;" />
</div>
<p>In the actual network environment ,it could not be achieved. Information transmission always has varying delays, not to mention that nodes are not located in a same place. The locations of clients are also far and near,the transmission distances are different. It is chaotic and sounds impossible to guarantee that all nodes receive messages at the same time. What should we do?</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG2.png" alt="IMG2" style="zoom:33%;" />
</div>
<p>The answer is simple. Building a &quot;relay station&quot; can solve this problem. No matter where the messages come from, they are first queued in the relay station, then the relay station sends the messages and execution order to the nodes. As long as the nodes execute the operations in the order received from the relay station, data consistency can be guaranteed!</p>
<p>It is not over yet! Since there is another big issue: Centralization. All nodes have to obey the commands of the relay station. If the relay station says to execute messages in the order of ABDC, the nodes have to follow ABDC. Going round and round a big circle, the result returns to its starting point. So how can we sort messages in a decentralized way?</p>
<br>
<p>Decentralizing is actually simple, that is, doing something completely independent of any other one. There is no &quot;boss&quot; or &quot;manager&quot;.It is very democratic,  everyone works together to reach a consensus. Anyone who comes is allowed to pick up the jobs, and anyone who leaves will not affect the continuous operation of the system. (Unless everyone leaves, but with economic incentives, someone will always come!)</p>
<p>So how can we design it? The nodes need to reach consensus on the order of executing messages and we need to decentralize the working process of the relay station.</p>
<br>
<p><strong>IC is designed like this</strong>: (IC abstracts nodes into replicas in subnets)</p>
<p>We could not rely on a relay station. Although the time for messages to arrive at each replica may be different (that is, the time of executing messages is different), all replicas must execute messages in the same order.</p>
<p>The IC uses state machine replication, where each replica is a state machine. As long as the input messages are the same, the internal states of the replicas will be identical.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG3.png" alt="IMG3" style="zoom:25%;" />
</div>
<p>Then if everyone's order is different, which order should be executed? It will use random number to decide! (IC's Random Beacon)</p>
<p>IC uses a verifiable random function (VRF) at the base layer. It can generate unpredictable random numbers, and everyone can verify that the random numbers are not made by human.</p>
<p>VRF uses threshold BLS signature scheme. The threshold BLS signature algorithm uses DKG to distribute private key shares to replicas. This is a non-interactive distributed key generation protocol. DKG can distribute private key shares between members. There is no need for a trusted third-party, it does not depend on any member to distribute private key shares, avoiding single points of failure. Everyone uses the private key shares to sign information. Once the signature reaches the threshold, it can be aggregated into a complete signature. The signature process is non-interactive. Any third party can aggregate after receiving enough shares. Anyone can verify the signature with the unique public key. The public key is also recorded in the NNS registry.</p>
<br>
<p>If a message is confirmed, no matter which private key shares participate in the signature, as long as the threshold quantity is reached (the threshold for generating the Random Beacon is one-third), the final unique signature information can be aggregated. For example, the threshold in the following figure is 6. In order for the 16 replicas to generate the random beacon signature for this round, as long as the signature is greater than 6, it can be aggregated.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG4.png" alt="IMG4" style="zoom:25%;" />
</div>
<p>As long as the bad guys get less than one-third of the private key shares, they cannot interfere with the threshold BLS signature. It is also impossible to predict the signature result because the private key shares are not enough. That is to say, no one knows the signature result.</p>
<blockquote>
<p>The consensus of the subnet can resist up to less than one-third malicious replicas. If the malicious replicas are less than one-third, all they can do is sign or not sign, they are unable to interfere with the final result of the threshold signature, nor prevent the signature from being generated. If malicious replicas are greater than or equal to one-third, the subnet has been destroyed, so the random number does not matter. Therefore, the threshold for the random beacon is low, at one-third. </p>
</blockquote>
<ul>
<li>In the traditional RSA algorithm, you control the private key and the message is public, which is equivalent to knowing the signature result yourself. After the private key is leaked, others can also know the signature result in advance.</li>
<li>However, in the threshold BLS  signature algorithm, a group of people control the private key shares. The signer himself does not have the complete private key, so he does not know the signature result. Only after everyone has signed and aggregated ,then they know the signature. Throughout the process, no one knows the global private key, but the signature result is the result recognized by most people. A group of people generate signatures, and no individual can predict the signature result. A single person cannot prevent the signature from being released.</li>
</ul>
<img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/image-20230918231945413.png" style="zoom:70%;" />
<br>
<p>This can serve as Random Beacon to provide a reference for which replica to produce a block. This random number is also a consensus result and cannot be tampered with by a single person. Moreover, this can continuously safely generate random numbers, as long as different information is used for each round of signatures. This different information is naturally the random beacon and some block dkg_ids of the previous round, so that the information signed in each round is different.</p>
<p>IC's random beacon, notarization, finality, random tape, and certified copy status all use threshold BLS signatures. (The random tape and certified copy status are content at the execution layer)</p>
<br>
<h2 id="solution"><a class="header" href="#solution">Solution</a></h2>
<p>Let us take a closer look on how IC's consensus protocol produces a block:</p>
<h3 id="preparation-before-block"><a class="header" href="#preparation-before-block">Preparation Before Block</a></h3>
<p>The consensus protocol produce block by rounds. For example, consensus is reached on the genesis block in round 1, and round 6 for block 6.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG5.png" alt="IMG5" style="zoom: 67%;" />
</div>
<p>Before start, the subnet first randomly selects some replicas to form a &quot;consensus committee&quot; according to the number of replicas. If the number of replicas is too low, all replicas will join the committee. The members in the committee are responsible for producing the blocks, so even if there are a large number of replicas in the subnet, it will not affect performance.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG6.png" alt="IMG6" style="zoom: 67%;" />
</div>
<p>There is also the concept of &quot;<strong>epoch</strong>&quot; in the subnet. An epoch is approximately a few hundred rounds. The NNS can adjust the epochs for each subnet.</p>
<p>Each subnet operates within epochs that contain multiple rounds (typically around a few hundred rounds). Different replicas make up the committees in each epoch.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG7.png" alt="IMG7" style="zoom: 80%;" />
</div>
<p>At the end of each epoch, the consensus committee members for the next epoch are selected through the random beacon, and the current consensus committee members will all become random beacon committee members in the next epoch.</p>
<p>The first block of the new epoch contains the list of consensus committee members and random beacon committee members for this epoch.</p>
<br>
<p>And at the beginning of the new epoch, the private key shares will be redistributed to the members. This process is called <a href="2.CoreProtocol/">Pro-active Resharing of Secrets</a>. There are two reasons for doing this:</p>
<ul>
<li>When the members of the subnet change, resharing can ensure that any new member will have new private key shares, and any member exiting the subnet will not have a new private key share.</li>
<li>Even if a small amount of private key shares are leaked to attackers in each epoch, it will not threaten the consensus.</li>
</ul>
<br>
<p>The number of consensus committees is related to the total number of replica members in the subnet. To improve scalability, in small-scale networks, committee members can be all replicas. In large-scale networks, committee members are part of all replicas and constantly changing in each epoch.</p>
<br>
<p>The number of consensus committee members cannot be too large or too small. Too few are insecure, too many affect the consensus speed.</p>
<p>So the relationship between the number of committees and the total number of members has a mathematical model to describe: When the total number of members in the subnet tends to infinity, the hypergeometric distribution tends to the binomial distribution, that is, non-replacement random sampling tends to replacement random sampling. Because the total number of replica members is infinite, there is no difference between replacement and non-replacement. If you are interested, you can read the introduction <a href="2.CoreProtocol/Relatedconcepts/HowToPickNumberInConsensus.html">here</a>.</p>
<br>
<p>Once the preparation is complete, blocks can be produced.</p>
<br>
<h3 id="block-maker"><a class="header" href="#block-maker">Block Maker</a></h3>
<p>At the start of each round, the random beacon generated from the previous round produces a ranking to determine the weight of members to produce blocks. The leader with the highest weight is given priority to produce blocks. (As shown in the figure below, the ranking assigns a number from 0 to 4 to the 5 consensus committee members, with 0 having the highest weight)</p>
<p>Under normal circumstances, the leader is honest and the network connection is normal. The leader is responsible for producing blocks. Others are waiting to notarize the leader's block. Even if block from the 2nd member is received, it will not be notarized until the leader's block is received.</p>
<p>At the same time, the random beacon committee will also package, sign and broadcast the hash of the previous round's beacon and the NiDKG record of this round. When the signature reaches the threshold, this round's random beacon is generated, which also determines the block production weight for the next round.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG8.png" alt="IMG8" style="zoom:80%;" />
</div>
<p>A non-genesis block generally contains:</p>
<ul>
<li>The messages received from the time the previous block was notarized to the time this block was packaged, called the &quot;<strong>payload</strong>&quot;.</li>
<li>The hash of the previous block.</li>
<li>The ranking of the block-producing replica.</li>
<li>The height of the block.</li>
</ul>
<br>
<p>After the block is assembled, the replica responsible for producing the block will generate a <strong>block proposal</strong>, including:</p>
<ul>
<li>The block itself.</li>
<li>Its own identity.</li>
<li>Its own signature on this block.</li>
</ul>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG9.png" alt="IMG9" style="zoom:67%;" />
</div>
<p>Then broadcast the block proposal to other members.</p>
<p>The leader produces a block and broadcasts it to everyone. After notarization is completed, since only the leader's block is notarized, there is no need for finalization, and it enters the next round. This is the fastest and most common situation. About 1 second to finalize a block. (Optimistic responsiveness: The protocol will continue to execute based on actual network latency rather than the upper limit of network latency)</p>
<br>
<p>If after waiting for a period of time, the leader's block has not been received, it may be that the leader has a poor network or the machine has malfunctioned. Only then will members accept block from 2nd member or 3rd member and notarize their blocks.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG10.png" alt="IMG10" style="zoom:67%;" />
</div>
<p>The system has an agreed upon waiting time. If the leader's block is not received within a period of time, it will expect block 2 in the second time period. Then in the third time period, block 3 is expected. If block 3 is its own, then produce the block itself ...</p>
<br>
<h3 id="notarization"><a class="header" href="#notarization">Notarization</a></h3>
<p><strong>Notarization only verifies the reasonableness of the block</strong>, and the notarized block does not represent consensus. This ensures that at least one block in the current round can be notarized.</p>
<p>Therefore, notarization does not mean consensus, nor does it require consensus. If multiple blocks have the same weight, these blocks will be signed.</p>
<br>
<p>During notarization, the members of the consensus committee verify the following three aspects:</p>
<ol>
<li>The block should contain the hash of the block already notarized in the previous round.</li>
<li>The payload of the block must meet certain conditions (specific regulations on the payload content, these conditions are independent of the consensus protocol).</li>
<li>The ranking of the replica responsible for producing this block must correspond to the ranking in the random beacon (for example, if the replica ranked 2nd claims to be ranked first, then this block will not be notarized).</li>
</ol>
<br>
<p>If the block information is correct, the replica responsible for verification first signs the block height and block hash, and then forms a &quot;<strong>notarization share</strong>&quot; with the just signed signature, hash, height, and its own identity. Broadcast the notarized shares.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG11.png" alt="IMG11" style="zoom: 25%;" />
</div>
<p>Notarization also uses BLS threshold signatures. When a replica receives enough (the threshold is two-thirds) notarization share, it aggregates the signature share to form a notarization for this block.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG12.png" alt="IMG12" style="zoom:67%;" />
</div>
<p>The aggregated notarization information includes the block hash, block height, aggregated signature, and more than two-thirds of the identity identifiers. Replicas either find that they have collected enough notarization shares and aggregate them into notarizations themselves; or they receive aggregated notarizations from others.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG13.png" alt="IMG13" style="zoom:67%;" />
</div>
<p>After notarization, the block is still broadcast. When other members receive the notarized block, they will re-broadcast the notarized block and will not generate notarization shares for other blocks.</p>
<br>
<p>For example, in the figure below, the girl holding the cell phone and the Blue Hat enter the next round of consensus. When the girl sends messages to the other three people, the network is interrupted for 700 milliseconds. The message forwarded by the blue hat plays a key role. Otherwise, five missing three would not be able to work.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG14.png" alt="IMG14" style="zoom:25%;" />
</div>
<p>If the leader's block has a problem and the notarization fails, the weighting of the second block will now be the largest. If the blocks of the second member and the third member have both passed notarization, the leader of the next round will choose to produce block after the block with the greatest weight. As in round 5 and 6 below, the weight of the 2nd block is greater than the weight of the 3rd block. Adding up the weights of all blocks, the chain composed of yellow and purple blocks is the chain with the greatest weight.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG15.png" alt="IMG15" style="zoom:67%;" />
</div>
<br>
<p>In order to maximize efficiency, each replica has a &quot;maximum waiting time&quot; (Delay functions), which is the maximum waiting time before accepting new blocks or voting on blocks. After this time, it will not wait. The length of this waiting time varies from person to person, and is different for each replica.</p>
<p>If a replica does not receive messages for several consecutive rounds due to network latency, it is because its waiting time is too short. Before the message arrives, it does not wait. If the final confirmation fails, all honest replicas will wait a little longer until the final confirmation is received.</p>
<p>At this time, replicas can appropriately increase the delay and wait a little longer. This makes it more likely to receive messages in the next round.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/image-20230711215857942.png" alt="image-20230711215857942" style="zoom:50%;" />
</div>
<h3 id="finalization"><a class="header" href="#finalization">Finalization</a></h3>
<p>Because sometimes more than one block may be generated (when the leader does not respond, the second and the third may produce block to save time). This requires a finalization. The finalization stage will determine the only block that everyone has notarized. Then the blocks before the block that everyone agrees with will also be implicitly finalized, and other branches will become invalid.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG16.png" alt="IMG16" style="zoom:57%;" />
</div>
<p>The finalization process is specifically:</p>
<p>After a replica finds a notarized block, it will check whether it has notarized any other blocks in this round. If it has not notarized any other blocks, it will broadcast a &quot;finalization share&quot; for the block. To prove that it has only issued a notarization share for this block.</p>
<p>To achieve the finalization of a block, two-thirds of different replicas need to issue finalization share, and then aggregate for the finalization of a block. The format of the finalization share is exactly the same as the notarization share (but marked in a specific way to prevent confusion). After receiving the finalized block, like the notarization process, it will broadcast to other members again.</p>
<p>Note: Replicas do not wait until finalizing all the fragments before proceeding to the next round. The replica just checks if it has notarized any fragments other than the received one whenever it receives a fragment at a certain height, then broadcasts its signed finalized fragment or forwards the received finalized fragment.</p>
<br>
<p>For example, after a replica receives the finalization share of round 10 in round 11, it will check its behaviour at that time and then broadcast a reply.</p>
<p>If after a while, if you receive the finalization of the block in round 10, you can implicitly consider all previous blocks as finalized.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG17.png" alt="IMG17" style="zoom:67%;" />
</div>
<p>These finalized blocks can be considered as safe confirmed by everyone, meaning that all replicas agree with the branch where the finalized block is located. At the height of block 10, only this block has passed notarization. Then the replica reaches consensus at this height.</p>
<br>
<p>For example:</p>
<p>If a replica only generates a notarization share for one block in Round 5, the replica will also issue a finalization share and then enter Round 6 consensus. If the finalization is received later, the branch containing the finalization is considered valid. If the block after finalization does not fork , there will be no problem without finalization.</p>
<p>It is possible that in Round 4, half of the replicas generated notarization shares for the leader and the 2nd blocks, and the other half of the replicas only generated notarization shares for the leader's block. Then the finalization share proposed by the replicas that only notarized the leader's block cannot reach the threshold and cannot obtain finalization. Only half of the replicas generate notarization shares for the 2nd member's block, so the 2nd member's block does not obtain notarization.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/IntroductiontoConsensusLayer/IMG18.png" alt="IMG18" style="zoom:67%;" />
</div>
<p>In summary, if a block is not finalized in a round, the replicas will stay in that round waiting for the block to be finalized.</p>
<p>If at the end of the round, still no block is finalized, it will proceed to the next round and try to finalize the block from the previous round.</p>
<p>In subsequent rounds, as long as the network resumes synchronization and the leader is honest, the block for that round will eventually be finalized.</p>
<p>Once a block in a round is finalized, all the blocks in the previous rounds will also be finalized formally. Notarization only ensures the block exists in the block tree, while finalization locks it on the canonical chain.</p>
<p>Compared with many other blockchains, the advantage of the IC consensus protocol is that it adopts asynchronous finalization. In other blockchains, nodes usually need to find the longest chain. If the chain forks, the nodes need to wait for a while to find the longest chain. If some blocks are missed due to network failures, the longest chain cannot be found, and data from other nodes needs to be synchronized.</p>
<p>The IC protocol does not rely on finding the &quot;longest chain&quot; to eventually confirm the block. IC's finality method only relies on cryptographic signatures, not on the confirmation of the entire chain. A small number of signatures can observe a block consensus formed without waiting for the confirmation of the entire chain. Forks can be eliminated in a short time, and finalization speeds can be achieved in less than one second.</p>
<br>
<p><strong>The consensus process is completed here!</strong></p>
<br>
<p>To summarize, the members of the Consensus Committee need to do 3 things when entering a new round:</p>
<p>(1) See how they rank and then decide whether to produce block yourself</p>
<p>(2) Notarize the block</p>
<p>(3) Observe the blocks, find the main chain, and ignore invalid branches</p>
<p>The Consensus Committee will become a random beacon committee in the next period and be responsible for generating random beacons for each round.</p>
<br>
<p>The consensus process is for the leader to block, everyone verifies and then issues a notarization share, the notarization share reaches the threshold and aggregates into notarization, and enters the next round. Finalization does not have to be completed every round.</p>
<p>The IC consensus protocol ensures that when there are individual malicious attacks, IC's performance will flexibly decrease instead of directly freezing. The consensus protocol currently tends to maximize performance as much as possible in the &quot;optimistic case&quot; without failures.</p>
<p><strong>As the protocol progresses round by round, the blocks connected from the genesis block form a chain that extends continuously. Each block contains a payload, consisting of a series of inputs and the hash of the parent block.</strong></p>
<p>Honest replicas have a consistent view of the path of the blockchain. The blocks record the messages that have been sorted, which are sent by the message routing layer to the execution layer for processing.</p>
<br>
<h2 id="comparison-of-consensus-mechanisms"><a class="header" href="#comparison-of-consensus-mechanisms">Comparison of Consensus Mechanisms</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">Classic public chain</th><th style="text-align: center">Consortium Blockchain</th><th style="text-align: center">Internet Computer</th></tr></thead><tbody>
<tr><td style="text-align: center">Write order</td><td style="text-align: center">Write first, then consensus</td><td style="text-align: center">Consensus first, then write</td><td style="text-align: center">Write first, then consensus</td></tr>
<tr><td style="text-align: center">Typical algorithm</td><td style="text-align: center">PoW, PoS, DPos</td><td style="text-align: center">PBFT, BFT</td><td style="text-align: center">PoUW</td></tr>
<tr><td style="text-align: center">Consensus process</td><td style="text-align: center">Finalized when consistent (high probability)</td><td style="text-align: center">consistent confirmation before P2P broadcast</td><td style="text-align: center">Select block nodes through random numbers</td></tr>
<tr><td style="text-align: center">Complexity</td><td style="text-align: center">High computational complexity</td><td style="text-align: center">High network complexity</td><td style="text-align: center">High network complexity</td></tr>
<tr><td style="text-align: center">forked?</td><td style="text-align: center">Yes</td><td style="text-align: center">No</td><td style="text-align: center">No</td></tr>
<tr><td style="text-align: center">Security threshold</td><td style="text-align: center">One half</td><td style="text-align: center">One third</td><td style="text-align: center">One third</td></tr>
<tr><td style="text-align: center">Number of nodes</td><td style="text-align: center">The number of nodes can change at any time</td><td style="text-align: center">The number of nodes cannot be changed arbitrarily, and the more the number, the lower the performance.</td><td style="text-align: center">The number of nodes cannot be changed arbitrarily, and the large number has little effect on performance.</td></tr>
<tr><td style="text-align: center">Application scenarios</td><td style="text-align: center">Non-licensed chain</td><td style="text-align: center">Permissioned blockchain</td><td style="text-align: center">Semi-permissioned, decided whether nodes join by DAO voting</td></tr>
</tbody></table>
</div>
<h2 id="comparison-of-several-consensus-algorithms"><a class="header" href="#comparison-of-several-consensus-algorithms">Comparison of Several Consensus Algorithms</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Consensus algorithm</th><th style="text-align: center">PoW</th><th style="text-align: center">PoS</th><th style="text-align: center">DPoS</th><th style="text-align: center">PBFT</th><th style="text-align: center">VRF</th><th style="text-align: center">PoUW</th></tr></thead><tbody>
<tr><td style="text-align: center">Node management</td><td style="text-align: center">No license</td><td style="text-align: center">No license</td><td style="text-align: center">No license</td><td style="text-align: center">Licensed</td><td style="text-align: center">Licensed</td><td style="text-align: center">DAO voting license</td></tr>
<tr><td style="text-align: center">Consensus latency</td><td style="text-align: center">High</td><td style="text-align: center">Low</td><td style="text-align: center">Low</td><td style="text-align: center">Low</td><td style="text-align: center">Low</td><td style="text-align: center">Ultra low</td></tr>
<tr><td style="text-align: center">Throughput</td><td style="text-align: center">Low</td><td style="text-align: center">High</td><td style="text-align: center">High</td><td style="text-align: center">High</td><td style="text-align: center">High</td><td style="text-align: center">High</td></tr>
<tr><td style="text-align: center">Energy saving</td><td style="text-align: center">No</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td><td style="text-align: center">Yes</td></tr>
<tr><td style="text-align: center">Safety boundary</td><td style="text-align: center">1/2</td><td style="text-align: center">1/2</td><td style="text-align: center">1/2</td><td style="text-align: center">1/3</td><td style="text-align: center">1/3</td><td style="text-align: center">1/3</td></tr>
<tr><td style="text-align: center">Representative application</td><td style="text-align: center">Bitcoin</td><td style="text-align: center">Ethereum</td><td style="text-align: center">BitShare</td><td style="text-align: center">Fabric</td><td style="text-align: center">Algorand</td><td style="text-align: center">Internet Computer</td></tr>
<tr><td style="text-align: center">Scalability</td><td style="text-align: center">Good</td><td style="text-align: center">Good</td><td style="text-align: center">Good</td><td style="text-align: center">Poor</td><td style="text-align: center">Poor</td><td style="text-align: center">Unlimited</td></tr>
</tbody></table>
</div><br>
<p>After passing through the consensus layer, the message will trigger <a href="2.CoreProtocol/Messageroutinglayer.html">the message routing layer</a>, which is responsible for placing the message into the input queue of the Canister.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-routing-layer"><a class="header" href="#message-routing-layer">Message Routing Layer</a></h1>
<h2 id="message-relay-station-in-the-replica"><a class="header" href="#message-relay-station-in-the-replica">Message Relay Station in the Replica</a></h2>
<p>The message routing layer, as its name suggests, is responsible for message transimission within a replica. It acts as an intermediary, interfacing between upper and lower layers.</p>
<h3 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h3>
<p>The consensus layer packages messages into block <strong>payloads</strong>. Once a block is finalized, each replica in the subnet parses the payloads in the block. The message routing layer then passes the messages to the corresponding canisters in the execution layer. After executing the messages, the canisters update their internal state and return message responses to the message routing layer.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230709152648678.png" style="zoom: 80%;" />
</div>
<p>The messages received by the message routing layer are of two types:</p>
<p>One type is messages from users, called <strong>ingress messages</strong>. The other type is messages from canisters in other subnets, called <strong>cross-subnet messages</strong>.</p>
<p>The messages <strong>sent</strong> by the message routing layer are also of two types:</p>
<p>One is responses to user messages, called <strong>ingress message responses</strong>. The other type is still <strong>cross-subnet messages</strong>, which are messages sent by canisters in its own subnet to canisters in other subnets.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230710010119385.png" style="zoom: 67%;" />
</div>
<h3 id="message-queues"><a class="header" href="#message-queues">Message Queues</a></h3>
<p>Each canister in the execution layer has an input queue and an output queue. The message routing layer routes the payloads in the blocks to the input queues of the target canisters.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/IMG21.png" style="zoom: 67%;" />
</div>
<p>Each canister has its own <strong>input queues</strong> and <strong>output queues</strong>.</p>
<ul>
<li><strong>Input queues</strong>:</li>
</ul>
<p>The input queues contain: messages from users, inter-subnet messages from canisters in other subnets, and messages from other canisters in the subnet.</p>
<p>Each round, the canister executes some messages from the input queues and puts the message responses into the canister's <strong>output queue</strong>.</p>
<ul>
<li><strong>Output queues</strong>:</li>
</ul>
<p>The output queues contain: responses to user messages, messages sent to canisters in other subnets, and messages sent to other canisters within the subnet.</p>
<p>When the message routing layer takes messages from the message queues and puts them into the <strong>subnet-to-subnet streams</strong>, the <strong>crossnet transfer protocol</strong> is responsible for actually transferring these messages to other subnets.</p>
<p>In addition to the output queues, there is an <strong>ingress history</strong> data structure. It records in a hash tree called the &quot;<strong>Per-round certified state</strong>&quot;. The ingress history only records the responses after the canister executes the messages so that users can get responses to their messages.</p>
<blockquote>
<p>Note: The ingress history does not retain a complete history of all ingress messages. It only retains the responses after update calls.</p>
<p>The responses of query calls are not recorded in the ingress history (the ingress history only records the responses of update calls), so they cannot be verified by each round of authentication status. But IC provides another verification mechanism, called certified variables. We can store some important information using certified variables.</p>
<p>If the content of a query call is a certified variable, then the query call is secure and verifiable. Because the certified variables of the Canister are also recorded in each round of authentication status after hashing. And each round of authentication status is consensus-based, meaning that this information is the same in all replicas in the subnet.</p>
</blockquote>
<p>Looking at the message routing and execution layers separately, it looks like this:</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230712194634346.png" style="zoom:67%;" />
</div>
<h2 id="intra-subnet-messages"><a class="header" href="#intra-subnet-messages">Intra-subnet Messages</a></h2>
<p>When a Canister sends information to Canisters in other subnets, this information is placed in the cross-subnet queue and verified by the subnet at the end of this round. The receiving subnet can confirm that the information is authorized by the sender by verifying the signature. These messages require consensus. IC implements cross-subnet communication using the Xnet protocol, which will be introduced in detail later.</p>
<h3 id="intra-subnet-cross-canister-call"><a class="header" href="#intra-subnet-cross-canister-call">Intra-subnet Cross-canister Call</a></h3>
<p>In addition to cross-subnet messages, there are also messages from one canister calling another canister in the same subnet, called <strong>intra-subnet messages</strong>. The message routing layer forwards these messages directly from the output queue to the input queue of the corresponding canister without an extra round of consensus.</p>
<p>So why do messages from canisters to other subnets require consensus, but messages from canisters to the same subnet do not need consensus?</p>
<p>Because these state-changing operations are within the subnet. </p>
<p>Think about it, the data states in the replicas are the same, and consensus is also to ensure the consistency of the data in the replicas. After the replicas reach consensus, each honest replica will execute intra-subnet cross-canister calls, and everyone will execute cross-canister calls together. This is still a consistent operation.</p>
<p>Consensus is used when everyone faces different choices to make everyone execute the same operation.</p>
<p><img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230710142242883.png" alt="image-20230710142242883" /></p>
<p>So when a canister in a subnet calls another canister within the same subnet, each replica will make the same cross-canister call. Each replica stores all the data in the subnet. When the replicas execute cross-canister calls, the consistency of data in the subnet is still maintained.</p>
<p><img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230710151201556.png" alt="image-20230710151201556" /></p>
<p><strong>Guarantees provided by the message routing layer</strong></p>
<ol>
<li>Cross-subnet messages must be delivered to the execution layer of the target Canister subnet at one time.</li>
<li>If a message cannot be delivered, a rejection response must be generated.</li>
<li>If a Canister A sends two messages m1 and m2 to Canister B, and if they are not rejected, it must be guaranteed that they are placed in Canister B's input queue in order.</li>
</ol>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>At this point, let's summarize. The state of a replica (subnet) includes the state of Canisters and &quot;system state&quot;. The &quot;system state&quot; includes the input and output queues of Canisters, cross-subnet data streams, and the ingress history data structure.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/IMG25.png" style="zoom: 80%;" />
</div>
<p>In other words, the message routing layer and the execution layer together maintain the state of a replica. And the state of the replica is updated under fully deterministic conditions, so that all replicas in the subnet maintain exactly the same state. The consensus layer does not need to keep exactly the same progress as the message routing layer.</p>
<h2 id="per-round-certified-state"><a class="header" href="#per-round-certified-state">Per-round Certified State</a></h2>
<p>In each round, the state of each replica in the subnet will change.</p>
<p>Of course, the part that changes in each round also needs to be recorded separately. Because IC's consensus only guarantees that honest replicas process messages in the same order. Consensus only guards before messages enter the execution layer, but the exit after message processing lacks a &quot;guard&quot;: What if the message response is not sent successfully due to network issues? How does the client verify the authenticity of the message after receiving the message? If the message response is forged by hackers, it will be troublesome. In case the server system has strange bugs that prevent messages from being executed...</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/IMG26.png" style="zoom: 80%;" />
</div>
<p>Replicas need to verify the state again after processing messages. The <strong>per-round certified state</strong>, also known as the system state tree, serves as the last guard in a complete round. The per-round certified state can record the state changes of replicas in one round, and re-broadcast a threshold signature to everyone for confirmation by two-thirds of the replicas.</p>
<p>Both input and output must be certified by consensus, otherwise there is a risk of divergence.</p>
<p>Therefore, in order to ensure that each replica processes the message correctly, after the Canister executes the message, the executed message must be recorded to allow the replicas to verify each other again.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230710144332663.png" style="zoom:67%;" />
</div>
<p>After executing messages in each round, each replica hashes its own per-round certified state, packs it into a Merkle tree, and signs it with a private key fragment. Collect two-thirds of the signature fragments to aggregate into a complete signature. The state tree and the certified signature are called the per-round certified state.</p>
<p>Because the execution layer processes messages in the same way, theoretically each replica in the subnet will independently create the same tree.</p>
<p>The per-round state tree only contains some data information that has changed after each round of execution. The overall state of the replica is not in the per-round certified state.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230706141701491.png" style="zoom:50%;" />
</div>
<p>Each round of certification states contains the following in this round:</p>
<ul>
<li>Various metadata about each Canister (such as the hash of Wasm, etc., not the complete status of the Canister)</li>
<li>The root node hash of the Merkle tree of the certification status of the previous round</li>
<li>Intra-subnet messages added to the data flow between subnets</li>
<li>Ingress history, various responses to messages</li>
<li>The ID and public key of each subnet</li>
<li>Current time</li>
<li>Metadata</li>
</ul>
<p>The consensus layer and execution layer of IC are separated and are two independent parts. The consensus layer and execution layer can also adjust their own rhythms and speeds. If the consensus is too fast and the execution layer accumulates too many messages to keep up with the consensus, message routing needs to notify the consensus layer to slow down. (It may be due to some bugs in the execution layer, etc.) <strong>Here</strong> we see how the consensus slows down.</p>
<p>How do you know if the execution layer is slow? Through the certification status of each round. Each replica will observe the round of threshold signature certification and the round of consensus reaching in each round. If the difference is too large, the speed must be reduced.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/z.gif" alt="z" style="zoom: 80%;" />
</div>
<p>Just like the assembly line in a traditional factory, if one part slows down, the entire production line has to slow down. Otherwise, the backlog of messages to be processed will accumulate more and more.</p>
<h2 id="xnet-protocol"><a class="header" href="#xnet-protocol">XNet Protocol</a></h2>
<p>IC implements communication between subnets through the XNet protocol. In order to reduce the latency of message transmission, replicas tend to choose replicas closer to themselves for communication.</p>
<p>Simply put, cross-subnet messages are transmitted as follows:</p>
<p>After the Canister in the execution layer processes the message, it puts the cross-subnet message into the output queue. The message routing layer has a component called the <strong>Stream builder</strong>, which is responsible for forming cross-subnet messages into data streams. After <strong>Per-round state</strong> threshold signature certification, the XNet endpoint of the replica executes and sends. The <strong>XNet endpoint</strong> sends messages to the nearest replica of subnet B. After the replica XNet payload builder of subnet B receives the message, it broadcasts the payload. Then pack it out and reach consensus.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230710010807353.png" style="zoom:43%;" />
</div>
<p><strong>The Stream builder</strong> extracts messages from the Canister's output queue and queues the messages. It needs to meet determinism, orderliness and fairness:</p>
<ol>
<li>Determinism: All replicas must reach consensus on the content of the stream. (Replicas perform threshold signature certification for each round of state certification)</li>
<li>Orderliness: If Canister A sends a request R1 to Canister B first, then sends a request R2, then R1 is ahead of R2 in the data stream.</li>
<li>Fairness: We do not want a Canister to occupy too much bandwidth. The Stream builder will try to give each Canister the same bandwidth.</li>
</ol>
<p>The Stream builder sorts these messages according to the target subnet and forms message streams (one message stream per target subnet). Each message in the message stream has a unique increasing index.</p>
<p>After that,  **per-round certified state ** will certify the submitted state. After the certification is completed, the certified data stream can be sent to other subnets.</p>
<p>The <strong>XNet endpoint</strong> is responsible for sending certified messages to other subnets. The XNet endpoint is a component that provides messages to other subnets. It provides services through secure TLS connections and only accepts connections from other replicas. The XNet endpoint obtains a complete list of nodes, subnet allocation, IP addresses and public keys (for establishing TLS connections) from the registry.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230709153806949.png" style="zoom:37%;" />
</div>
<p>If a replica of subnet B wants to get new messages from subnet A, it will choose the nearest replica of subnet A and send a request to this replica through the XNet protocol. XNet transmits information through the HTTPS protocol.</p>
<p><strong>The XNet payload builder</strong> is responsible for receiving cross-subnet messages. As the name suggests, after receiving these messages, it will package them as payloads into blocks, reach consensus, execute ...</p>
<p>In addition to cross-subnet messages, user ingress messages and Bitcoin transactions (for subnets enabling Bitcoin integration) will also be packaged as payloads into blocks.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230710010416109.png" style="zoom: 25%;" />
</div>
<p>After combining and packaging these payloads into a block, the consensus protocol will verify the entire block and reach consensus. After the consensus is reached, the messages in the payload will be processed.</p>
<p>This is the process of transmitting messages from one subnet to another subnet. As shown in the figure below.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/Messageroutinglayer/image-20230710135919388.png" style="zoom:67%;" />
</div>
<p>Garbage collection: After sending the messages, subnet A still needs to tell subnet B which messages have been processed so that subnet A can clear those messages that are no longer needed.</p>
<p>These components ensure that cross-subnet messages can be delivered correctly and implement secure and scalable blockchain communication.</p>
<br>
<p>After understanding the communication aspect, let's now take a look at <a href="2.CoreProtocol/executionLayer.html">the execution layer</a>, which is the top layer of the core protocol.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-layer"><a class="header" href="#execution-layer">Execution Layer</a></h1>
<p>The execution layer is responsible for executing smart contracts. On IC, a smart contract is a virtualized container: Canister.</p>
<h2 id="introduction-2"><a class="header" href="#introduction-2">Introduction</a></h2>
<p>IC works in rounds, with each round triggered by the consensus layer reaching agreement on a set of message blocks.</p>
<p>At the beginning of each round, messages are assigned to the input queues of contracts according to their destinations. Subnet messages are assigned to the subnet input queue. The scheduler will sort these messages for execution. Each time the subnet state is processed in a round, the execution will end when the limit is reached.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/executionlayer/image-20230709151844674.png" style="zoom:80%;" />
</div>
<p>The scheduler can fairly allocate workloads between Canisters and give priority to Canisters that need to optimize throughput. When a Canister is scheduled to execute, it will be assigned an available CPU core and execute the messages in the input queue one by one until all messages are processed. Then, the scheduler selects the next Canister for execution until the instruction round limit is reached or there are no Canisters left to schedule.</p>
<p>The execution environment monitors resource usage and deducts corresponding Gas fees from the Canister's balance.</p>
<p>For security and reliability, each Canister executes in an isolated sandbox environment. When executing each individual message, the scheduler starts the sandbox process hosting the Canister and executes the provided message. Executing each message may send new messages to other Canisters, modify the Canister's memory pages, or generate a response. The execution environment charges according to the number of instructions consumed by the Canister.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/executionlayer/image-20230706150853074.png" style="zoom: 50%;" />
</div>
<p>As shown in the figure above, for more details about Canisters, please refer to <strong>Chapter 4</strong>.</p>
<p>To manage the execution time of Canisters, the IC limits the number of instructions executed by each Canister. Each Canister has a fixed number of instructions in each round. At the end of a round of execution, the Canister's execution will pause and continue in the next round. To prevent Canisters from occupying too many resources, the maximum number of instructions that can be executed in a single call of each Canister is limited. If the limit is exceeded, the execution will be terminated, the state of the Canister will be rolled back, and the consumed Cycles will be deducted.</p>
<p>The execution environment also limits the number of heap pages that a Canister can modify in each round. However, after a Canister exceeds the limit, the execution result will still be saved, just no subsequent operations will be performed. Only when the number of heap memory pages a Canister plans to modify is less than the limit will subsequent operations be performed.</p>
<h2 id="scheduler"><a class="header" href="#scheduler">Scheduler</a></h2>
<p>The scheduler is like a brain that is responsible for arranging the execution order of Canisters running on the execution layer. The scheduler needs to do the following:</p>
<ol>
<li>It must be deterministic, that is, under the same conditions, its decisions must be the same every time.</li>
<li>It needs to fairly allocate workloads between Canisters.</li>
<li>It should prioritize overall processing speed rather than the execution speed of a single task.</li>
</ol>
<p>To allow Canisters to respond quickly even when the system is busy, they can choose to prepay a certain amount of computing resources. Each Canister has its own allocation of computing resources, which is like a small part of a CPU core. Only part of the subnet's computing power can be allocated so that Canisters that have not pre-allocated computing resources can also be executed.</p>
<p>Fairness means ensuring that each Canister can obtain its allocation of computing resources and distribute the remaining computing resources evenly. The scheduler will select several Canisters to execute a complete round. In one round, Canisters will either complete executing all their tasks or reach the instruction limit.</p>
<p>The scheduler will use the cumulative points accumulated by each Canister over multiple rounds as priorities. At the beginning of each round, each Canister will receive a certain number of points, including their allocation of computing resources and the average share of the remaining computing resources. The scheduler will allocate Canisters to CPU cores for execution in a polling manner and deduct 100 points from Canisters that have executed a full round.</p>
<p><strong>Here is an example:</strong></p>
<p>Assume there are three Canisters: A, B and C. Each replica has 2 CPU cores. Each Canister has an input queue for receiving messages to be processed. The scheduler handles the execution of these Canisters.</p>
<ol>
<li>
<p>At the beginning of the round, the input queues of Canister A, B and C have 5, 3 and 10 messages respectively. The scheduler will evaluate these messages and sort them for execution.</p>
</li>
<li>
<p>Assume the scheduler first chooses Canister A for processing. It will allocate an idle CPU core to Canister A and execute the messages in Canister A's input queue one by one. After all messages (5) of Canister A have been processed, the scheduler will mark Canister A as completed.</p>
</li>
<li>
<p>Without waiting for Canister A to complete, the scheduler can allocate a core to Canister B after allocating a core to A. It allocates another core to Canister B and executes the messages in Canister B's input queue one by one. After all messages (3) of Canister B have been processed, the scheduler marks Canister B as completed. Then it allocates the CPU core to Canister C.</p>
</li>
</ol>
<div class="center-image">
    <img src="2.CoreProtocol/assets/executionlayer/image-20230706151318234.png" style="zoom:37%;" />
</div>
<ol start="4">
<li>Finally, according to its own rules, the scheduler selects Canister C for processing. It will allocate an idle CPU core to Canister C and start executing the messages in Canister C's input queue one by one. At this point, after processing 6 messages, Canister C reaches the instruction limit for this round. The scheduler will mark Canister C as incomplete, suspend execution, and continue in the next round.</li>
</ol>
<div class="center-image">
    <img src="2.CoreProtocol/assets/executionlayer/image-20230706161320136.png" style="zoom:37%;" />
</div>
<ol start="5">
<li>At the beginning of the next round, the scheduler will evaluate the input queues of all Canisters, including the unprocessed messages of Canister C. Then, according to priorities, accumulated shortages and other factors, it will schedule to ensure fair and efficient allocation of tasks.</li>
</ol>
<p>Canisters are single-threaded, and multiple Canisters can run in parallel on multiple cores. If there are 300 CPU cores, the scheduler will try to run different Canisters on these cores as much as possible. On each CPU core, Canisters will be executed one by one until the limit is reached.</p>
<p>Each Canister has an independent state, and communication between Canisters is asynchronous. This gives IC scalability similar to traditional cloud services. By increasing the number of subnets, IC can achieve horizontal scaling.</p>
<h2 id="cycles-cost"><a class="header" href="#cycles-cost">Cycles Cost</a></h2>
<p>When performing tasks, Canisters consume resources such as CPU, network bandwidth, and memory usage. These resource consumptions are measured by &quot;Cycles&quot;.</p>
<p>Technically, the Wasm bytecode running in smart contracts is checked when installing or updating Wasm bytecode to the IC to count the number of instructions required to execute smart contract messages. This can calculate the amount of Cycles required to execute the message. Using Wasm as the bytecode format for smart contracts helps achieve determinism to a large extent because Wasm itself is essentially deterministic during execution. Most importantly, Cycles billing must be completely deterministic, so that the number of Cycles billed by each replica for a given operation is exactly the same and maintains the replica state machine properties of the subnet.</p>
<p>The memory used by smart contracts, whether Wasm bytecode or smart contract state, needs to be paid for through Cycles. Network activities such as receiving ingress messages, sending XNet messages, and making HTTPS calls to Web 2.0 servers are also paid for by smart contracts through Cycles.</p>
<p>Compared with other blockchains, the cost of storing data on the IC is quite low (of course, cheaper than Arweave, Ar, which specializes in storage, and others).</p>
<p>Cycles are a price-stable token anchored to the <strong>SDR</strong>. 1 SDR = 1 Trillion Cycles = $10^{12}$ Cycles</p>
<h2 id="consumption-of-resources-of-canister"><a class="header" href="#consumption-of-resources-of-canister">Consumption of Resources of Canister</a></h2>
<p>Each Canister has a Cycles account, and Canisters can hold, send and receive Cycles. The billing standards are controlled by the NNS and can be adjusted through voting proposals. Consumption of Cycles includes the following:</p>
<ol>
<li>
<p><strong>Execution fee</strong>: When a Canister processes a request (calls a Canister function), a fee is charged according to the number of instructions executed.</p>
</li>
<li>
<p><strong>Call fee</strong>: Fees are generated when Canisters send messages to each other. The fee is proportional to the message size. When a Canister sends a message to another Canister, it has to pay for the bandwidth consumed. The cost of message transmission is proportional to the size of the message, and the size of messages on the IC is limited, so the fees are also limited.</p>
<p>When a Canister initiates a call to another Canister, the execution environment will deduct Cycles from the calling Canister's account to pay for the cost of the outgoing call message and the cost of the reply message that the callee will send. Since the size of the reply message is unknown, the maximum message size is deducted first, and excess Cycles are returned to the caller if the reply is short.</p>
</li>
<li>
<p><strong>Storage fee</strong>: Canisters pay a fee to store data (including Wasm bytecode and state). The system reaches consensus on the &quot;current&quot; time after each round of consensus and then charges according to the number of rounds. For more details, please refer to the <strong>source code</strong>.</p>
</li>
<li>
<p><strong>Creating a Canister</strong>: When deploying a Canister online for the first time, you need to top up some Cycles for the Canister. The default is 3T cycles, with a minimum top-up of 0.01T.</p>
</li>
</ol>
<h2 id="cycles-calculation"><a class="header" href="#cycles-calculation">Cycles Calculation</a></h2>
<p>IC adopts a &quot;reverse gas model&quot;. That is, the maintainer of the Canister needs to provide Gas fees (Cycles) to perform calculations, and users do not need to pay for sending messages.</p>
<p>During the execution of the Canister, IC's execution layer uses contract-level scheduling and batch message processing to optimize the system's throughput and latency. At the same time, to ensure security and reliability, Canisters run in isolated sandbox environments. The execution environment records the Canister's usage, such as CPU time, memory, disk space, and network bandwidth, and then deducts the corresponding fees from the Canister's Cycles balance.</p>
<div class="center-image">
    <img src="2.CoreProtocol/assets/executionlayer/1688483328530.jpg" style="zoom:70%;" />
</div>
<p>The more Cycles consumed in a subnet, the more ICP the corresponding data center of that subnet will receive. The amount of newly issued ICP is proportional to the amount of Cycles consumed. Therefore, if there are more replicas (more data centers) in a subnet, the Gas fee will be higher because the ICP ultimately has to be paid to the data centers. Similarly, (if) if no Canisters are deployed in a subnet, no Cycles are consumed, and the data center does not receive ICP (loss). However, Dapp developers cannot choose which subnet their Canisters are deployed in, this is randomly assigned, so each subnet will be fairly allocated Canisters.</p>
<p>If there are more Canisters in the subnet,</p>
<p>Since it is a reverse gas model, Canisters pay for their own Gas fees for running, how does the IC prevent malicious consumption of Cycles calling attacks?</p>
<ul>
<li>
<p>Before executing messages from users, the Canister can inspect the user's message, called the ingress message. When receiving a user's update call, the system will use the <strong>canister_inspect_message</strong> method to check if the message should be accepted. If the Canister is empty (no Wasm module), the ingress message will be rejected. If the Canister is not empty and is not intercepted by the <strong>canister_inspect_message</strong> method, the Canister will execute the ingress message.</p>
<p>In the <strong>canister_inspect_message</strong> method, the Canister can call <strong>ic0.accept_message: () -&gt; ()</strong> to accept the message. If the Canister has called the message acceptance function <strong>ic0.accept_message</strong> too many times, the <strong>canister_inspect_message</strong> method will reject it. Or if the Canister does not call the <strong>ic0.accept_message</strong> method, it is equivalent to rejecting it. If the Canister rejects the message, no fees will be charged.</p>
<p>In addition, query calls, cross-Canister calls, and Canister management calls do not check the <strong>canister_inspect_message</strong> method.</p>
</li>
<li>
<p>When a Canister sends a message to another Canister, it is called a cross-Canister message. The sending Canister must pay for the transmission of the request and the final response. See <a href="https://github.com/dfinity/ic/blob/master/rs/config/src/subnet_config.rs#L120">here</a> for operating fees.</p>
</li>
</ul>
<h2 id="freeze-threshold"><a class="header" href="#freeze-threshold">Freeze Threshold</a></h2>
<p>To prevent Canisters from suddenly depleting cycles and losing data, there is a freeze threshold in the system. If the Cycles are insufficient to maintain the Canister's storage fees for the next 30 days, the Canister will be frozen.</p>
<p>After being frozen, the Canister will no longer receive and send messages, stop computing, and directly reject all requests. At this time, the Canister only consumes Cycles for storing data. After the Canister is frozen, topping up some Cycles to make the balance higher than the threshold can unfreeze it. If no Cycles are topped up within 30 days after being frozen, the Canister will be deleted from the subnet when the Cycles run out.</p>
<p>In addition, if deducting Cycles for a certain operation will drop below the freeze threshold, the Canister will not be able to perform that operation.</p>
<br>
<p>Now that we have covered all four layers of the core protocol in IC, in the next chapter, let's take a look at IC's flagship capability: <a href="2.CoreProtocol/">Chain Key Cryptography</a>.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-3"><a class="header" href="#introduction-3">Introduction</a></h1>
<ul>
<li><a href="2.CoreProtocol/Relatedconcepts/HowToPickNumberInConsensus.html">How to pick the number in the consensus council?</a></li>
<li><a href="2.CoreProtocol/Relatedconcepts/P2PLayerAndMaliciousAttack.html">How does P2P layer reduce malicious attack?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-pick-the-number-of-consensus-committee-"><a class="header" href="#how-to-pick-the-number-of-consensus-committee-">How to pick the number of consensus committee ?</a></h1>
<p>First and foremost, we have a large group of individuals (let's call it U), consisting of both honest and dishonest people.</p>
<p>Now, we want to randomly select a small subset of individuals from this group (referred to as G) and calculate the probability of honest people within this subgroup. Ideally, we would like everyone selected to be honest. However, it is clear that we cannot guarantee that all chosen individuals will be honest, so let's strive to maximize the probability of selecting honest people!</p>
<br>
<p>So, how do we calculate this probability?</p>
<p>We employ the <strong>hypergeometric cumulative distribution function</strong> (CDFhg) and the <strong>binomial cumulative distribution function</strong> (CDFbinom) formulas to determine the smallest subgroup size that ensures the probability of honest individuals exceeds an acceptable threshold.</p>
<p>We use a mathematical formula called the <strong>hypergeometric cumulative distribution function</strong> (CDFhg). Put simply, this formula helps us calculate the probability of honest individuals based on the total number of people in group U, the number of honest people, and the size of the subgroup G we wish to draw.</p>
<p>However, we want to establish a minimal subgroup size (denoted as n) such that the probability of honest individuals surpasses an acceptable threshold (1 - œÅ). This way, we can employ this subgroup size in practical applications.</p>
<p>If our group U becomes exceedingly large, we utilize another formula called the <strong>binomial cumulative distribution function</strong> (CDFbinom), which is based on the binomial distribution. This formula is similar to the previous one but is applicable to larger group U sizes.</p>
<p>Lastly, by comparing various thresholds (œÅ) and the proportion of dishonest individuals (Œ≤), we identify the smallest subgroup sizes suitable for different scenarios. These sizes can be applied to practical protocols, ensuring that the probability of honest individuals in our drawn subgroup G is sufficiently high.</p>
<p>Now let's talk about CDFhg and CDFbinom.</p>
<h2 id="hypergeometric-cumulative-distribution-function-cdfhg"><a class="header" href="#hypergeometric-cumulative-distribution-function-cdfhg">Hypergeometric cumulative distribution function (CDFhg)</a></h2>
<p>In this formula, we use \(CDFhg(x, n, M, N)\) to represent the cumulative distribution function of the hypergeometric distribution.</p>
<p>Here:</p>
<ul>
<li>N: Total number of people in group U</li>
<li>M: Number of honest people in group U</li>
<li>n: Size of small group G formed by randomly selecting</li>
<li>x:  The maximum number allowed of honest people in the small group G</li>
</ul>
<p>Then, we can calculate the probability of honest people in the randomly selected small group G by the following formula:</p>
<p>$$ Prob[G honest] = CDFhg(‚åàn/2‚åâ ‚àí 1, n, ‚åä|U|/Œ≤‚åã, |U|) $$</p>
<p>This formula tells that: given the number of honest and dishonest people in a group U, we can calculate the probability of getting honest people when drawing a specific sized small group G.</p>
<h2 id="binomial-cumulative-distribution-function-cdfbinom"><a class="header" href="#binomial-cumulative-distribution-function-cdfbinom">Binomial cumulative distribution function (CDFbinom)</a></h2>
<p>When the size of group U approaches infinity, we can use the binomial distribution to approximate the hypergeometric distribution. The cumulative binomial distribution function is expressed as \(CDFbinom(x, n, p)\).</p>
<p>Here:</p>
<ul>
<li>p: The success (honest people) probability for each draw</li>
<li>n: Size of small group G formed by randomly selecting</li>
<li>x: The maximum number allowed of honest people in the small group G</li>
</ul>
<p>We can calculate the probability of honest people in the randomly selected small group G by the following formula:</p>
<p>$$ Prob[G honest] ‚â• CDFbinom(‚åàn/2‚åâ ‚àí 1, n, 1/Œ≤) $$</p>
<p>This formula tells that in a very large group , what are the probabilities of getting honest people when drawing a specific sized small group G.</p>
<br>
<p>Both of these mathematical formulas are used to calculate the probability of honest individuals in a randomly sampled subgroup G. The CDFhg is applicable to group U with a finite size, while the CDFbinom is suitable for infinitely large group U sizes. These formulas aid us in identifying appropriate subgroup sizes to ensure the probability of honest individuals surpasses an acceptable threshold.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-does-the-p2p-layer-reduce-malicious-attacks"><a class="header" href="#how-does-the-p2p-layer-reduce-malicious-attacks">How does the P2P layer reduce malicious attacks?</a></h1>
<p>The P2P layer uses several methods to mitigate the effects of malicious behavior and ensure that replicas in a subnet can communicate efficiently and securely. Here are some key points on how the P2P layer handles potential malicious behavior:</p>
<p><strong>Use encrypted hashes to ensure integrity</strong>: When a replica receives a notification of an artefact, the notification contains an encrypted hash of the artefact. After downloading the artefact, the replica will apply the same encrypted hash function to the downloaded content. Only if the generated hash matches the hash in the notification is the artefact considered valid and continues processing. This prevents malicious replicas from sending tampered artefact content.</p>
<p><strong>Client verification</strong>: Even if a malicious replica sends an artefact with a matching hash, client components (such as consensus layer components) need to verify the artefact before processing or forwarding it to other replicas. This includes verifying signatures or checking that the artefact conforms to expected formats and rules.</p>
<p><strong>Selective download of artefacts</strong>: The P2P layer does not download artefacts immediately upon receiving a notification. Instead, replicas decide whether to download an artefact based on the notification content and their own state. This reduces the impact of malicious replicas flooding the network with unnecessary or malicious artefacts.</p>
<p><strong>Redundancy and fault tolerance</strong>: When downloading large artefacts that can be divided into multiple data blocks, the P2P layer will try to download data blocks from multiple replicas that have published the artefact. This improves download speed and bandwidth utilization. At the same time, it provides fault tolerance in the event of malicious behavior or failure of a replica.</p>
<p><strong>Verified connections</strong>: The underlying transport component of the P2P layer establishes secure TLS and TCP-based connections between replicas in a subnet. Replicas use private keys to authenticate each other to ensure that only replicas in the same subnet can communicate. This reduces the risk of unauthorized replicas injecting malicious traffic into the subnet.</p>
<p><strong>Monitoring and resending requests</strong>: The P2P layer continuously monitors connection quality and received artefacts. If a replica encounters an artefact issue, such as lost or invalid data, it can request the peer replica to resend the artefact. This mechanism helps recover from issues that malicious replicas may cause.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="chain-key-cryptography"><a class="header" href="#chain-key-cryptography">Chain-key cryptography</a></h2>
<img src="3.ChainKey/assets/Chainkey/chainkey.jpg" alt="chainkey" style="zoom:50%;" />
<p>Chain-key cryptography refers to the suite of cryptogenic protocols embedded in Internet Computer lower-level systems. It is the complete set of cryptographic protocols that Internet Computers rely on for runtime operations, including threshold BLS signatures, non-interactive key distribution (NIDKG), non-interactive zero-knowledge proofs (NIZK), Threshold ECDSA signatures, verifiable encrypted threshold keys (VETKeys) and so on.</p>
<p>The most important among these is threshold BLS signatures.</p>
<h2 id="threshold-bls-signatures"><a class="header" href="#threshold-bls-signatures">Threshold BLS signatures</a></h2>
<p>What is threshold BLS signatures? <code>‡∏Ö ï‚Ä¢Õ°Ã´ ‚Ä¢ î‡∏Ö</code> </p>
<p>It is the most important, fundamental, and core component of cryptographic key chains. Subnet operations rely on threshold BLS signatures to achieve consensus, provide message authentication to users, generate random beacons on which consensus depends, and sign catch-up packages, among other tasks. </p>
<p>To give an example, a threshold BLS signature is like a &quot;DAO&quot; - any place the subnet needs to sign something requires enough replicas in the subnet to &quot;agree&quot; (sign) before it can go through. When enough replicas agree, that represents consensus and the majority rules.</p>
<blockquote>
<p>In traditional asymmetric cryptography, we can generate a public and private key pair; the public key is shared openly while the private key is kept secret. The public key encrypts information, the private key decrypts it. The private key signs information, the public key verifies it. You can learn more about asymmetric cryptography here.</p>
</blockquote>
<p>As I explained with <a href="3.ChainKey/../2.CoreProtocol/IntroductiontoConsensusLayer.html">consensus</a> earlier, when a replica in a subnet creates a block proposal, if everyone agrees the block looks good, they will each sign it with their private key to indicate their approval.</p>
<p>If every replica generated their own key pair, managing the keys would be complex and inefficient ü•≤. Even more importantly, if users wanted to verify chain contents, they'd have to download hundreds of GBs to check everything themselves üò≠. That's just unfriendly.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20231008154331015.png" alt="image-20231008154331015" style="zoom:42%;" />
</div>
<p>To solve this, Dfinity chose a threshold BLS signature scheme to enable subnet signatures.</p>
<h3 id="bls-signatures"><a class="header" href="#bls-signatures">BLS signatures</a></h3>
<p>Let me explain why BLS signatures were chosen.</p>
<p>One reason for using BLS signatures is that the final signature produced by the subnet is unique - for a given public key and message, there is only one valid signature. This unique signature property allows smart contracts to generate unpredictable random numbers: after a smart contract requests a random number, (through one round of consensus) the subnet will generate a signature on a special message, then hash that signature to derive a random number seed, and finally generate the required (pseudo) random number from the seed. </p>
<p>Due to the security properties of BLS signatures, no one can predict or tamper with this randomness.</p>
<p>BLS signatures are quite different from common signature algorithms like RSA and DSA in many ways. </p>
<p>First, BLS signatures are much shorter and more secure. </p>
<p>A signature value only needs one coordinate of an elliptic curve point, around 160 bits is enough. But RSA and DSA signature contain two large integers, usually 320 bits are needed to achieve an equivalent security level, so BLS signatures have a clear advantage in length. The security of BLS signatures does not rely on integer factorization or other mathematical problems, but rather on computationally hard problems on elliptic curves, like the CDH problem. These kinds of problems seem even harder to break today.</p>
<p>Although BLS signatures verification is slower due to requiring some pairing computations, signature generation is very fast, requiring only a simple point multiplication. RSA and DSA are the opposite - signing is slow but verification is fast.</p>
<p>Another advantage of BLS signatures is they don't require maintaining signature state, the signature is fixed as long as the message content doesn't change. </p>
<br>
<p>However, RSA and DSA signatures still need to save random numbers to prevent replay attacks. In RSA signatures, a scheme called &quot;Probabilistic Signature Scheme&quot; (PSS) is commonly used, which utilizes random numbers (salt) during signature generation to enhance security. Therefore, for the same message and private key, the resulting signature may vary slightly due to the introduced randomness. This variation is achieved by introducing random salt values into the signature, to increase security and prevent attackers from gaining information about the private key by observing multiple signatures of the same message.</p>
<br>
<p>Additionally, BLS signatures can be efficiently batch verified together, greatly improving efficiency in many use cases. This is not possible with RSA and DSA.</p>
<p>These properties make BLS signatures very suitable for many blockchain applications with high requirements on signature size and scalability. </p>
<p>The algorithm itself is very elegant and a promising signature algorithm. You can learn more about the cryptographic principles of BLS signatures here.</p>
<p>Most importantly, BLS signatures can split the private key into share fragments and be upgraded to multi-signature or <strong>threshold signature</strong> schemes! Doing this directly with RSA and DSA would be very difficult. </p>
<br>
<h3 id="threshold-bls-signatures-1"><a class="header" href="#threshold-bls-signatures-1">Threshold BLS signatures</a></h3>
<p>Splitting the private key into share fragments! </p>
<p>It sounds very sophisticated, but it's actually just an algorithm that allows multiple parties to participate in signing. The private key is split into many shares and given to different people to keep. When signing, enough people (meeting the threshold) have to collaborate to combine the signature fragments into a valid signature. </p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20231008154650846.png" alt="image-20231008154650846" style="zoom:39%;" />
</div>
<p>In movies, books, and games, there are often quests that require collecting multiple keys, crystals, or other artifacts to unlock the gateway to the final level or obtain the ultimate treasure. Like in Avengers: Infinity War, Thanos had to assemble the six Infinity Stones to wipe out half of all life in the universe. In the Harry Potter series, Voldemort split his soul to create multiple horcruxes, and Harry had to find and destroy them all to fully defeat Voldemort. In Dragon Ball, gathering the seven Dragon Balls allows you to summon the dragon and make a wish.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230818135016018.jpg" alt="img" style="zoom:40%;" />
</div>
<p>Plots involving collecting or combining items to produce some magical effect are common tropes across various media.</p>
<p>In reality, threshold BLS signatures implement this kind of magic through cryptography. Each person generates a signature fragment using their private key share, and when enough fragments meet the threshold, they can be combined into a complete signature. Even if some replicas (less than one third) in the subnet fail or lose network connectivity, signing can still complete. Yet the public key used to verify the signature is unique!</p>
<p>Although threshold signature schemes existed long before, the Internet Computer is the first blockchain to integrate this technology into the low-level protocol.</p>
<p>Without the full private key, only dispersed key shares, even replicas holding shares can't directly obtain signature results. Enough signature fragments have to be collected to generate the signature. Requiring multiple replicas to jointly confirm operations on the blockchain enhances security and reliability. It becomes very difficult for an adversary to control enough replicas to forge signatures.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20231008154809887.png" alt="image-20231008154809887" style="zoom:35%;" />
</div>
<p>BLS is the only signature scheme that enables a very simple and efficient threshold signing protocol. Replicas holding private key shares can easily generate fragmentary signatures on messages, and reaching the threshold number of fragments allows composing the complete signature for the message. Moreover, the replicas don't need interaction, each one just broadcasts out its fragment. And inheriting excellent genes from BLS, the signature is unique - for a given public key and message, there is only one valid signature. No matter which private key fragments sign, as long as enough fragments are combined, the final signature is always the same.</p>
<p>Threshold BLS signatures are the foundation of the Internet Computer. With threshold signatures, replicas in a subnet can use threshold BLSs to achieve consensus:</p>
<ul>
<li>
<p>When enough replicas in a subnet sign a new block, their fragments can be combined into a complete signature, meaning consensus is reached with the majority ruling. Other replicas can verify the block using the subnet's public key.</p>
</li>
<li>
<p>When enough replicas sign a random beacon, their fragments also make a full signature, meaning the new signature becomes a new random number. As long as the signed message is different each time, the signature result will definitely be different too. And each private key fragment allows other replicas to verify this randomness using the subnet's public key.</p>
</li>
<li>
<p>When enough replicas sign a Merkle tree root, their fragments make a complete signature, meaning most replicas in the subnet have consistent state. Users can verify the output using the subnet's public key.</p>
</li>
</ul>
<p>Additionally, these threshold signatures serve as the source of unpredictable pseudorandomness:</p>
<p>As an unpredictable and unbiasable source of pseudorandomness available to any smart contract, this is a unique capability that enables applications impossible on other blockchains (e.g. NFT lotteries).</p>
<p>Threshold BLS signatures have another critical benefit - users need to ensure messages returned from the subnet haven't been tampered with, otherwise there could be trouble if a hacker swaps them out. </p>
<p>So the subnets sign messages back to users.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230818163340357.jpg" alt="img" style="zoom:30%;" />
</div>
<p>With threshold BLSs, even if some replica nodes fail or go offline, the remaining honest nodes can still reach consensus and sign messages as long as their number meets the threshold. This maintains liveliness and security.</p>
<p>The fragments from honest nodes are sufficient to compose valid signatures that users can verify with the subnet's public key. Threshold signatures provide decentralization, scalability, and antifragility!</p>
<p>As I mentioned earlier - if every replica generated their own key pair, managing all those keys would be complex and inefficient ü•≤. And if different replicas signed each block, for users to verify chain contents they'd have to download hundreds of GBs to check everything themselves üò≠. That's just unfriendly.</p>
<p>But with threshold BLS signatures, it's like each subnet only has &quot;one key pair&quot;. The private key is jointly held by replicas in the subnet, while there is only one corresponding public key for the subnet! Anyone can use the subnet public key to verify content signed by the subnet üëç!</p>
<p>This means verifying chain data no longer requires downloading hundreds of GBs - you can just use a 48 kb subnet public key to independently check any message. Even mobile phones, computers, and IoT devices can verify messages signed by subnets.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230818163244831.png" alt="img" style="zoom:27%;" />
</div>
<p>Similarly, when communication between subnets is needed, Subnet B can use Subnet A's public key to verify messages from Subnet A.</p>
<p>This cross-shard verification enables the Internet Computer to scale horizontally - with enough replicas, unlimited shards (subnets) can be created.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230818175102179.png" alt="img" style="zoom:33%;" />
</div>
<p>Each subnet is like an independent &quot;mini blockchain&quot;, with subnets using public keys to verify communication. Since consensus already happened internally in Subnet A, Subnet B just needs to verify messages from A using its public key. This greatly streamlines cross-shard communication.</p>
<br>
<p>But wait, if every subnet has a public key, won't there be tens of thousands of keys to manage with so many subnets in the future?</p>
<p>No worries üòè. There's the system subnet - the NNS! The NNS Canister has a registry holding every subnet's public key. Just ask the NNS if you need a subnet's key.</p>
<p>And for extra safety, the NNS subnet threshold signs all other subnets' public keys. So you can use the NNS subnet key to verify its signatures on other subnets' keys.</p>
<p>Then cache a few common subnet keys on user devices, and we're good to go üëå. </p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20231008155036213.png" alt="image-20231008155036213" style="zoom:50%;" />
</div>
<p>Alright, threshold BLS verification is no problem now.</p>
<p>But this is still far from enough.</p>
<h2 id="nidkg"><a class="header" href="#nidkg">NIDKG</a></h2>
<p>The replicas in a subnet need threshold BLS signatures to operate, so the first step is distributing keys to each replica. However, threshold schemes usually rely on a trusted key generation center to distribute the keys. But in a blockchain, no single replica can be easily trusted as non-malicious.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230820224815507.png" alt="img" style="zoom:30%;" />
</div>
<p>This requires a distributed key generation (DKG) protocol - such protocols had very limited use before, are complex to implement, and inefficient taking a long time just to distribute keys, far from practical.</p>
<p>The main reason is traditional DKGs either assume synchronous networks for communication, or lack robustness, or both require synchrony but aren't robust.</p>
<p>Synchronous communication means if there's even a slight delay in messages, the whole DKG process would fail or be insecure. And no robustness means if any replica crashes during DKG, the whole protocol fails.</p>
<p>But to realize threshold BLSs on a blockchain requires DKG, otherwise it wouldn't be a blockchain! With no choice, Dfinity's masters had to research improving DKG efficiency.</p>
<p>For ordinary people, the complex crypto theory would look like hieroglyphics. Luckily Dfinity's masters each have incredible skills.</p>
<p><a href="https://dfinity.org/">Dfinity</a> has many experienced experts, including computer scientists, cryptographers, researchers, and PhDs from top institutions like ETH Zurich, MIT, Stanford, UCLA, Yale, and more, with many previously at tech giants like Google, Amazon, IBM.</p>
<p>CTO <strong>Jan Camenisch</strong> is a computer scientist, IEEE and IACR fellow, published over 120 highly-cited papers on privacy and crypto, and was an IBM Chief Scientist for 19 years. <strong>Ben Lynn</strong> co-created BLS signatures - the &quot;L&quot; in BLS is for Lynn. He got his PhD from Stanford and worked at Google for 10 years. <strong>Timo Hanke</strong> was a professor of mathematics and cryptography at RWTH Aachen University. In 2013 he created AsicBoost, improving Bitcoin mining efficiency by 20-30%, now a standard for large mining operations.</p>
<p>There's also cryptographic wizard <strong>Jens Groth</strong>, who invented pairing-based NIZKs, pairing-based SNARKs, and sub-logarithmic sized proof systems for Bulletproofs. With a PhD from Aarhus University, he did postdoctoral research at UCLA, became a cryptography professor at UCL, and has published over 50 papers.</p>
<p>Ah yes, <a href="https://medium.com/dfinity/jens-groth-principal-researcher-at-dfinity-receives-the-iacr-test-of-time-award-512bcddceed9">Jens</a> is our protagonist here.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230820221756941.png" alt="img" style="zoom:80%;" />
</div>
<p>No existing DKG could meet the Internet Computer's high standards - it needed one that was secure and robust even on an asynchronous network with many faulty replicas.</p>
<p>To tackle inefficient DKGs, Jens went back to basics and heavily optimized the complex multi-round interaction required in DKG. DKGs use zero knowledge proofs, but normal proofs require multiple rounds of interaction just between two parties, let alone the many replicas in a subnet. And proofs have high computation complexity, needing intricate crypto and protocols, with expensive proof generation and verification.</p>
<p>So master Jens rolled up his sleeves and got to work on the cryptography: inventing efficient non-interactive zero knowledge proofs (NIZKs) that complete proofs without interaction.</p>
<p>With NIZKs, the new DKG gained wings, and soon NIDKG was born!</p>
<p>The novel NIDKG can run on asynchronous networks with great robustness - it keeps operating even if a third of replicas in a subnet fail or crash. Replicas just generate transactions without interacting further with others. The remaining replicas can aggregate transactions to compute the subnet's public key for the threshold scheme. Each replica can also decrypt its own private key share from the transactions.</p>
<br>
<p>NIDKG is the most critical part of ChainKey. Nothing less! </p>
<p>BLS threshold signatures are very simple, convenient, and highly useful. However, if you want to use BLS threshold signatures in a distributed system, how to securely and reliably distribute the private key shards is quite challenging. </p>
<p>Efficient non-interactive protocols like NIDKG can address the limitations of BLS threshold signatures very well. It enables deep integration of BLS threshold signatures in blockchain systems, using them for consensus, generating randomness, and validating information emitted on-chain. </p>
<p>More introduction to on-chain randomness can be found <a href="3.ChainKey/">here</a>. </p>
<br>
<p>As Dfinity boasted about their scientific team üëá.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230820231353543.png" alt="img" style="zoom:67%;" />
</div>
<p>The &quot;non-interactive&quot; in NIDKG means replicas don't need interaction. Without multiple communications, each replica just generates its polynomial secrets and NIZK proofs based on the protocol, then broadcasts them out. If interaction was required, complexity scales exponentially with more replicas, messing up the whole subnet. And any replica's slight delay could cause failure across the subnet.</p>
<p>By the way, zero knowledge (ZK) proofs are a cutting-edge cryptography technique that lets you prove something to someone without revealing what it is. Sounds unbelievable right! But it's possible in cryptography. It's like when your girlfriend says &quot;I want to tell you something, but you have to promise me first.&quot; And you ask &quot;What do you need to tell me?&quot; She replies &quot;You have to promise first!&quot;</p>
<p>Besides integrating new tech into the low-level system, Dfinity has also started applying it to other areas recently, building the encrypted utopia Dominic envisions. In 2021 they proposed using ZK proofs for identity on the Internet Computer. And in 2023 the crypto wizards are already planning to add zero knowledge proofs!</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230820230117316.png" alt="img" style="zoom:80%;" />
</div>
<h3 id="the-specific-process"><a class="header" href="#the-specific-process">The Specific Process</a></h3>
<p>Whoops, I rambled too much just now. Been feeling lonely lately, tend to babble on and on when talking. Anyway, let's dive into the NIDKG internals and see how it enables our operation.</p>
<p>After the previous overview, we know NIDKG has each replica independently generate a transaction (dealing) and broadcast it out. The transaction contains the replica's secret encrypted file, NIZK proof of the encryption, and material to generate the subnet's public key. Other replicas receive and verify the NIZK proofs, and once 2/3 of dealings are collected, they can reconstruct the subnet public key and their own private key shares.</p>
<h4 id="public-parameters"><a class="header" href="#public-parameters">Public Parameters</a></h4>
<p>Before starting, the NIDKG protocol needs some public parameters, such as NNS will tell everyone <strong>how many replicas there are in the subnet (n)</strong>, <strong>what the threshold is (t)</strong>, and some parameters that are predetermined, bilinear groups \(G1\) ,\(G2\) ,\(GT\) and generators \(g1\) ,\(g2\) , hash function \(H\) and binary tree height \(Œª\) etc. NNS will also assign each replica a <strong>node ID (node_id)</strong> as the replica's own identity. (<a href="https://github.com/dfinity/ic/blob/master/rs/consensus/src/dkg.rs#L98C25-L98C25">Source code</a> calls it this, I don't know why not call it replica ID üòù, maybe &quot;replica&quot; was coined later ~)</p>
<p>These parameters need to be determined and published before running the protocol.</p>
<br>
<h4 id="generate-key-pairs"><a class="header" href="#generate-key-pairs">Generate Key Pairs</a></h4>
<p>In NIDKG, each replica needs to generate its own public and private key pair. The steps to generate the key pairs are:</p>
<ol>
<li>Choose a random \(x\), uniformly randomly selected from \(Z_{p}\).</li>
<li>Use the chosen \(x\) to compute the public key:</li>
</ol>
<p>$$
y = g_{1}^{x} 
$$</p>
<p>where \(g1\) is a predefined generator of the protocol.</p>
<ol start="3">
<li>Construct a zero knowledge proof \(œÄ\) to prove knowledge of the discrete logarithm \(x\) of \(y\). This uses the standard Schnorr proof for elliptic curve discrete log.</li>
<li>Set the public key to:</li>
</ol>
<p>$$
pk = (y, œÄ_{dlog})
$$</p>
<p>where it contains \(y\) and the proof \(œÄ\).</p>
<ol start="5">
<li>Choose another random \(œÅ\), uniformly randomly selected from \(Z_{p}\).</li>
<li>Use \(œÅ\) and the predefined protocol parameters \(f0, ..., fŒª, h\) to compute the private key:</li>
</ol>
<p>$$
dk\ =\ (g_{1}^œÅ,\ g_{2}^x\ *\ f_{0}^œÅ,\ f_{1}^œÅ,\ ...,\ f_{Œª}^œÅ,\ h^œÅ) 
$$</p>
<p>$$
dk_{0}\ =\ (0,\ dk) 
$$</p>
<p>where the private key \(dk\) is a forward secure private key that can be used to decrypt subsequent ciphertexts.</p>
<ol start="7">
<li>Delete the intermediate temporary variables \(x\), \(œÅ\) used in the computations.</li>
<li>Use the generated public and private key pair (pk, dk) as this replica's key pair.</li>
</ol>
<p>Each replica needs to generate such a key pair (pk, dk).</p>
<br>
<h4 id="generate-dealings"><a class="header" href="#generate-dealings">Generate dealings</a></h4>
<p>The process of generating dealings:</p>
<p><strong>Each replica independently randomly generates a (t-1)-degree polynomial \(a_{i}(x\)).</strong></p>
<p>For example, replica \(i\) generates:</p>
<p>$$
a_{i}(x)\ =\ a_{i0}\ +\ a_{i1}*x\ +\ ...\ +\ a_{i(t-1)}*x^{t-1} 
$$</p>
<p>where when \(x = 0\), the value of the polynomial \(a_{i}(0\)) is a randomly generated secret \(s\). If it is re-distributing keys, the private key share from before is used as the secret \(s\).</p>
<p><strong>The constant \(a_{i0}\) of the polynomial represents the shared secret, \(a_{i1},\ ...,\ a_{it-1}\) are randomly chosen coefficients from \(Z_{p}\):</strong></p>
<p>$$
Set\ a_{i0}\ =\ s\ \ and\ \ pick\ random\ a_{1},\ ...,\ a_{t-1}\ \overset{$}{\leftarrow} Z_{p} 
$$</p>
<p>Then compute all the constant terms \(a_{i0},\ ...,\ a_{i(t-1)}\) of the polynomial \(a_{i}(x\)) corresponding \(g_{2}\) group elements \(A_{i0}\ ...\ A_{i(t-1)}\):</p>
<p>$$
A_{i0}\ =\ g_{2}^{a_{i0}} 
$$</p>
<p>$$
A_{i1} = g_{2}^{a_{i1}} 
$$</p>
<p>$$
... 
$$</p>
<p>$$
A_{i(t-1)} = g_{2}^{a_{i(t-1)}} 
$$</p>
<p>Then put these \(A_{i}\) as public parameters into the dealing \(d\).</p>
<p>So \(A_{i0},\ ...,\ A_{i(t-1)}\) correspond to the coefficients of the Shamir secret sharing polynomial \(a(x)\) used to generate the dealing. They are polynomial commitments. They are part of dealing d, used to verify the correctness of the secret sharing.</p>
<p>When the threshold number of dealings are collected, the public polynomial \(a(x)\) of all replicas can be recovered using Lagrangian interpolation, where \(a(0)\) is the public key of the subnet.</p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20230825213313484.png" alt="img" style="zoom:35%;" /> 
</div>
<p><strong>Replica i computes its secret share \(s_{1},\ ...,\ s_{n}\) of the polynomial \(a_{i}(x\)) using Shamir secret sharing:</strong></p>
<p>$$
s_{i}\ =\ {\textstyle \sum_{k=0}^{t-1}} a_{k}i^{k} \bmod p \ \ \ (k\ =\ 1,...,t-1) 
$$</p>
<p>Then convert \(s_{i}\) to binary:</p>
<p>$$
s_{i}\ =\ {\textstyle \sum_{j=1}^{m}} s_{i,j} B^{j-1} 
$$</p>
<p>Then, we need to encrypt and broadcast the secret share \(s_{i}\) so that other replicas will believe that decrypting the ciphertext gives \(s_{i}\)!</p>
<br>
<p>So we must provide evidence that we can decrypt the ciphertext in the dealing, so other replicas can recover their private key share with enough dealings. We use a multi-recipient forward secure encryption scheme where the ciphertext is publicly verifiable.</p>
<p>The only problem is the plaintext should be partitioned into small chunks, as recipients need to compute discrete logs to extract these chunks. So if the chunks a recipient needs to extract are too large, they will have problems. This requires a non-interactive proof system that can ensure all chunks are moderately sized.</p>
<br>
<p><strong>The secret share \(s_{i}\) is split into multiple small chunks mi, using a forward secure encryption scheme based on bilinear pairings.</strong></p>
<p>Each chunk \(mi\) has a small domain, so it can be brute forced decrypted later. ElGamal encryption is used on each chunk \(mi\).</p>
<p>Before generating the dealing, we already generated a public/private key pair, now we can encrypt the chunks using the public keys of all replicas: \(pk_{i}\ =\ (y_{i},\ œÄ_{i}\)).</p>
<p>Choose m random numbers \(r_{m},\ s_{m}\), uniformly randomly selected from \(Z_{p}\): \(r_{1},\ s_{1},\ ...,\ r_{m},\ s_{m}\ \overset{$}{\leftarrow} \ Z_{p}\).</p>
<p>First compute: \(C_{1,1},\ ...,\ C_{n,m},\ R_{1},S_{1},\ ...,\ R_{m},S_{m}\):</p>
<p>$$
C_{i,j} \ = \ y_i^{r_{j}} \ * \ g_{1}^{s_{i,j}}
$$</p>
<p>$$
Ri \ = \ g_{1}^{ri}
$$</p>
<p>$$
S_{j}\ =\ g_{1}^{s_{j}} 
$$</p>
<p>Then do some computations: (where \(\tau\) denotes epoch):</p>
<p>$$
\tau _ { Œª _ { T + 1 } } ... \tau _ { Œª _ { H } }\ =\ H _ { Œª _ { H } } ( pk _ { 1 },\ ...,\ pk _ { n },\ C _ { 1 , 1 },\ ...,\ C _ { n,m },\ R _ { 1 } , S _ { 1 },\ ...,\ R _ { m }, S _ { m } ,\ \tau )
$$</p>
<p>$$
f\ =\ f(\tau * { 1 }\ ...\ \tau * { Œª } )
$$</p>
<p>$$
Z_{j}\ =\ f ^ { r_{ j } } h ^ {s_{j} } \ \ \ (Z_{1},\ ...,\ Z_{m} ) 
$$</p>
<p>We can use the same random number \(R\) for all chunks to optimize performance:</p>
<p>$$
r\ = {\textstyle \sum_{m}^{j=1}} r_{j} B^{j-1} \bmod p 
$$</p>
<p>$$
R\ = \ g_{1}^{r} 
$$</p>
<p>The ciphertext C is the collection of encryptions of all chunks \(y_n^{r} \ * \ g_{n}^{s_{n} }\):</p>
<p>$$
C_{1} \ = \ y_1^{r} \ *\ g_{1}^{s_{1}},\ ...,\ C_{n} \ = \ y_n^{r} * \ g_{1}^{s_{n}}
$$</p>
<p>Now the chunked encryption is done.</p>
<br>
<p><strong>Finally construct two NIZK proofs:</strong></p>
<ul>
<li>\(œÄ_share\): Proof that the secret share \(s_{i}\) is a correct Shamir secret sharing, satisfying the polynomial \(a_{i}(x\)).</li>
</ul>
<p>$$ œÄ_{share} \gets Prove_{share}(y_{1},\ ...,\ y_{n},\ A_{0},\ ...,\ A_{t‚àí1},\ R,\ C1,\ ...,\ Cn;\ r,\ s_{1},\ ...,\ s_{n}) $$</p>
<ul>
<li>\(œÄ_chunk\): Proof that each ciphertext chunk is a correct encryption of \(s_{i}\).</li>
</ul>
<p>$$
œÄ_{chunk} \gets Prove_{chunk}(y_{1},\ ...,\ y_{n},\ R_{1},\ ...,\ R_{m},\ C_{1,1},\ ...,\ C_{n,m};\ r_{1},\ ...,\ r_{m},\ s_{1,1},\ ...,\ s_{n,m})
$$</p>
<div class="center-image"> 
<img src="3.ChainKey/assets/Chainkey/image-20230825213207705.png" alt="img" style="zoom:33%;" /> 
</div>
<p><strong>Replica i packages the encrypted private key share C, polynomial coefficients \(A_{i}\), and two NIZK proofs into a dealing \(d_{i}\).</strong> It broadcasts this dealing \(d_{i}\) to other replicas in the subnet.
$$
d\ =\ \binom{C_{1,1},\ ...,\ C_{n,m},\ R_{1},\ S_{1},\ ...,\ R_{m},\ S_{m}}{Z_{1},\ ...,\ Z_{m},\ A_{0},\ ...,\ A_{t-1},\ œÄ_{share},\ œÄ_{chunk}}
$$</p>
<p>The key to generating a dealing is doing the secret sharing, encryption, and providing NIZK proofs. This process ensures verifiability and security of the dealing.</p>
<br>
<h4 id="verify-dealings"><a class="header" href="#verify-dealings">Verify dealings</a></h4>
<p>When a replica receives a dealing d broadcast by another replica, it can verify the dealing like this:</p>
<p>The key is to verify the correctness of the NIZK proofs, that the plaintext chunks in the ciphertext are correct, and that it finally matches the published share verification key.</p>
<p>Input parameters explained:</p>
<ul>
<li>
<p>Optional \(shvk\) (share verification key), generated during public key aggregation.</p>
</li>
<li>
<p>Threshold t.</p>
</li>
<li>
<p>Public keys of n participants \(pk_{1},\ ...,\ pk_{n}\).</p>
</li>
<li>
<p>Current epoch \(œÑ\).</p>
</li>
<li>
<p>Dealing \(d_{j}\) to verify.</p>
</li>
</ul>
<p><strong>Check dealing format:</strong></p>
<ul>
<li>
<p>Ensure it contains the right components: ciphertext, NIZK proofs, etc.</p>
</li>
<li>
<p>Ensure each component is a valid group element.</p>
</li>
</ul>
<p><strong>If there is \(shvk_{j}\), check if it equals \(A_{j,0}\).</strong></p>
<p><strong>Compute leaf path and epoch \(œÑ\):</strong></p>
<ul>
<li>
<p>Extract hash parameters from ciphertext.</p>
</li>
<li>
<p>Run hash function to compute path \(œÑ\).</p>
</li>
</ul>
<p><strong>Compute f function value:</strong></p>
<ul>
<li>Compute \(f(œÑ1,\ ...,\ œÑŒª\)) according to path \(œÑ\).</li>
</ul>
<p><strong>Verify ciphertext relation with f:</strong></p>
<ul>
<li>Check pairing relation: \(e(g_{1}, Z_{j}) = e(R_{j}, f) ¬∑ e(S_{j}, h\))</li>
</ul>
<p><strong>Verify NIZK proof \(œÄ_share\):</strong></p>
<ul>
<li>Input instance info, run \(œÄ_share\)'s verification algorithm.</li>
</ul>
<p><strong>Verify NIZK proof \(œÄ_chunk\):</strong></p>
<ul>
<li>Input instance info, run \(œÄ_chunk\)'s verification algorithm.</li>
</ul>
<p>If all checks pass, the dealing d is considered valid. Otherwise it is invalid, reject the dealing.</p>
<p>This verification process can be done publicly by all replicas, ensuring verifiability of dealings, i.e. PVSS (Publicly Verifiable Secret Sharing).</p>
<br>
<h4 id="combine-dealings"><a class="header" href="#combine-dealings">Combine dealings</a></h4>
<p>When calling the function to recover the public key by combining dealings, the input parameters are:</p>
<ul>
<li>
<p>Threshold t.</p>
</li>
<li>
<p>Total number of participants n.</p>
</li>
<li>
<p>Index set indicating which dealings I were selected.</p>
</li>
<li>
<p>Validated dealings \(d1,\ ...,\ d\ell\).</p>
</li>
</ul>
<p><strong>Parse dealings:</strong></p>
<p>Each dealing \(d_{j}\) contains: \(A_{j,0},\ ...,\ A_{j,t-1}\).</p>
<p>Where \(A_{j,k} = g_{2}^{a_{j,k} }\), \(a_{j,k}\) is the polynomial coefficient of some replica j. The polynomial generated by each replica is random, like this:</p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20230825143154446.png" alt="img" style="zoom: 37%;" /> 
</div>
<p>And \(A_{j,k}\) is \(a_{j,k}\) of each replica's polynomial computed as \( g_{2}^{a_{j,k} }\). Like a hash function, knowing \(A_{j,k} = g_{2}^{a_{j,k} }\) does not reveal \(a_{j,k}\). As long as \(a_{j,k}\) is unchanged, \(A_{j,k}\) remains unchanged.</p>
<br>
<p><strong>Multiply \(A_{j,k}\) from each dealing to recover the public polynomial:</strong></p>
<p>Compute the public polynomial's \(A_{0}, ..., A_{t-1}\) of all replicas, for each \(k\ =\ 0,\ ...,\ t-1\) :</p>
<p>$$
A _ { k } \ =\ \prod _ { j=1 } ^ { \ell } A _ { j , k } ^ { L ^ { I } _ { i _ { \ell } } ( 0 ) }
$$</p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20230825214349915.png" alt="img" style="zoom:27%;" />
</div>
<p>This recovers the public polynomial's coefficients \(A_{0}, ..., A_{t-1}\) through interpolation. When \(k=0\), \(A_{0}\) is the public key of the subnet.</p>
<p><strong>Generate public key:</strong></p>
<p>$$
vk = A_{0}
$$</p>
<p><strong>Compute verification key:</strong></p>
<p>$$
shvk_{j}\ =\ \prod_{k=0}^{t-1}A_{k}^{j^{k}} 
$$</p>
<p>If successful, return \((vk, shvk_{1},\ ...,\ shvk_{n}\)).</p>
<p>Then the public key \(vk\) still needs to be verified:</p>
<p>Check parameters \(t,n\) are in valid range: \(1 &lt;= t &lt;= n &lt;= N\)</p>
<p>Check \(vk, shvk_{1}...shvk_{n}\) are all in group \(G2\). Set \(shvk_{0}\) to \(vk\).</p>
<p>Define index set \(J = {0,...,t-1}\).</p>
<p>For \(i\) from \(t\) to \(n\):</p>
<ul>
<li>Check if \(shvk_{i}\) equals:</li>
</ul>
<p>$$
shvk_{i}\ =\ \prod_{j=0}^{t-1}A_{k}^{j^{k}}
$$</p>
<p>That is, check if \(shvk_{i}\) lies on the Lagrangian interpolation polynomial of \(shvk_{0}...shvk_{(t-1)}\).</p>
<p>If all checks pass, then there are no issues. This verifies \(vk\) and \(shvk\) satisfy the public key validity requirements of the threshold BLS signature scheme, ensuring they are a valid public key set that can correctly perform threshold signatures.</p>
<br>
<h4 id="retrieve-private-key"><a class="header" href="#retrieve-private-key">Retrieve Private Key</a></h4>
<p>Finally each replica uses its own decryption key to decrypt and compute its private key share sk from all valid dealings.</p>
<p><strong>Parse input:</strong></p>
<ul>
<li>
<p>Recipient's decryption private key: \(dk_{œÑ'}\).</p>
</li>
<li>
<p>Dealing index set used: \(K\).</p>
</li>
<li>
<p>Dealings: \(d1,\ ...,\ d\ell\).</p>
</li>
<li>
<p>Epoch: \(œÑ\).</p>
</li>
</ul>
<p><strong>Parse each dealing:</strong> Parse each dealing to get its various elements, including \(C_{k,n,m}„ÄÅR_{k,m}„ÄÅS_{k,m}„ÄÅZ_{k,m}\) etc. These elements are in groups \(G1\) and \(G2\). Ensure \(1 ‚â§ i ‚â§ n ‚â§ N\).</p>
<p><strong>Define and compute \(œÑ\):</strong> For each dealing, based on the given \(œÑ\) value, define a series of \(œÑ_{k,1}\) to \( œÑ_{k, Œª_{T} }\), then compute subsequent \(œÑ_{k,Œª_{T+1} } ... œÑ_{k, Œª}\).</p>
<p><strong>Compute intermediate \(f_{k}\):</strong> Use function f to compute intermediate \(f_{k}\) for each dealing's \(œÑ\) value:
$$
f_{k}\ =\ f(\tau_{k,1},\ ...,\ \tau_{k,\lambda }) 
$$
<strong>Derive decryption key:</strong> Based on given key update information \(dk_{œÑ'}\), derive the decryption key \(dk_{œÑ_{k,1},\ ...,\ œÑ_{k, Œª} }\). These decryption keys are in the set \({0, 1}^{Œª} √ó G_{1} √ó G_{2}^{2}\).</p>
<p><strong>Compute \(M_{k,j}\):</strong> For each element of each dealing, use the given algorithm to compute \(M_{k,j}\) values, involving some multiplications and exponentiations:
$$
M_{k,j}\ =\ e(C_{k,i,j},\ g_{2})\ \cdot e(R_{k,j},\ b_{k}^{-1})\ \cdot e(a_{k},\ Z_{k,j})\ \cdot e(S_{k,j},\ e_{k}^{-1}) 
$$
<strong>Brute force search:</strong> For each k and j, use the Baby-Step Giant-Step algorithm to brute force search for a suitable \(s_{k,j}\) value, such that \(M_{k,j}\) equals a specific value:
$$
M_{k,j}\ =\ e(g_{1},\ g_{2})^{s_{k,j}}
$$
<strong>Compute \(s_{k}\):</strong> Use the found \(s_{k, j}\) values to compute part of the private key \(s_{k}\):
$$
s_{k}\ =\ \sum_{j\in J}^{m} s_{k,j}B^{j-1} \bmod p 
$$
<strong>Parse K and compute \(s_{i}\):</strong> Parse set \(K\), compute \(s_{i}\) from all \(s_{k}\) using Lagrangian interpolation, involving previous private key shares and \(s_{k, j}\):
$$
sk\ =\ s_{i}\ =\ \sum_{j\in J}^{\ell} s_{k,j}L_{k}^{K}(0) 
$$
<strong>Return result:</strong> If all steps succeed, erase intermediate computations, return private key share sk.</p>
<br>
<p><strong>Finally, verify the private key share:</strong> Validate secret sharing signature key validity, to verify the private key matches the signature verification parameters.</p>
<p>If sk is an integer in the normal range, and \(shvk\) equals \(g_{2}^{sk}\), then the verification succeeds.</p>
<br>
<p><strong>The key to NIDKG is that zero knowledge proofs make the verification process publicly verifiable, without needing interaction with other replicas to independently judge if a dealing is correct.</strong></p>
<p><strong>Each replica chooses a random secret (random number or private key share from last epoch) to generate a polynomial, then computes the shared secret \(s_{i}\). Finally it chunks \(s_{i}\), encrypts the chunks, builds two zero knowledge proofs, and packages it as a dealing for other replicas to verify. After verification, the public key of the subnet and the replica's own private key share can still be computed through non-interactive methods.</strong></p>
<br>
<h3 id="resharing-protocol"><a class="header" href="#resharing-protocol">Resharing Protocol</a></h3>
<p>After a subnet has generated its public key, if a new public key is generated every time subnet members change, it would be quite troublesome. Also, if the key is only updated when subnet members change, it is not secure enough. Because if over one third of replicas are compromised by hackers in various ways, the whole subnet would be paralyzed. If a hacker first silently compromises one replica, continues to lurk and silently tries to compromise the next replica, until controlling enough replicas, then launches an attack ... </p>
<br>
<p>So to solve these two problems, the resharing protocol can retain the subnet public key, and only reshare the private key share of each replica. This also provides proactive security, periodically refreshing the private key shares of all replicas in the subnet. </p>
<div class="center-image"> 
<img src="3.ChainKey/assets/Chainkey/image-20230827153152958.png" alt="img" style="zoom:43%;" /> 
</div>
<p>Now let's review:</p>
<p>Assume the old public key \(vk\) has passed public key validation.</p>
<p>In the verification after public key aggregation, it is guaranteed that \(shvk_{1},...,shvk_{n}\) can be derived from \(vk\) and \(shvk_{1},...,shvk_{t-1}\) through Lagrangian interpolation.</p>
<p>That is, \(vk\) and \(shvk_{1},...,shvk_{n}\) satisfy the same \(t-1\) degree polynomial \(a(i\)):</p>
<p>\[
vk\ =\ A _ { 0 } \ =\ \prod _ { j=1 } ^ { \ell } A_ {j,0} ^ {L ^ { I } _{ i _ { \ell } } ( 0 ) } \ = \ g _ { 2 } ^ { a _{ 0 } }
\]</p>
<p>\[
shvk_{ i } = g^{ a( i ) }_ { 2 }\ \ \ (i\ =\ 1,\ ...,\ n)\ = A_{ i }
\]</p>
<p>For any index set \(I\) containing \(1&lt;=i_{1} &lt; ... &lt; i_{t} &lt;= n \) , we can compute the public key \(vk\) from \(shvk_{i}\) using:</p>
<p>\[
vk\ =\ \prod_{j=1}^{t} shvk_{ i_{ j } } ^ { L^{I}_ {i_{ j } }(0)}
\]</p>
<p>During key resharing, given \(t\) dealings \(d_{1},...,d_{t}\) that correspond to valid \(shvk_{ i_{ 1 } },...,shvk_{ i_{ t } }\) respectively.</p>
<p>When verifying the validity of these dealings, we know:</p>
<p>$$
A _ { 1 , 0 } = shvk _ { i _ { 1 } } ,\ ...,\ A _ { t , 0 } = shvk _ { i _ { t } }
$$</p>
<p>Compute the new public key \(vk'\) from these dealings:</p>
<p>$$
vk' \ = \ A _ { 0 } \ = \ \prod _ { j = 1 } ^ { t } A _ { j , 0 } ^ { L ^ { I } _ { i _ { \ell } } ( 0 ) }
$$</p>
<p>Substitute \( A _ { 1 , 0 } = shvk _ { i _ { 1 } },\ ...,\ A_{ t , 0 } = shvk _ { i _ { t } } \) into this formula, we get:</p>
<p>$$
vk'\ =\ A _ { 0 } \ = \ \prod _ { j = 1 } ^ { t } shvk _ { i _ { j } } ^ { L ^ { I } _ { i _ { j } } ( 0 ) }
$$</p>
<p>The new \(vk' = A_{0}\), so \(vk' = vk\). Thus the verification keys are perfectly retained.</p>
<br>
<p>So each time after key update, the public polynomial \(a(i\)) plotted looks something like this: the other coefficients of the public polynomial change each time, but each different public polynomial passes through the same point when \(x = 0\).</p>
<div class="center-image"> 
<img src="3.ChainKey/assets/Chainkey/image-20230825222232664.png" alt="img" style="zoom:25%;" /> 
</div>
<p>This ensures that each NIDKG can recover the same public key. The subnet public key remains unchanged, but the other coefficients of the public polynomial change, thus achieving forward security.</p>
<br>
<h3 id="epochs"><a class="header" href="#epochs">Epochs</a></h3>
<p>First is to ensure security of each replica, making it difficult for hackers to attack. Second is that even if a few minority replicas are attacked, as long as the hacker does not compromise more than one third of replicas at once, the subnet will not be threatened. As long as the hacker does not acquire enough private key shares within one epoch, they cannot pose a threat to the subnet.</p>
<div class="center-image"> 
    <img src="3.ChainKey/assets/Chainkey/image-20231008155922792.png" alt="image-20231008155922792" style="zoom:40%;" /> 
</div>
<p>Even if the hacker severs node connections, the subnet can purge anomalous nodes by frequently changing private key shares.</p>
<p>When new replicas join the subnet, the resharing protocol is also run to share private key shares with the new replicas.</p>
<br>
<p>So how often should the private keys be changed? Once per epoch, where an epoch contains many consensus rounds, usually 500 rounds (adjustable by the NNS).</p>
<p><a href="https://claude.ai/chat//2.%E6%A0%B8%E5%BF%83%E5%8D%8F%E8%AE%AE/2.%E5%85%B1%E8%AF%86%E5%B1%82.html#%E9%A6%96%E5%85%88%E6%98%AF%E5%87%BA%E5%9D%97%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87">As mentioned before</a>, Internet Computer has the concept of &quot;epochs&quot;. The replicas in each subnet change private key shares once per epoch. The concept of epochs comes from the paper <a href="https://eprint.iacr.org/2019/514">Pixel: Multi-signatures for Consensus</a>, co-authored by Dfinity's engineering manager Manu Drijvers, Gregory Neven, Hoeteck Wee and Sergey Gorbunov.</p>
<p>The paper designs an efficient and secure forward secure multi-signature scheme Pixel that can be directly applied to existing blockchains, while bringing significant performance improvements.</p>
<blockquote>
<p>The paper proposes a new forward secure multi-signature scheme Pixel that can be used in PoS blockchains to prevent posterior corruption attacks. This scheme is based on hierarchical identity-based encryption and achieves highly efficient forward secure multi-signatures without relying on a trusted setup. Pixel signatures consist of just two group elements regardless of the number of signers. Verification requires just 3 pairings and 1 exponentiation, supporting non-interactive aggregation. Compared to tree-based forward secure signatures, Pixel provides significant improvements in storage, bandwidth, and verification time. It also compares Pixel to BLS-based signatures, demonstrating that Pixel satisfies both efficiency and forward security.</p>
</blockquote>
<br>
<h2 id="chain-evolution-technology"><a class="header" href="#chain-evolution-technology">Chain Evolution Technology</a></h2>
<p>Two other important parts of chain key cryptography are Summary Blocks and Catch-up Packages (CUPs). Their role is to help subnets smoothly perform on-chain changes and upgrades, which we call Chain-evolution Technology.</p>
<p>What are on-chain changes and upgrades? During operation of a subnet, the replicas in the subnet may increase or leave, and the algorithms and protocols of the replicas also need continuous improvements and optimizations. This requires dynamically adjusting the blockchain state.</p>
<p>If backward compatibility is not considered and protocols are directly upgraded in a subnet, forks are very likely to occur. This is extremely detrimental to decentralized networks. This requires a carefully designed on-chain upgrade mechanism, i.e. chain evolution technology.</p>
<br>
<h3 id="summary-blocks"><a class="header" href="#summary-blocks">Summary Blocks</a></h3>
<p>The first block of each epoch is a Summary Block. It is the beginning of an epoch, serving as a transition between epochs.</p>
<p>It is the key to the smooth running of each era. The summary block records important information about an era, such as which replicas are responsible for consensus, which replicas are responsible for random beacons, etc. during that era. Each era has different characteristics, and this information is updated at the start of each new era. </p>
<p>The Summary Block provides base parameters and initialization information for an epoch. With the Summary Block as the cornerstone, the subnet can stably run throughout the entire epoch. It is like rules set before a competition, to let all players clearly understand their positioning and responsibilities.</p>
<p>Summarizing this critical information into Summary Blocks has many benefits:</p>
<ol>
<li>New replicas can quickly sync subnet state, without needing to execute from genesis once.</li>
<li>Key parameters are centrally managed, convenient for on-chain governance and upgrades.</li>
</ol>
<p>It can be seen that Summary Blocks serve as &quot;anchors&quot; in smoothly performing on-chain changes.</p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20231008160127485.png" alt="image-20231008160127485" style="zoom:80%;" />
</div>
<p>Several very important data fields in each epoch's Summary Block:</p>
<p>The <strong>currentRegistryVersion</strong> determines which replicas comprise the consensus committee for this epoch. The consensus committee will be responsible for all consensus layer activities like block production, validation, finalization, etc. during this epoch.</p>
<p>The <strong>nextRegistryVersion</strong>, each consensus round, the block producer will put the latest registry version number it knows into the proposal (this version number must be no earlier than the block it is extending). This ensures the value of this field in each epoch's Summary Block is always the newest.</p>
<p>The &quot;currentRegistryVersion&quot; of this epoch will become the &quot;currentRegistryVersion&quot; of the next epoch. Similarly, the &quot;currentRegistryVersion&quot; of this epoch also comes from the &quot;nextRegistryVersion&quot; in the previous epoch's Summary Block.</p>
<p>The <strong>currentDealingSets</strong> is the set of threshold signature dealings that determine the threshold signature key used to sign messages this epoch.</p>
<p>The <strong>nextDealingSets</strong> is the set of dealings prepared in the previous epoch, which will be set as the &quot;nextDealingSets&quot; this epoch. The &quot;nextDealingSets&quot; of this epoch will become the &quot;currentDealingSets&quot; of the next epoch.</p>
<p>That is, the NIDKG protocol or key resharing process is carried out every epoch. Assume key resharing occurred in epoch 4, it would be placed in the &quot;nextDealingSets&quot; of the Summary Block in epoch 5, and set as the &quot;currentDealingSets&quot; in epoch 6. Meaning the replicas that shared private key shares in epoch 4 serve as the consensus committee.</p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20231008160821553.png" alt="image-20231008160821553" style="zoom:67%;" />
</div>
<p>This provides enough time for the replicas in the subnet to run the NIDKG protocol or key resharing. If not enough dealings are collected, the protocol will continue using the dealings from this epoch in the next epoch, to buy more time to generate sufficient dealings.</p>
<p>The <strong>collectDealingParams</strong> describes the parameters of the set of dealings to be collected this epoch. This epoch, the block producers will put these parameters into dealings, then into the blocks in their proposals.</p>
<p>The dealing committee that receives these dealings is determined by the &quot;nextRegistryVersion&quot; in the Summary Block. The members of the &quot;nextRegistryVersion&quot; generate dealings this epoch, then become the consensus committee next epoch, and finally become the random beacon committee two epochs later.</p>
<p><strong>The dealing, consensus, and random beacon committees are different each epoch, with replicas taking turns being responsible for different tasks in each committee. The dealing committee has two epochs to run the NIDKG protocol and prepare their private keys. Next epoch they become the consensus committee, then are responsible for subnet consensus, and finally subnet random beacons.</strong></p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20231008161307295.png" alt="image-20231008161307295" style="zoom:31%;" />
</div>
<p>Through the current and next registry versions, current and next dealing sets, and dealing collection parameters, a Summary Block for an epoch contains all the rules and configurations the consensus layer needs to follow for the current epoch.</p>
<blockquote>
<p>Note that even if a replica is removed from a subnet, (if possible) it should fulfill an extra epoch of assigned committee duties. For example if it worked in the consensus committee for one epoch, it should go to the random beacon committee for one more epoch before leaving the subnet.</p>
</blockquote>
<br>
<h3 id="catch-up-packages"><a class="header" href="#catch-up-packages">Catch-up Packages</a></h3>
<p>A Catch-up Package (CUP) is a special message containing a snapshot of the current state, allowing replicas to recover to the current state at the start of a new epoch without needing to know past information.</p>
<p>The CUP does not contain the full state of the entire subnet. The CUP only contains the root of the Merkle tree resulting from converting the entire subnet state into a Merkle tree, plus some other critical data.</p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20230912232811269.png" alt="img" style="zoom:37%;" />
</div>
<h4 id="structure-of-a-cup"><a class="header" href="#structure-of-a-cup">Structure of a CUP</a></h4>
<p>It contains all the key information a replica needs to start working in a new epoch:</p>
<ul>
<li>Digest of the entire replica state (root of the Merkle tree). This is also a snapshot of the entire subnet state.</li>
<li>The Summary Block of the current epoch, containing key information about this epoch.</li>
<li>The first random beacon of the current epoch, which is the random number seed needed to generate new blocks.</li>
<li>Threshold signature of the subnet. This can verify validity and authority of the CUP.</li>
</ul>
<p>The CUP still relies on threshold BLS signatures, which are fundamental to subnet consensus. The replicated state of the entire subnet is several hundred GBs, too large. So we can split the entire subnet state into chunks, then convert into a Merkle tree. We just need to give the root of the Merkle tree to the replicas for a low threshold signature! (*^‚ñΩ^*) </p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20231008161915908.png" alt="image-20231008161915908" style="zoom:50%;" />
</div>
<p>Generating a CUP requires waiting until the end of the epoch to obtain the complete state information. Then the state is processed into a tree structure, calculating the root as the digest. This greatly reduces message size.</p>
<p>The CUP only contains a digest of the subnet replica state (root of the Merkle tree), not the complete state. Replicas can pull required state from peer replicas in the P2P layer, then combine with the Summary Block and random number seed in the CUP message to reconstruct the state at that time and continue working in the new epoch.</p>
<p>Using a threshold signature ensures there is only one valid CUP each epoch, the subnet public key remains unchanged, so the CUP can be verified by any replica.</p>
<div class="center-image">
<img src="3.ChainKey/assets/Chainkey/image-20230912232912503.png" alt="img" style="zoom:50%;" />
</div>
<p>It is similar to saving game progress. When restarting the game we can directly load the progress, without needing to replay everything. The CUP saves the current progress state of the blockchain network.</p>
<p>CUPs are also not permanently saved. Each replica only needs to save the latest CUP.</p>
<p>This is undoubtedly an important step for Internet Computer towards being practical and evolvable. It provides a framework for on-chain parameter adjustments, replica migrations, algorithm upgrades, etc.</p>
<br>
<h4 id="the-role-of-catch-up-packages"><a class="header" href="#the-role-of-catch-up-packages">The Role of Catch-Up Packages</a></h4>
<p>Like I mentioned before, when a new replica joins a subnet, it can quickly get up to speed on the subnet's current state thanks to the magic of Catch-Up Packages. Also, if a replica falls way behind the other replicas (maybe it was offline or disconnected from the network for a while), it relies on the Catch-Up Package to catch back up with the latest state.</p>
<p>Subnets don't permanently store every single block forever and ever. They don't need historical blocks for validation or anything. So each replica only keeps blocks from the most recent epoch to stay healthy, and deletes old blocks when they're no longer useful. Once a block gets finalized in consensus, the execution layer can just update the state. The subnet only needs the latest container state - old blocks and old state are kaput.</p>
<p>So whenever a subnet generates a Catch-Up Package, it can take out the trash and delete those old blocks. This gives Internet Computer way higher storage efficiency compared to typical blockchains (which keep every block and state forever).</p>
<p>Also based on Internet Computer's economic model where it uses a reverse Gas thingamajig. If developers don't top up their deployed smart contracts (Canisters) and the Canister runs outta Gas (Cycles), it goes buh-bye for good.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230912233446307.png" alt="img" style="zoom:50%;" />
</div>
<p>Catch-Up Packages also let subnets recover even if most replicas crash. As long as one replica survives, a brand new subnet can rise from the ashes using the Package and the replica's state.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20231008162159112.png" alt="image-20231008162159112" style="zoom:50%;" />
</div>
<p>Subnets can use CUPs to balance their load too. If too many Canisters are installed on a subnet, the NNS can split it into two subnets. Each new subnet keeps truckin' using the Package from the original subnet, with each subnet keeping half of the Canisters.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230913001217267.png" alt="img" style="zoom: 35%;" />
</div>
<p>In each consensus round, one replica in the subnet cooks up a block. Each block contains the latest registry version the block creator downloaded from the NNS. Other replicas only notarize the block if that registry is around.</p>
<p>Within an epoch, all the subnets' replicas run the same replica version. To avoid forks, the replicas gotta switch versions at the same block height. For example, if the replicas find an upgrade is needed in the new version, they start upgrading next epoch.</p>
<p>After consensus is reached on the latest registry version among replicas across all subnets, next step is to switch to the new version. Subnet replicas upgrade protocols to the latest after generating the Package. When a new protocol version is needed, the Summary Block at epoch start will give the heads up; all replicas running the old protocol keep running the consensus protocol until the Summary Block of the next epoch is finalized and the corresponding Package is created; once that Package is good to go the replicas gotta hurry up and upgrade the protocol, install the new version, and keep on truckin' with the full protocol starting from the Package.</p>
<p>During upgrades the subnet can keep processing read queries, but can't process updates, putting Canisters in read-only mode. Afterwards the upgrade itself needs to be installed and the VM (Internet Computer Virtual Machine) restarted to complete the upgrade, so query calls go dark too. Overall, downtime during subnet upgrades is just a few minutes.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20230908180550931.png" alt="img" style="zoom:33%;" />
</div>
<p>This is how each Internet Computer subnet fixes bugs, adds new features, which is the super critical capability allowing Internet Computer to run forever.</p>
<br>
<h2 id="chain-key-tokens"><a class="header" href="#chain-key-tokens">Chain Key Tokens</a></h2>
<p>Canisters are super powerful Wasm virtual containers. Andreas, one of the WebAssembly VM designers and Google senior engineer, also worked on designing Canisters at Dfinity. They're so powerful we can even use Canisters as mini servers!</p>
<p>Knowing how insecure bridge security is, constantly getting hacked.</p>
<p>Well if we can use Canisters as servers, could we run other blockchain nodes on them? üòâ The answer is yesss - this directly brings smart contract capabilities to Bitcoin.</p>
<br>
<p>But Bitcoin and Ethereum use ECDSA for signatures, while Internet Computer uses BLS signatures. Also, we can't directly put private keys in a Canister. If we use a Canister to run other blockchain nodes (like a Bitcoin node), each replica in the subnet would have the same Canister, so we couldn't ensure security of the Bitcoin private key held in the Canister, because if any one replica gets hacked, the Bitcoin private key in the Canister would be leaked.</p>
<p>Of course, no worries, Dfinity crypto experts Jens Groth and Victor Shoup got this. üòè</p>
<p>It's just like threshold BLS signatures, we just need to deploy a threshold ECDSA algorithm in the subnet!</p>
<br>
<p>In traditional ECDSA, there is only one private key that can be used for signing. The idea behind threshold ECDSA signatures is, don't centralize the signing key in one place, but rather split the key across multiple replicas, so no single replica can sign alone, multiple replicas must collaborate to generate a signature. This way even if some individual replicas are compromised, the overall system's signing private key will not be leaked.</p>
<p>To sign, each replica will use its private key share to generate a &quot;signature share&quot;. Then combine all the signature shares from the replicas, and that gives the full signature. When combining the shares, malicious shares from dishonest replicas will be filtered out. Each replica's private key share is only known to itself.</p>
<p>Let's take a simple example, say there are 7 replicas in the subnet, each holding a private key share. Of them 2 replicas may be compromised and dishonest. We set a threshold of at least 5 replicas needing to collaborate to generate a signature.</p>
<p>When a user requests a signature, the 7 replicas each generate a signature share. The 5 honest replicas will generate correct shares, while the 2 dishonest may generate incorrect shares. The system will then choose any 5 of the 7 shares at random to combine, reconstructing the full signature. Since there are only 2 dishonest replicas, when choosing 7 shares there will definitely be 5 from honest ones, so incorrect signature shares can be filtered out, correctly generating the signature.</p>
<p>Dfinity's expert mentors also made threshold ECDSA satisfy multiple properties fitting Internet Computer:</p>
<ul>
<li>Threshold ECDSA is also non-interactive. It can ensure signatures are eventually output even if network communication is unreliable. This means signatures will be returned to users even if some messages are heavily delayed or some replicas temporarily go offline.</li>
<li>The signing phase is very efficient. If preprocessing has prepared auxiliary info, when a user requests a signature, each replica only needs to broadcast minimal info to complete signing, no extra coordination communication needed.</li>
<li>Supports the BIP32 standard, allowing deriving multiple signing keys from a master key.</li>
<li>Under reasonable crypto assumptions, this protocol provides the same level of security as single-point ECDSA. That is, the difficulty of an attacker forging signatures is equivalent to breaking the single-point ECDSA signature scheme.</li>
</ul>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/1.webp" alt="1" style="zoom:55%;" />
</div>
<p>The benefit of this approach is the attacker has to compromise multiple replicas simultaneously to forge signatures. Even if a small number of replicas are compromised, the &quot;ECDSA private key&quot; will not directly leak, allowing the overall system to continue operating securely. This improves security.</p>
<p>Learn more about ckBTC and ckETH.</p>
<br>
<h2 id="vetkeys"><a class="header" href="#vetkeys">VETKeys</a></h2>
<p>VETKey is a technology that derives decentralized keys via IDs.</p>
<p>By way of threshold signature encryption, replicas within the subnet collaboratively derive the private key corresponding to the ID. But here's the kicker: each replica is left clueless about the final private key. There's no Achilles' heel ‚Äì we're talking about top-notch security here. Even if a few replicas are compromised, the actual private key stays under wraps. Compared to traditional schemes, it's a safer bet as it doesn't rely on a trusted execution environment.</p>
<p>Users can encrypt private data. The replicas then join forces to decrypt the key and deliver it to the user. However, the actual key remains a secret throughout the process. Plus, a single subnet public key (a master key, if you will) can spawn an infinite number of isolated identity keys. This massively simplifies key management. It also paves the way for a variety of end-to-end encrypted applications, such as private chats, confidential payments, key custodian services, and so on.</p>
<p>Let's <a href="https://neutronstardao.github.io/constellation.github.io/3.ChainKey/VETkeys.html">take a closer look at</a> this on-chain key derivation scheme.</p>
<br>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>The greatest innovation of the Internet Computer lies in its use of a series of complex cryptographic technologies. It has achieved self-consensus within the subnet, which can be perceived as a type of sharding technology. With chain-key cryptography, secure cross-subnet communication can take place between subnets. As it does not require global consensus across the entire network, the Internet Computer can achieve horizontal scalability by adding more subnets.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/Chainkey/image-20231008163127289.png" alt="image-20231008163127289" style="zoom:50%;" />
</div>
<p>Hence, the threshold BLS signature is the cryptographic heart that keeps the Internet Computer running, with consensus requiring the threshold BLS signature. A host of other cryptographic technologies revolve around the threshold BLS signature. For instance, the secure distribution of threshold BLS signature keys, secret resharing, on-chain evolution technology, and randomness based on threshold BLS signature form the core protocols of the Internet Computer's foundation. Technologies such as Chain-Key Token and VETKey are advanced applications that indirectly use the threshold BLS signature.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vetkeys-1"><a class="header" href="#vetkeys-1">VETKeys</a></h1>
<p>All the data uploaded to blockchains nowadays is out there for all to see. <strong>If you wanna peek into what an account's been up to or what they've got stored away, it's all laid bare.</strong> Now blockchain tech might beef up security and availability, but it also opens the door to privacy leaks 'cause everything gets copied to so many nodes. Encryption can help protect privacy, but managing keys gets kinda hairy.</p>
<p>So Web3 users just ain't allowed to have no privacy, huh?</p>
<br>
<img src="3.ChainKey/assets/VETKeys/image-20230724134027881.png" style="zoom:65%; float: left; margin-right: 35px;" class="zoom-img" />
<p>Privacy is definitely indispensable. All you need to do is encrypt it with the public key and then store it on the blockchain, right?</p>
<p>A'ight, lemme just whip up a public-private key pair real quick. Encrypt with the public key, decrypt with the private key, bam, easy peasy. (Holla if you need an explainer on public-key cryptography).</p>
<br>
<p>It could work in theory, it's just kinda risky in practice:</p>
<p>What if you lose the private key?</p>
<p>What if some hacker gets ahold of it?</p>
<p>What if you wanna decrypt on another device?</p>
<p>Moving private keys between devices is a pain and prone to leakage!</p>
<br>
<p>This is where <a href="https://en.wikipedia.org/wiki/Identity-based_encryption">IBE</a> (Identity-Based Encryption) comes in handy. IBE was first proposed in 1984 by famous cryptographer Adi Shamir (yeah, the same Shamir behind <a href="https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing">Shamir's Secret Sharing</a> and the S in RSA). </p>
<p>But back then he could only come up with identity-based signatures, which were meh. IBE remained an open problem for years, until the Boneh-Franklin scheme and Cocks' quadratic residuosity-based encryption cracked it in 2001.</p>
<br>
<h2 id="ibe"><a class="header" href="#ibe">IBE</a></h2>
<p>IBE is a type of encryption that uses identity info to simplify key management. You can think of it as a special form of public key encryption. </p>
<p>With regular public key encryption, each user has their own public and private key pair. To send an encrypted message to a user, you need their public key.</p>
<p>But with IBE, users don't need to generate separate key pairs. They can just use their identity, like an ID number or email, as their &quot;public key.&quot; Of course you can't use the ID directly as a public key. IBE actually encrypts the file using a master public key together with the user's ID.</p>
<p>So you can think of it as the master public key and the user ID combining to form a &quot;user public key&quot; to encrypt the file. </p>
<blockquote>
<p>Note the master key and user ID don't actually get combined, they just work together during encryption.</p>
</blockquote>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724143504863.png" style="zoom:40%;" />
</div>
<p>IBE relies on a trusted third party: a Private Key Generator (PKG). The PKG first generates a master key pair. The master public key is made public, and is used together with the user ID to encrypt messages.</p>
<p>The master private key can derive a decryption key from the user ID, which is then sent to the user with that ID. The user can then encrypt messages using their ID.</p>
<p>The decryption key corresponding to an ID is derived from the master private key. With the PKG's master key pair, decryption keys can be computed for all IDs!</p>
<br>
<p>So the diagram actually looks like this:</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724202643512.png" style="zoom:40%;" />
</div>
<br>
<blockquote>
<p>According to <a href="https://eprint.iacr.org/2001/090">the paper</a>, the specific cryptographic principles are as follows:</p>
<ol>
<li>Setup phase:</li>
</ol>
<p>(1) Choose a bilinear group \((G1,G2,GT,e)\): This is a set of groups \(G1\), \(G2\) and \(GT\) with special mathematical relationships. Some computations can be done through the pairing operation \(e()\) between these groups.</p>
<p>(2) Choose a random generator \(P‚ààG1\), where \(P\) is a base point in group \(G1\). </p>
<p>(3) Choose a random master secret key \(s ‚àà Zp\): \(s\) is a random number.</p>
<p>(4) A hash function \(H\): \({0,1}* ‚Üí G1\): used to map identity information to group \(G1\).</p>
<ol start="2">
<li>Key Extraction phase: </li>
</ol>
<p>(1) For identity ID, compute \(H1(ID)\) to get public key \(QID\): \(QID = H1(ID)\). \(QID ‚àà G1*\).</p>
<p>(2) Use master secret key s and public key \(QID\) to compute decryption key \(SID = sQID\). The decryption key generator center computes the user's private key based on their identity, and sends it to the corresponding user.</p>
<ol start="3">
<li>Encryption phase:</li>
</ol>
<p>(1) To encrypt message \(M\) for ID, choose a random number \(r\), \(r ‚àà Zq*\).</p>
<p>(2) Compute ciphertext \(C\) which contains two parts: \(C1 = rP\), \(C2 = M‚äïe(H2(ID), P)r\). So \(C = (rP, M‚äïe(H2(ID), P)r)\).</p>
<p>Breaking it down: After choosing random \(r\), first compute ciphertext component \(C1 = rP\). Then compute \(gID = e(QID, P) ‚àà G2\), where \(P\) is a master public key and \(e\) is the bilinear map. Next compute ciphertext component \(C2 = M ‚äï H2(grID)\), where \(M\) is the plaintext and H2 is a hash function. The ciphertext \(C\) is \(&lt;C1, C2&gt;\).</p>
<ol start="4">
<li>Decryption phase:</li>
</ol>
<p>(1) Receive ciphertext \(C\). </p>
<p>(2) Use decryption key \(SID\) and \(C1\) to compute pairing \(e(SID, C1)\), which can restore \(e(H2(ID), P)r: e(SID, C1) = e(sQID, rP) = e(QID, P)r\).</p>
<p>(3) Then decrypt message \(M = C2‚äïe(H2(ID), P)r\).</p>
</blockquote>
<br>
<p>If everyone had to generate their own key pairs, it'd be a hot mess tryna keep track of all those public keys to encrypt stuff. You'd have a ginormous pile of confusing keys for every person you encrypt messages with. But with IBE, folks just need to hold on to one master public key, then use someone's ID directly to encrypt messages with them - piece of cake.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724205449144.png" style="zoom:37%;" />
</div>
<p>Users can switch up their ID periodically, and just have the PKG derive a new decryption key for the new ID. </p>
<p>Lost your decryption key? No prob, just have the PKG whip up a new one, then hurry and decrypt those files. Worried someone got their mitts on your decryption key? No biggie, get a new ID, get a new decryption key. You can even set expiration dates on IDs.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230725080738126.png" style="zoom:39%;" />
</div>
<p>Users can encrypt files using their ID with the PKG, and decrypt files using the decryption key derived by the PKG. So the ID acts like the public key, while the decryption key is derived by the PKG.</p>
<p>Through the PKG's master key, a unique decryption key can be computed for every ID.</p>
<br>
<p>For example, if Bob's email is bob@example.com, then according to this system, a decryption key corresponding to bob@example.com can be derived. With this decryption key, Bob can decrypt any information encrypted to bob@example.com .</p>
<p>This way, users don't need to separately save their decryption keys. The whole system only needs one master key, and can derive the matching decryption key based on identity.</p>
<p>IBE avoids the hassle in public key encryption of transmitting and saving each user's public keys. Users only need to know the other's identifier to encrypt messages.</p>
<p>In real applications, IBE systems often use the user's email as their ID. You only need to know the recipient's email to encrypt and send an email, without needing to obtain their public key. This simplifies key management processes.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724221954854.png" style="zoom:45%;" />
</div>
<p>Let's get real - IBE is public key encryption, just with the keys tied to users' identity info.</p>
<br>
<p>The big sell for IBE is you can straight up use identities as public keys, no messing with certs, and pulling keys is easy peasy. But here's the catch - the PKG knows everyone's decryption key keys.</p>
<p>So if some hacker punks the PKG and jacks the master key pair, all the users' data is toast! Their biz gets leaked cuz the PKG holds their secrets. One PKG breach means game over for privacy across the system.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724223257732.png" style="zoom:42%;" />
</div>
<p>We can't just randomly pick one subnet node as the PKG if we wanna use IBE on blockchain. Even selecting based on each era's first random beacon is shaky - what if that node turns malicious? Or the chosen PKG node goes rogue later on? We'd be screwed. And passing keys between nodes each period ain't secure either.</p>
<p>So we need something craftier than just winging it with a random PKG node.</p>
<p>To really lock down data security, the Dfinity team dropped &quot;<a href="https://eprint.iacr.org/2023/616.pdf">vetKeys: How a Blockchain Can Keep Many Secrets</a>&quot; in 2023. It presents a distributed key derivation scheme: <strong>verifiably encrypted threshold key derivation</strong>, or vetKD for short. The core of vetKD is Verifiably Encrypted Threshold BLS, aka vetBLS. Let me break down how vetKD works based on the paper.</p>
<br>
<h2 id="vetibe"><a class="header" href="#vetibe">VetIBE</a></h2>
<p>VetIBE replaces the traditional IBE's third party Private Key Generator (PKG) with subnet nodes. It uses threshold cryptography to make IBE key derivation more decentralized and verifiable, avoiding a single point of failure.</p>
<p>In regular IBE, the PKG derives a user's decryption key by multiplying the master private key with the hash of the user ID.</p>
<blockquote>
<p>\(dID = sQID\). Here \(dID\) is the user's decryption key. \(sQID\) represents multiplying the master private key \(s\) with the point \(QID\) on the elliptic curve group \(G1\).</p>
<p>The decryption key \(dID\) is obtained by multiplying the master key s with the user public key \(QID\) on the elliptic curve group.</p>
</blockquote>
<br>
<p>In vetIBE, the subnet as a whole takes the PKG's place. Nodes threshold sign the user ID, and the resulting signature when reaching the threshold is the decryption key for that ID. Multiple nodes jointly generate the master key, and use DKG to share splits of the master key. (This is also how subnets generate consensus and random numbers using BLS threshold signatures).</p>
<p><strong>Users encrypt files with their ID and the subnet's public key, and decrypt with the BLS threshold signature as the decryption key for that ID.</strong></p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724225257959.png" style="zoom:35%;" />
</div>
<p>But hold up, we've got an issue here - if nodes just sign the ID with their private key splits then shoot that back to users raw, that ain't secure. Hackers could snatch enough signature shards to equal the decryption key for that ID! So we can't have nodes sending back signature pieces in the clear. Time to slap on another layer of public key encryption!</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724230423204.png" style="zoom:37%;" />
</div>
<p>We can solve this security issue by having the user generate a temporary transport key pair: Before initiating the request, the user directly generates a transport key pair (tsk, tpk). Then they initiate the key derivation request, sending the transport public key tpk, user ID to the subnet. Each node in the subnet signs the ID, then encrypts the signature shard using the user's transport public key, and sends it back to the user. Upon receiving the encrypted signature shards, the user first decrypts them using their own transport private key to obtain the signature shards. Then they combine the signature shards into the complete signature (decryption key) to decrypt the file.</p>
<br>
<p>So let's recap the encryption/decryption flow: </p>
<p>The basic idea of vetIBE is that the user first encrypts the information, then stores it on the blockchain.</p>
<p>When a user needs to encrypt a file, they encrypt the file using the user ID and subnet public key mpk. Then they store the ciphertext in the Canister.</p>
<p>When a user needs to decrypt a file, they first generate a transport key pair (tpk, tsk). Then they initiate the key derivation request, sending tpk, ID to the nodes.</p>
<p>Each node uses its private key shard ski to compute the BLS signature shard for the ID: œÉi = H(id)^ski.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724231525509.png" style="zoom:40%;" />
</div>
<p>Then each replica encrypts its own signature shard using the transport public key tpk, generating an encrypted signature shard eki, and sends it to the user.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724232122118.png" style="zoom:39%;" />
</div>
<p>The user receives t encrypted signature shards from t different replicas, and then decrypts them individually using the transport private key tsk to obtain t signature shards. The user combines these to produce the subnet's signature œÉ on the ID. This œÉ is the decryption key corresponding to the ID.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724234850400.png" style="zoom:67%;" />
</div>
<blockquote>
<p>The specific encryption process is:</p>
<p>The user calls the interface, inputting the identity ID and plaintext message \(m\).</p>
<p>Invoke the hash function, perform hash operation on ID \(h = H1(id)\), obtaining value h.</p>
<p>Choose a random number \(s\), compute \(t = H2(s, M)\), where H2 is another hash function.</p>
<p>Compute \(C1 = g2^t\), \(C2 = s ‚äï H3(e(H1(id), mpk)^t) = s ‚äï H3(e(h, mpk)^t)\), \(C3 = M ‚äï H4(s)\). The ciphertext is \(C = (C1, C2, C3)\).</p>
<p>With vetKD, now each subnet is a &quot;decentralized PKG&quot;!</p>
</blockquote>
<p>We call the derived keys vetKeys.</p>
<br>
<p>So in vetIBE, the user does not have a fixed public key, but instead temporarily generates a transport public key tpk as needed. Then they obtain the decryption key through the nodes' collaboration. The user ID and tpk together serve as the &quot;identity&quot; for deriving the decryption key, but the user does not have a fixed key pair.</p>
<p>As the name implies, the transport public key is used to encrypt the transmission of the signature shards!</p>
<br>
<h2 id="what-if-the-user-loses-the-transport-private-key-for-decryption"><a class="header" href="#what-if-the-user-loses-the-transport-private-key-for-decryption">What if the user loses the transport private key for decryption?</a></h2>
<p>Actually, the file is encrypted using the subnet public key and ID. To decrypt the file, the key derived by the subnet based on the ID is needed (the BLS signature), not the transport key. The transport key is only used to ensure the security of the signature shards.</p>
<p>So as long as a new transport keypair is generated again, and sent to the subnet to encrypt the signature shards with this new transport public key, a new BLS signature can be derived. The user can decrypt and obtain the BLS signature plaintext with the new transport private key, and thus decrypt the file.</p>
<br>
<p>The user does not need to store the private key locally, and can acquire the key anytime with a new transport public key.</p>
<p>Compared to local key storage solutions, this blockchain assisted derivation mechanism can better ensure availability for users. As long as the user ID exists, the file can be decrypted. And the security of the user's ID can also be guaranteed by ii (Internet Identity).</p>
<br>
<h2 id="what-should-the-user-do-if-they-want-to-decrypt-the-file-on-another-device"><a class="header" href="#what-should-the-user-do-if-they-want-to-decrypt-the-file-on-another-device">What should the user do if they want to decrypt the file on another device?</a></h2>
<p>There is a solution. Similarly, log in to the dapp with ii to acquire the ID. Then generate a new transport keypair! You know what to do next üòè.</p>
<br>
<h2 id="how-can-end-to-end-encrypted-communication-be-achieved-then"><a class="header" href="#how-can-end-to-end-encrypted-communication-be-achieved-then">How can end-to-end encrypted communication be achieved then?</a></h2>
<p>It's very simple with vetIBE technology:</p>
<p>User A logs in to the dapp to acquire identity ID_A, and obtains the corresponding user decryption key, which is the BLS signature of ID_A: œÉ_A.</p>
<p>User B also generates their own ID_B and user decryption key: œÉ_B.</p>
<p>Now both User A and User B have their own public keys (IDs) and decryption keys (œÉ). User A can encrypt and send messages using the other party's ID.</p>
<p>User B decrypts with their own decryption key œÉ_B to complete the communication.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230724235906579.png" style="zoom:50%;" />
</div>
<p>Hol' up...</p>
<p>You still worried it ain't secure? What if someone's device gets hacked and the hacker snatches the decryption key for that ID. Now using that ID to chat is busted. And since the decryption key for the ID is unique, it means the user's gotta change their ID and derive a new decryption key. Plus any previous messages sent could be cracked.</p>
<br>
<p>Dang, looks like I gotta bust out my ultimate signature move: <strong>Communication ID!</strong></p>
<p>Since the decryption key can be calculated from the ID and subnet, I'll just generate temporary communication ID for both parties. Encrypt everything with the pre-arranged IDs, and both sides can ask the subnet to derive the keys.</p>
<br>
<p>For example:</p>
<p>Say A's crushin' on B and wants to chat privately. First they generate a communication ID using: A's ID + B's ID + the first message from A, then hash it all to get the communication ID.</p>
<p>A encrypts &quot;010&quot; using B's ID_B and sends it to B. (Could be a random number, doesn't matter as long as each message is unique).</p>
<p>Then A can generate the communication ID: sender ID + receiver ID + 010, hash it to get the communication ID.</p>
<p>B receives and decrypts using their derived decryption key to get 010. Then generates the communication ID using the same process.</p>
<p>Boom! üëå With the communication ID, both can now derive decryption keys through the subnet and chat freely. Sending love letters n' stuff.</p>
<div class="center-image">
    <img src="3.ChainKey/assets/VETKeys/image-20230725001611484.png" style="zoom:40%;" />
</div>
<p>It's secure cuz both sides encrypt with the communication ID. This keeps it locked down:</p>
<p>The communication ID is designed so only A and B can get the keys.</p>
<p>Only ciphertext travels, third parties can't decrypt.</p>
<p>The way the keys get made has built-in protections, so even if some nodes get hacked, the secrets stay secret. </p>
<p>Even if someone hacks device A or B, the private key won't leak directly. Decryption keys can be deleted after use instead of being permanently stored locally. This is more secure than traditional public-key encryption methods, where users must always store their private keys locally. You just need a new comm ID, and you can re-generate the comm ID private key through the subnet.</p>
<p>This keeps the transmission secure while also solving the issue of user devices being hacked. Compared to old school end-to-end encryption that just stores keys locally, the vetIBE system can get better hack resistance with the blockchain's help.</p>
<br>
<p>That covers vetIBE. The paper also mentions vetSIG, vetPRF, vetVRF - which combine into vetKD.</p>
<p>I've blabbed enough already lol, so I'll give the quick lowdown on the others! Lemme know if the casual tone and humor lands or needs adjustment.</p>
<br>
<h2 id="vetsig"><a class="header" href="#vetsig">vetSIG</a></h2>
<p>BLS signatures are inherently verifiable, so they can be directly used for signatures. vetBLS allows nodes to generate BLS signatures in encrypted form. The user can recover the signature upon receiving it, thus achieving vetSIG.</p>
<p>It's quite similar to vetIBE, except vetIBE derives a decryption key from an ID, while vetSIG simply uses a subnet's BLS threshold signature. </p>
<p>The steps are:</p>
<ol>
<li>
<p>The user generates \(tpk\), \(tsk\), and sends \(tpk\) to the nodes.</p>
</li>
<li>
<p>When a user wants the BLS signature of message \(m\), they send m and tpk to the nodes.</p>
</li>
<li>
<p>Each node uses its sk share to compute a signature share \(œÉi\) of \(m\), encrypts it with \(tpk\), and sends \(eki\) to the user. </p>
</li>
<li>
<p>The user receives t \(eki\)'s, decrypts to obtain the signature shares, and recovers the full signature \(œÉ\).</p>
</li>
<li>
<p>The user uses \(œÉ\) as the signature of \(m\) relative to public key \(pk\), thus achieving vetSIG.</p>
</li>
</ol>
<br>
<h2 id="vetprf"><a class="header" href="#vetprf">vetPRF</a></h2>
<p>The uniqueness of BLS signatures, combined with a hash function under a random oracle, can construct a PRF. vetBLS allows nodes to generate BLS signatures in encrypted form. The user recovers the signature and hashes it with the input to obtain the output, achieving vetPRF.</p>
<p>The steps are:</p>
<ol>
<li>
<p>The user generates \(tpk\), \(tsk\), and sends \(tpk\).</p>
</li>
<li>
<p>When a user wants to compute the PRF output for input \(x\), they send \(x\) and \(tpk\) to the nodes.</p>
</li>
<li>
<p>Each node computes a BLS signature share of \(x\), encrypts it, and sends to the user. </p>
</li>
<li>
<p>The user receives the encrypted shares, recovers the full signature \(œÉ\).</p>
</li>
<li>
<p>The user computes \(y = H'(pk,x,œÉ)\) as the PRF output on \(x\), thus achieving vetPRF.</p>
</li>
</ol>
<br>
<h2 id="vetvrf"><a class="header" href="#vetvrf">vetVRF</a></h2>
<p>Building on vetPRF, using the BLS signature as proof constructs a verifiable VRF. Verification is done by verifying correctness of the BLS signature. </p>
<p>The steps are:</p>
<ol>
<li>
<p>Based on vetPRF, the user wants to prove correctness of \(y\).</p>
</li>
<li>
<p>They send the signature \(œÉ\) as proof, along with \(y\) to the verifier.</p>
</li>
<li>
<p>The verifier checks \(e(œÉ, g2) = e(H(x), pk)\) to verify correctness of \(y\), thus achieving vetVRF.</p>
</li>
</ol>
<br>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>vetKD achieves secure and efficient threshold key derivation. Users do not need to generate and manage private keys themselves, making it very suitable for blockchain scenarios. vetKD is better suited as infrastructure for blockchain networks, providing unified key management and access control. It utilizes the security properties of blockchains to reduce the burden on users, and provides a more user-friendly and secure key management solution.</p>
<br>
<p>So what problems does vetKD solve exactly?</p>
<p>Specifically:</p>
<p>Through threshold encryption, vetKD allows blockchain nodes to collaboratively derive keys, without any individual node knowing the final key. There is no single point of failure, improving security. Even if some nodes are compromised, the actual private keys will not be directly revealed. Compared to traditional schemes, it does not rely on a trusted execution environment and has higher security. </p>
<p>Users can encrypt private data, nodes collaborate to decrypt the key and send it to the user, without revealing the actual key in the process. Moreover, a single subnet public key (master key) can derive unlimited separate identity keys, greatly simplifying key management. Various end-to-end encryption applications can also be enabled, such as private chat, private payments, and key escrow.</p>
<p>In summary, vetKD allows blockchain applications to protect user data privacy while retaining the verifiability and transparency of blockchains, filling an important gap in this field and having significant innovative value.</p>
<br>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-is-the-nns-for"><a class="header" href="#what-is-the-nns-for">What is the NNS for?</a></h2>
<p>As summarized when covering threshold cryptography in IC:</p>
<p><em><strong>The greatest innovation of the Internet Computer lies in its use of a series of complex cryptographic technologies. It has achieved self-consensus within the subnet, which can be perceived as a type of sharding technology. With chain-key cryptography, secure cross-subnet communication can take place between subnets. As it does not require global consensus across the entire network, the Internet Computer can achieve horizontal scalability by adding more subnets.</strong></em></p>
<p>Technically, IC can scale infinitely. More subnets can be added as needed. However, within each subnet, the membership is fixed when consensus is reached internally, because the BLS private key shards have already been distributed to the consensus committee members. Even if new replicas want to join a subnet, they have to &quot;wait in line&quot; until the next era starts before getting the private key shards. So for each subnet, membership needs to remain relatively stable, unlike Bitcoin where new miners can join anytime.</p>
<p>Additionally, IC's ability to keep creating subnets (shards) requires a place to keep track of all these subnets, otherwise bad actors could create fake subnets pretending to be part of IC. If subnets could be freely created, the cost of communication and trust between them would greatly increase, with layers of verification needed for every cross-subnet message. ÔºûÔ∏øÔºú </p>
<p>However, IC must also remain decentralized and open.</p>
<p><strong>So to enable massive computational capacity and ultra low-cost cross-subnet communication while preserving decentralization, IC chose a compromise - the DAO.</strong> If you are unfamiliar with what a DAO is, you can check <a href="5.NNS/DAO.html">here</a> first.</p>
<div class="center-image">
<img src="5.NNS/assets/NNS/image-20230708141930460.png" alt="img" style="zoom: 20%;" />
</div>
<p>After careful consideration, the Dfinity team decided to create a &quot;super subnet&quot; within IC called the system subnet. This subnet has the highest authority in IC, acting as the super admin: creating subnets, deleting subnets, adding new nodes to subnets, splitting subnets, upgrading subnet protocols, upgrading replica software versions, adjusting Cycles exchange rates, managing unique Canister IDs, user Principal IDs, public keys for each subnet, and other critical parameters of the entire IC blockchain system. These key settings are determined or voted on internally by the super admin.</p>
<p>This hybrid model of embedding a DAO at the base layer of a blockchain system is called a DAO-controlled network. The entire IC network runs under the DAO's control.</p>
<p>The DAO that governs the whole IC system has a cool name: the Network Nervous System (NNS). Critical parameters of IC are decided by a DAO, which is the entire IC community. The community can decide to scale up by adding more subnets when needed! üòé</p>
<p>Anyone can use their neurons staked in the NNS to propose expanding capacity. Once passed, the NNS automatically spins up new subnets to handle network load, all without any downtime. The scaling process is invisible to users and developers. This differentiates IC from traditional blockchains - IC's TPS can increase with more subnets, simply by adding shards! This gives IC similar capabilities to traditional networks, where TPS improves by adding more servers.</p>
<p>One thing to note though, a DAO isn't built overnight. A DAO can't instantly become decentralized. It requires a gradual process, slowly decentralizing, subtly and silently. Like Bitcoin was tiny and fragile initially, surviving crises and hard forks before becoming what it is today.</p>
<blockquote>
<p>Bitcoin had bugs like overflows, taking others' coins, etc</p>
</blockquote>
<p>The NNS is IC's super admin. If the major voting power of this DAO falls into bad actors' hands, the entire IC system is at risk, since the DAO is integrated at the base layer. The NNS subnet needs maximum security, so it has a very <a href="https://dashboard.internetcomputer.org/subnet/tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe">large number of nodes</a>, making it difficult for hackers to control enough nodes and ensuring the NNS subnet's underlying security.</p>
<div class="center-image">
<img src="5.NNS/assets/NNS/image-20230921102952706.png" alt="img" style="zoom:73%;" />
</div>
<p>Currently there are 40 node machines. If one fails, no biggie:</p>
<div class="center-image">
<img src="5.NNS/assets/NNS/image-20230921103600826.png" alt="img" style="zoom:67%;" />
</div>
<p>Deployed within the NNS subnet is a sophisticated engine: the DAO's smart contracts.</p>
<blockquote>
<p>Oh right, on IC smart contracts are virtual containers called Canisters. They're like Docker or Kubernetes containers, but for Wasm code instead of images or pods. Pretty futuristic! Check out this link to learn more about Canisters if you haven't already. They're pretty neat.</p>
</blockquote>
<p>I aimed to give the translation an authentic, conversational style that flows naturally for English speakers. I took a few liberties to inject some light humor around the comparisons to familiar technologies like Docker and Kubernetes, while staying true to the original meaning. Please let me know if you would like me to modify the translation at all - I'm happy to adjust the style and tone as needed.</p>
<h2 id="exploring-the-nns-internals"><a class="header" href="#exploring-the-nns-internals">Exploring the NNS Internals</a></h2>
<p>The NNS subnet currently has a total of 11 Canisters, which can be seen on the <a href="https://dashboard.internetcomputer.org/canisters?s=25&amp;subnet=tdb26-jop6k-aogll-7ltgs-eruif-6kk7m-qpktf-gdiqx-mxtrf-vb5e6-eqe">Dashboard</a>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Name</th><th style="text-align: center">Canister id</th><th style="text-align: center">Controller</th><th style="text-align: center">Function</th></tr></thead><tbody>
<tr><td style="text-align: center">NNS Registry</td><td style="text-align: center">rwlgt-iiaaa-aaaaa-aaaaa-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Registry</td></tr>
<tr><td style="text-align: center">NNS ICP Ledger</td><td style="text-align: center">ryjl3-tyaaa-aaaaa-aaaba-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">ICP token functions</td></tr>
<tr><td style="text-align: center">NNS ICP Archive</td><td style="text-align: center">qjdve-lqaaa-aaaaa-aaaeq-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Stores Ledger history</td></tr>
<tr><td style="text-align: center">NNS Governance</td><td style="text-align: center">rrkah-fqaaa-aaaaa-aaaaq-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Voting, neuron proposals</td></tr>
<tr><td style="text-align: center">NNS Lifeline</td><td style="text-align: center">rno2w-sqaaa-aaaaa-aaacq-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Controls Root Canister</td></tr>
<tr><td style="text-align: center">NNS Cycles Minting</td><td style="text-align: center">rkp4c-7iaaa-aaaaa-aaaca-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Converts ICP to Cycles</td></tr>
<tr><td style="text-align: center">NNS Genesis Token</td><td style="text-align: center">renrk-eyaaa-aaaaa-aaada-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Genesis neurons</td></tr>
<tr><td style="text-align: center">NNS Root</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai</td><td style="text-align: center">rno2w-sqaaa-aaaaa-aaacq-cai(Lifeline)</td><td style="text-align: center">Controls other NNS Canisters</td></tr>
<tr><td style="text-align: center">NNS Front-End Dapp</td><td style="text-align: center">qoctq-giaaa-aaaaa-aaaea-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Stores NNS front-end code</td></tr>
<tr><td style="text-align: center">NNS SNS-WASM</td><td style="text-align: center">qaa6y-5yaaa-aaaaa-aaafa-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">Records SNS information</td></tr>
<tr><td style="text-align: center">(NNS Identity)</td><td style="text-align: center">qhbym-qaaaa-aaaaa-aaafq-cai</td><td style="text-align: center">r7inp-6aaaa-aaaaa-aaabq-cai(Root)</td><td style="text-align: center">User identities</td></tr>
</tbody></table>
</div><br>
<h3 id="canisters-on-the-nns"><a class="header" href="#canisters-on-the-nns">Canisters on the NNS</a></h3>
<p>Their functions are all closely related to the operation of the system:</p>
<ol>
<li>Registry Canister: The registry canister. The entire system configuration of the IC is stored in this canister, such as which nodes belong to which subnet and the software version each node should run.</li>
<li>Ledger Canister: The ICP ledger canister. It stores the ICP balances of each principal id and the ICP transaction history.</li>
<li>Archive Canisters: Once the number of transactions is too large to be stored in a single canister, the transaction history is stored here.</li>
<li>Governance Canister: The governance canister. It receives and stores proposals, all of which are related to governing the IC network. The governance canister also tracks neurons to determine who can participate in governance voting.</li>
<li>Cycles Minting Canister: Responsible for burning ICP to mint Cycles. All Cycles on the IC are minted by this canister.</li>
<li>Root Canister: It is the controller of all other NNS Canisters and is responsible for upgrading them. The controller of a canister has the authority to delete the canister, upgrade the code, and stop the canister. However, the Root Canister cannot arbitrarily upgrade canisters, it must wait for the governance canister to vote through a proposal to upgrade a canister before calling the Root Canister to execute the upgrade.</li>
<li>Lifeline Canister: It is the controller of the Root Canister and is responsible for upgrading it. The only canister written in Motoko in the NNS. When there is a very serious bug in the Rust lower level libraries, this Motoko canister can be used to upgrade the Root Canister, and then the Root Canister upgrades other NNS canisters to recover the IC system.</li>
<li>Front-End Dapp: The NNS front-end canister.</li>
<li>Genesis Token Canister: Used to initialize neurons that existed before genesis. The governance recorded some neurons of investors, foundations, and early contributors.</li>
<li>SNS-WASM Canister: Manages SNS canister related content. It is responsible for creating, updating, and deleting SNS canisters. After voting approval, it installs the Wasm module into the canister of the SNS subnet.</li>
<li>User Identity Abstraction Canister: Records user identities.</li>
</ol>
<br>
<h3 id="registry-canister"><a class="header" href="#registry-canister">Registry Canister</a></h3>
<p>The most important canister is the Registry Canister.</p>
<p>It records all subnets on the IC, as well as the public keys of the subnets, BLS threshold signatures on the subnet public keys, various node information, Cycle prices, firewall configurations, etc.</p>
<p>New nodes must first submit their identity to the NNS, and then can join the subnet after voting approval. All replicas will monitor the Registry Canister to obtain the latest configuration. Each replica responsible for packaging blocks must also put the latest configuration into the block.</p>
<p>In any large distributed system, failures of individual nodes due to hardware failure, network connectivity issues or node operator decisions to take nodes offline are unavoidable. If this happens, the NNS will select a standby replica to replace the failed replica in its subnet. The new replica then joins the subnet and syncs state with the existing replicas by catching up on blocks, before participating in subnet consensus.</p>
<br>
<h3 id="ledger-canister-and-icp-tokens"><a class="header" href="#ledger-canister-and-icp-tokens">Ledger Canister and ICP Tokens</a></h3>
<p>The ICP token is managed by the Ledger Canister, which stores two things: accounts and transactions. Accounts track the number of tokens held by a particular principal (an authenticated identity on the IC). Tokens can then be sent from one account to another, which is recorded in the transactions of the Ledger Canister.</p>
<p>On the NNS, ICP has three uses:</p>
<ol>
<li>Anyone can purchase ICP, stake it to the NNS and participate in IC network governance. Staking and voting will yield ICP rewards.</li>
<li>Nodes that participate in governance and provide computing power will also receive ICP rewards.</li>
<li>ICP is convertible to Cycles, which is the fuel for canisters to perform computation, communication and storage.</li>
</ol>
<p>So you see, ICP is not a utility token directly integrated into the lower level system. ICP is a smart contract deployed on the NNS subnet, while Cycles is the system's utility token. But in any case, the smart contract on the NNS is the most important part of the entire blockchain system, and is equivalent to a lower level component supporting the operation of the IC (just deployed at the application layer from an architectural perspective).</p>
<blockquote>
<p>A deeper question: If a DAO is hacked and a large amount of ICP is controlled by hackers, can NNS voting be used to change ICP transaction records and forcibly refund stolen ICP?</p>
</blockquote>
<h3 id="governance-canister"><a class="header" href="#governance-canister">Governance Canister</a></h3>
<p>The Governance Canister is responsible for holding neurons and determining who can participate in governance. In addition, it stores proposals and related information, such as how many votes in favor, how many votes against, etc. If a proposal is adopted, the Governance Canister will automatically execute the decision, and no one can stop it. Finally, the Governance Canister will distribute rewards to the neurons that participated in voting and contributed to the decision making.</p>
<h3 id="defining-canister-ids-on-the-nns"><a class="header" href="#defining-canister-ids-on-the-nns">Defining Canister IDs on the NNS</a></h3>
<p>By the way, the Canisters in the NNS subnet should be the first Canisters deployed on the IC. The Canister IDs of these Canisters in the NNS are directly defined in the <a href="https://github.com/dfinity/ic/blob/master/rs/nns/constants/src/lib.rs">code</a>. The Canister IDs are generated from u64 type indexes, and Canisters can also be converted back to u64.</p>
<p>This code defines the basic information of each Canister in the NNS subnet, and is an important part of initializing the NNS subnet.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define the index of each Canister in the NNS subnet
pub const REGISTRY_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 0;
pub const GOVERNANCE_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 1; 
pub const LEDGER_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 2;
pub const ROOT_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 3;
pub const CYCLES_MINTING_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 4;
pub const LIFELINE_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 5;
pub const GENESIS_TOKEN_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 6;
pub const IDENTITY_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 7;
pub const NNS_UI_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 8;  
pub const SNS_WASM_CANISTER_INDEX_IN_NNS_SUBNET: u64 = 10;
pub const NUM_NNS_CANISTERS: usize = ALL_NNS_CANISTER_IDS.len();

// Define the ID of each Canister based on the index
pub const REGISTRY_CANISTER_ID: CanisterId = CanisterId::from_u64(REGISTRY_CANISTER_INDEX_IN_NNS_SUBNET);
pub const GOVERNANCE_CANISTER_ID: CanisterId = CanisterId::from_u64(GOVERNANCE_CANISTER_INDEX_IN_NNS_SUBNET);
pub const LEDGER_CANISTER_ID: CanisterId = CanisterId::from_u64(LEDGER_CANISTER_INDEX_IN_NNS_SUBNET);
pub const ROOT_CANISTER_ID: CanisterId = CanisterId::from_u64(ROOT_CANISTER_INDEX_IN_NNS_SUBNET);  
pub const CYCLES_MINTING_CANISTER_ID: CanisterId = CanisterId::from_u64(CYCLES_MINTING_CANISTER_INDEX_IN_NNS_SUBNET);
pub const LIFELINE_CANISTER_ID: CanisterId = CanisterId::from_u64(LIFELINE_CANISTER_INDEX_IN_NNS_SUBNET);
pub const GENESIS_TOKEN_CANISTER_ID: CanisterId = CanisterId::from_u64(GENESIS_TOKEN_CANISTER_INDEX_IN_NNS_SUBNET);
pub const IDENTITY_CANISTER_ID: CanisterId = CanisterId::from_u64(IDENTITY_CANISTER_INDEX_IN_NNS_SUBNET);
pub const NNS_UI_CANISTER_ID: CanisterId = CanisterId::from_u64(NNS_UI_CANISTER_INDEX_IN_NNS_SUBNET);
pub const SNS_WASM_CANISTER_ID: CanisterId = CanisterId::from_u64(SNS_WASM_CANISTER_INDEX_IN_NNS_SUBNET);
<span class="boring">}</span></code></pre></pre>
<br>
<h3 id="no-gas-on-nns"><a class="header" href="#no-gas-on-nns">No Gas on NNS</a></h3>
<p>The NNS is a system subnet where deployed Canisters are all related to the DAO and system operation. Developers cannot deploy Canisters on the NNS. So there is also no gas fee and no Cycles consumed on the NNS.</p>
<br>
<h2 id="nns-governance"><a class="header" href="#nns-governance">NNS Governance</a></h2>
<p>As a DAO, anyone can participate in voting to govern the network on the NNS without permission.</p>
<br>
<h3 id="introduction-to-neurons"><a class="header" href="#introduction-to-neurons">Introduction to Neurons</a></h3>
<p>Neurons are essentially the governance tokens of the NNS DAO.</p>
<p>By purchasing some ICP, sending it to the NNS wallet, and staking the ICP, you can obtain neurons. As a neuron holder, you can vote on proposals related to the IC network in the NNS, and also make proposals for others to vote on. The more ICP staked, the greater the voting power of the neuron. The longer the staking duration and the more votes cast, the voting power of the neuron will also increase. Of course, when the neuron matures, the additional ICP rewards received will be greater as well. To earn higher returns, neuron holders will tend to have their neurons participate in voting as much as possible to earn maximum voting rewards. At the same time, they will vote to support proposals that they believe will be most beneficial to the development of the IC network.</p>
<p>The system will distribute rewards in the form of additional ICP based on the &quot;maturity&quot; of the neurons (locked time). However, since the market price of ICP will fluctuate over time, the final returns of the neurons will also fluctuate.</p>
<p>If you don't know whether to vote in favor or against, you can also choose to follow a few neurons that you trust. When following other neurons, after the neuron votes, your neuron will cast the same vote. This way you don't have to open the NNS wallet to vote every day. Also, some proposals involve a lot of expertise and require analysis by experts in the community, which is difficult for ordinary people to decide on.</p>
<p>Neurons have the following key attributes:</p>
<ul>
<li>Utility tokens (ICP): These are the tokens used to create neurons. The amount of ICP locked in a neuron determines its base voting power.</li>
<li>Dissolve delay: This determines the time the ICP will be locked in this neuron account. The delay can be set at creation, e.g. 6 months or 1 year.</li>
<li>Maturity: This reflects the governance participation rewards earned by the neuron holder. Maturity can be reinvested into governance to gain more voting power, or withdrawn as ICP.</li>
</ul>
<p>Here are more details about neuron staking and voting rewards. You can use the staking calculator to estimate returns if you plan on staking some ICP.</p>
<p>Each proposal has a defined voting period. At the end of the voting period, if a simple majority votes in favor of the proposal and the votes in favor exceed 3% of the total voting power, the proposal will be adopted. Of course, if an absolute majority (over half of the total votes) votes in favor or against a proposal, the proposal will be immediately passed or rejected. After a proposal is rejected, the proposer will lose 10 ICP, a measure in place to deter junk proposals.</p>
<blockquote>
<p>Otherwise anyone could initiate all kinds of meaningless proposals</p>
</blockquote>
<p>Once a proposal is adopted, the Governance Canister will automatically execute the decision. For example, if a proposal proposes a change to the network topology and is adopted, the Governance Canister will call the Registry Canister to update the configuration.</p>
<p>For example, upgrading replicas through the NNS. First, an NNS proposal needs to be made (BlessReplicaVersion (#NodeAdmin)) to add a new replica version to the list. Then another NNS proposal is made to upgrade each subnet to the new version.</p>
<p>Once a proposal is adopted, the governance system will trigger an upgrade of the replicas in the subnet. The subnet's consensus layer will then autonomously decide when to execute the upgrade based on protocols between the nodes in the subnet:</p>
<p>These nodes have built-in support to download and apply upgrade packages without manual intervention.</p>
<p>The upgrade package contains the entire software stack required to run the nodes. After verifying the package contents correspond to the version the community voted to run, nodes will automatically restart into the new version.</p>
<h3 id="proposal-mechanism-on-the-nns"><a class="header" href="#proposal-mechanism-on-the-nns">Proposal Mechanism on the NNS</a></h3>
<p>ICP supports all kinds of proposal topics, not limited to one aspect. For example:</p>
<ul>
<li>Subnet management proposals: Consider changes in topology, such as adding or removing nodes.</li>
<li>Node management proposals: Regarding management of node servers, such as upgrading software versions.</li>
<li>Incentive mechanism proposals: Regarding profit distribution schemes of the blockchain.</li>
<li>Opinion collection proposals: No direct execution, just to record community sentiment.</li>
</ul>
<p>Next let's talk about the submission and processing flow for proposals:</p>
<p>Users who hold governance tokens (&quot;neurons&quot;) can submit proposals. To prevent proposal spam, a fee of 10 ICP must be paid during submission. This fee will be refunded if the proposal is eventually adopted, otherwise it will not be returned.</p>
<p>Let's say I control a neuron, and I want to propose adding two compute nodes, called Node1 and Node2, to a subnet. I can submit a proposal, specifying my neuron ID, proposal type, and the main content being the suggested new nodes, with parameters Node1 and Node2. The on-chain governance program will first verify that I do indeed own this neuron, and that this neuron has normal voting rights. After verification, my proposal will be formally submitted and added to the governance program.</p>
<p>A legally submitted proposal will be stored by the governance program. In addition, the governance program will also calculate and record related information about the proposal, such as the voting power each neuron has for this proposal, and the aggregated total voting power of the proposal.</p>
<p>When a new proposal is added, the &quot;votes in favor&quot; count will be automatically increased by the submitter's own voting power, indicating the submitter is considered to have voted in favor of their own proposal.</p>
<p>Each proposal also has a voting period that indicates the time period voting can take place for the proposal.</p>
<h3 id="how-can-voters-view-and-discuss-proposals"><a class="header" href="#how-can-voters-view-and-discuss-proposals">How can voters view and discuss proposals?</a></h3>
<p>All proposals and related information can be seen on ICP's official Dashboard. Community members can discuss governance proposals anywhere, and many important proposals will also have public discussions on developer forums.</p>
<h3 id="what-is-the-specific-voting-process"><a class="header" href="#what-is-the-specific-voting-process">What is the specific voting process?</a></h3>
<p>After a proposal is added to the governance program, other users with neurons can then vote on the proposal. Currently the most convenient way to vote is through an official voting Dapp. Before voting, users need to first understand the currently open proposals available for voting.</p>
<p>If a neuron casts a vote in favor for a proposal, its voting power will automatically be counted towards the proposal's &quot;votes in favor power&quot;. If it is a vote against, it will be counted towards &quot;votes against power&quot;.</p>
<p>To encourage more users to participate, neurons can also choose to delegate their votes to other trusted neurons for voting. This mechanism is called liquid democracy. If users don't have time to vote themselves, they can also follow other authoritative neurons to vote and obtain a certain reward.</p>
<h3 id="proposal-resolution-and-idle-mechanism"><a class="header" href="#proposal-resolution-and-idle-mechanism">Proposal Resolution and &quot;Idle&quot; Mechanism</a></h3>
<p>A proposal can be resolved in two ways:</p>
<ul>
<li>Before the end of the voting period, if more than half of the total voting power votes in favor, the proposal is adopted; if more than half of the total voting power votes against, the proposal is rejected.</li>
<li>When the voting period ends, if a majority voted in favor, and the votes in favor account for no less than 3% of the total voting power, then the proposal is adopted; otherwise, the proposal is rejected.</li>
</ul>
<p>In addition, the governance algorithm also employs an &quot;idle&quot; mechanism, which extends the voting period when the vote is relatively balanced, allowing more time for discussion. Specifically, if the outcome of a proposal flips from in favor to against, or vice versa, the proposal deadline will be extended. The initial voting period for a proposal is 4 days, and can be extended up to 4 days, so the voting period can be between 4-8 days.</p>
<p>Once a proposal is adopted, the method defined in it will be automatically called and executed on the specified Canister.</p>
<h3 id="voting-rewards"><a class="header" href="#voting-rewards">Voting Rewards</a></h3>
<p>Participating in governance and voting can not only influence network decisions, but neuron holders can also obtain voting rewards. The rewards will accumulate in the form of &quot;maturity&quot;.</p>
<p>Neuron holders have two ways to use maturity:</p>
<ul>
<li>Generate new neurons: The holder can choose to incubate a new small neuron to obtain ICP equivalent to the maturity amount. The new neuron only has a 7 day dissolve delay, allowing the ICP to be withdrawn in a short period of time.</li>
<li>Reinvest maturity: The holder can choose to reinvest the neuron, continuing to lock the maturity until the neuron fully dissolves. This part of the maturity will be added to the neuron and increase its corresponding voting power. When the neuron fully dissolves, this part of maturity will be released along with the principal.</li>
</ul>
<h3 id="how-to-avoid-51-attacks"><a class="header" href="#how-to-avoid-51-attacks">How to avoid 51% attacks:</a></h3>
<p>By design, most ICP is locked in neurons. Due to the dissolve delay, if an attack is initiated that damages the network, the price of ICP will be affected, resulting in significant value loss of the locked tokens.</p>
<p>In addition, the trading market for neurons can also have adverse effects. This is because attackers can cause panic leading to selloffs of neurons, allowing attackers to purchase large amounts of neurons on the cheap, negatively impacting network security.</p>
<h2 id="service-nervous-system-sns"><a class="header" href="#service-nervous-system-sns">Service Nervous System (SNS)</a></h2>
<p>Similar to how the IC is controlled by the NNS, decentralized applications deployed on the IC can also be controlled by a DAO. As mentioned earlier, the IC is like a cloud service, and Canisters deployed on it can be upgraded and have their code updated since they have controllers.</p>
<p>Currently, some Dapps are either controlled by the developer who deployed them, or are completely controller-less black hole Canisters. Neither situation is ideal. If a Dapp is controlled by a centralized development team, users have to completely trust the developers not to stop the Dapp or modify it in a way that benefits themselves. If a contract has no controller, then the Dapp cannot be upgraded at all and security vulnerabilities cannot be fixed, making data in it unsafe.</p>
<p>But don't worry, there is a third option - handing over control of the Dapp to a DAO, so the community can collectively decide the direction of the Dapp through an open governance mechanism. A DAO Canister controls the Dapp. This both protects users, since control is no longer in the hands of a few, and allows users to join governance and directly influence the Dapp's development.</p>
<h3 id="sns"><a class="header" href="#sns">SNS</a></h3>
<p>What's unique about ICP is that it can host fully on-chain Dapps (frontend, backend logic and data). Therefore the SNS DAO can fully control (via voting) all aspects of the Dapp, since everything is on-chain. Having a fully on-chain DAO is important because it allows all decisions to be executed on-chain. This contrasts with other blockchain DAOs, where voting happens on-chain but execution of outcomes is often done off-chain by developers.</p>
<p>ICP provides a DAO solution for Dapps to use called the Service Nervous System (SNS). During SNS creation, new tokens are minted and sold in a community-based fundraising. Control of the Dapp is transferred to the SNS, and anyone holding SNS tokens can contribute to decisions about the Dapp's future development.</p>
<p>Commemorative website for the launch of the first SNS project on IC: <a href="https://sqbzf-5aaaa-aaaam-aavya-cai.ic0.app/">https://sqbzf-5aaaa-aaaam-aavya-cai.ic0.app</a></p>
<h3 id="dao-and-open-source-projects"><a class="header" href="#dao-and-open-source-projects">DAO and Open Source Projects</a></h3>
<p><strong>&quot;Imagine building a Twitter-like application where the logic and data are not controlled by a centralized company, but by the smart contracts of a DAO!&quot;</strong></p>
<p>By adopting a DAO, control of these applications can be handed over to the token holders, the users. Whoever holds tokens has decision power. The community can collectively decide the direction of the application through voting, like which new features should be developed first, which are not needed, etc.</p>
<p>When developers update the code, they need to upload the latest code and submit a proposal containing the code hash, so anyone can view and audit the code. If there are no issues with the code, and the updated features are what the community wants, the proposal will likely pass. After the proposal passes the Canister will automatically update.</p>
<p>This is hugely important for users. The application is no longer at the mercy of a centralized dev team, real control is returned to users' hands. Except for the community all agreeing to take the application down, users can ensure the developers cannot unilaterally stop service, remove features or push malicious code updates. For developers, the DAO is also a good thing. It can attract more like-minded collaborators and bring more resources to the project. Developers no longer worry about users leaving, because the users are the owners of the project.</p>
<p>The DAO can also enable the application to be tokenized, issuing tokens for fundraising. Users can invest in the project by purchasing tokens, and the more valuable the tokens become, the more incentive users have to support the project. Moreover, code must be openly auditable by the community before deployment, which implicitly furthers the development of open source projects. Open source projects can raise funds through DAOs!</p>
<p>DAO enables true decentralized governance and empowerment for blockchain applications. It gives users, rather than developers, ultimate control. It can be said that DAO represents the best practice of the blockchain ethos, representing a future where blockchain technology empowers users and communities.</p>
<br>
<p>More on SNS:</p>
<p>SNS FAQ answering various questions: https://internetcomputer.org/sns/faq</p>
<p>How to participate in SNS: https://wiki.internetcomputer.org/wiki/SNS_decentralization_swap_trust</p>
<p>SNS docs: https://internetcomputer.org/docs/current/developer-docs/integrations/sns</p>
<div style="break-before: page; page-break-before: always;"></div><img src="5.NNS/assets/DAO/1.jpg" alt="img" style="zoom:35%;" />
<h1 id="the-allure-and-potential-of-daos"><a class="header" href="#the-allure-and-potential-of-daos">The Allure and Potential of DAOs</a></h1>
<p>Decentralized autonomous organizations (DAOs) - just say it out loud. Dig into what those words really mean: ‚Äúdecentralized‚Äù, ‚Äúautonomous‚Äù, ‚Äúorganization‚Äù. </p>
<ul>
<li>
<p>‚ÄúDecentralized‚Äù means no fixed ‚Äúcenter‚Äù or authority, like a CEO or government. In a DAO, decisions are made collectively by all participants, not dictated by a central power.</p>
</li>
<li>
<p>‚ÄúAutonomous‚Äù refers to self-governing. In a DAO, participants can establish their own rules and determine their own actions without outside command or control.</p>
</li>
<li>
<p>‚ÄúOrganization‚Äù means a collective with shared goals, like a company, team, or community.</p>
</li>
</ul>
<p>Put together, a DAO is a centerless, self-directed collective unified by shared objectives and values, where participants coordinate through blockchain technology.</p>
<p>The birth of Bitcoin in 2008 started the blockchain revolution. But Bitcoin's capabilities were limited, mainly transferring and storing value. In 2013, Vitalik Buterin conceived Ethereum, introducing smart contracts, enabling complex applications on blockchains, and making DAOs possible.</p>
<h2 id="daos---a-radical-new-social-experiment"><a class="header" href="#daos---a-radical-new-social-experiment">DAOs - A Radical New Social Experiment</a></h2>
<p>A DAO is simply an organization that runs on blockchain smart contracts. </p>
<p>But what can blockchains do? Take a company, which relies on a hierarchical leadership to operate. You can think of a DAO as a company without bosses, management, or even a physical office. A DAO is entirely run by people with shared goals and values. Sounds a bit utopian, but that's the basic idea of DAOs. They are purely virtual, running on blockchain technology.</p>
<p>With no management, how do DAOs function? This is where DAOs get funky. They rely on smart contracts - pre-programmed, self-executing code - to manage operations. A DAO is a completely transparent system, with all decisions based on programming languages and algorithms, not human discretion. This means all rules and decision flows are visible to anyone, each member has voting power to decide the DAO's direction, and no one can secretly change rules or make unilateral calls. </p>
<p>You can also think of a DAO as a souped up voting mechanism where decisions depend on member votes. </p>
<p>By encoding rules into smart contracts on blockchains, the tamper-proof, decentralized, self-executing properties of blockchains enable autonomy. Don't worry if you're hazy on blockchains - just think of them as public, unalterable ledgers that record transactions and events. This ensures transparency and fairness.</p>
<p>Smart contracts are the engine of DAOs - programs that automatically execute when conditions are met. Like a vending machine, insert enough coins and select an item, it automatically dispenses your selection. </p>
<p>DAOs essentially codify rules into &quot;vending machines&quot;, except decentralized across blockchains instead of contained in one machine vulnerable to destruction. </p>
<p>In a DAO, smart contracts may automate voting, allocation of funds, or other key decisions based on member votes. </p>
<p>The core idea is to let an organization's members (typically token holders) directly participate in decision-making, rather than delegating authority to a centralized governing body. </p>
<p>Here's how DAO governance typically works:</p>
<ol>
<li>
<p><strong>Tokens</strong>: DAOs usually have one or more tokens. Tokens can represent voting power but may also enable access to services or other functions.</p>
</li>
<li>
<p><strong>Proposals</strong>: Members (or sometimes specialized members) can submit proposals on various issues, from adjusting parameters to changing governance rules or determining the organization's direction. </p>
</li>
<li>
<p><strong>Voting</strong>: Once a proposal is submitted, token holders vote on it. Typically each token counts as one vote, but depends on the specific DAO structure.</p>
</li>
<li>
<p><strong>Execution</strong>: If a proposal gets enough support (the threshold depends on the DAO rules), it passes and is executed. In many DAOs this is automated via smart contracts.</p>
</li>
</ol>
<h2 id="makerdao---a-prominent-dao-example"><a class="header" href="#makerdao---a-prominent-dao-example">MakerDAO - A Prominent DAO Example</a></h2>
<p>MakerDAO is a project on the Ethereum blockchain aiming to generate a stable, decentralized currency - DAI - without intermediaries. </p>
<p>Here are some key aspects of MakerDAO:</p>
<p>DAI Stablecoin System: MakerDAO's primary product is DAI, a stablecoin pegged to the US Dollar generated through smart contracts and collateral (other cryptocurrencies) to maintain a stable value.</p>
<p>Decentralized Decision-Making: MakerDAO's governance structure is a core feature. MKR token holders have voting power to determine system critical parameters like stability fees, influencing DAI's economic mechanisms.</p>
<p>Open Source and Transparent: MakerDAO is open source, meaning anyone can view its smart contract code to improve transparency. </p>
<p>Risk Management: Since DAI relies on collateral, MakerDAO's stability and security depends on the value of this collateral. MKR token holders vote on risk parameters for collateral to manage this exposure.</p>
<p>MakerDAO's design and execution demonstrate a leading example of how DAOs can leverage blockchain technology and crypto-economic forces to create and manage decentralized financial products. However, like all crypto projects, MakerDAO faces many challenges including smart contract security, market volatility, and efficiency and fairness of governance.</p>
<h2 id="the-fog-ahead-for-daos"><a class="header" href="#the-fog-ahead-for-daos">The Fog Ahead for DAOs</a></h2>
<p>Of course, it's not all rainbows and unicorns for DAOs. Many open questions remain, like how to design fair and efficient decision-making mechanisms? How to prevent manipulation by minorities? How to protect privacy and security of participants? If a DAO's decisions cause harm, who should be responsible? These are critical points to ponder.</p>
<p>Basing decisions purely on votes can lead to &quot;tyranny of the majority&quot; problems. If a majority group dominates membership, they may control all decisions while minority groups are ignored.</p>
<p>Although smart contracts are automated, they still need to be written and maintained by humans. Flaws or exploits could severely impact a DAO.</p>
<p>The failure of &quot;The DAO&quot; project in 2016 was a wake-up call. As the first major DAO initiative, vulnerabilities in its code enabled substantial funds to be stolen, ultimately dooming the project. The episode sparked deeper examination of DAO security and governance structures.</p>
<p>Despite the challenges, the potential of DAOs is immense. They offer a fair, transparent, and efficient organizational form that could fundamentally change how we view companies and organizations. Although nascent globally, as blockchain technology progresses, we may see more DAO adoption. It will be exciting to watch how DAOs address their obstacles to achieve their ideals of fairness, transparency, and efficiency by empowering all members in decision-making.</p>
<h2 id="looking-ahead"><a class="header" href="#looking-ahead">Looking Ahead</a></h2>
<p>There's no doubt DAOs represent intricate, cutting-edge concepts that could profoundly impact how we organize. However, like any new technology, DAOs need time and effort to resolve problems.</p>
<p>Decentralized self-governance may seem foreign to many, but as technology advances, we may see DAO integration into our lives. DAOs could transform how we work, making decisions more open and democratic.</p>
<p>DAOs embody not just technology but a culture, a philosophy, advocating for equitable, transparent, decentralized values. In the DAO realm, everyone has a voice and is heard. This represents a new social construct challenging and disrupting existing power structures.</p>
<p>While the road ahead remains foggy, the landscape is slowly illuminating, unveiling the next chapter in the DAO odyssey.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="introduction-to-the-icp-economic-model"><a class="header" href="#introduction-to-the-icp-economic-model">Introduction to the ICP Economic Model</a></h2>
<p>The ICP token economy includes aspects like token supply, distribution, use cases, and mechanisms to maintain network stability and encourage DAO participation.</p>
<p>Through a well-designed tokenomics model, IC aims to create a sustainable ecosystem that encourages participation, growth, and trust in the network by developers, DAO participants, node providers, and Dapp users.</p>
<h3 id="design-intent"><a class="header" href="#design-intent">Design Intent</a></h3>
<p>The ICP tokenomics was designed to balance the following goals and constraints:</p>
<ul>
<li>Developers pay extremely low and stable costs for storage and computation.</li>
<li>Node provider rewards need to be high enough to incentivize them to join and serve the network.</li>
<li>Governance voting rewards need to strike a balance - encourage users to stake ICP and participate in governance while keeping inflation in check.</li>
<li>This is a dynamic system. The community needs to closely monitor system conditions and adjust various parameters of the ICP economy via NNS proposals for continual evolution and optimization.</li>
</ul>
<h3 id="use-cases-of-icp"><a class="header" href="#use-cases-of-icp">Use Cases of ICP</a></h3>
<p>To understand IC's economic model, one must first understand the various use cases of ICP. As the native utility token of the ICP blockchain, ICP has the following primary uses:</p>
<ol>
<li>
<p>Rewards for node providers</p>
<p>Node providers supplying computing and storage infrastructure for the ICP blockchain can earn ICP rewards. Each node receives a fixed amount every month, computed in fiat terms but paid in ICP. This model ensures node provider costs remain stable in fiat terms. Rewards vary slightly to encourage geographic distribution of nodes globally. As long as they provide quality service, node providers can continually earn these rewards. Rewards are paid through minting new ICP, leading to inflationary pressure.</p>
</li>
<li>
<p>Staked in the NNS</p>
<p>ICP holders can stake (lock up) their tokens to spawn governance neurons. Holding neurons gives them voting power via IC's chain-based open governance system NNS. The NNS allows neuron holders who staked ICP to vote on proposals to upgrade blockchain protocol, node software, accept new node providers, etc. The NNS implements liquid democracy - neurons can choose to follow other influential neurons. Neuron holders participating in governance voting earn ICP rewards from the blockchain protocol. Rewards are earned in maturity, convertible to ICP. This conversion is regulated by the NNS to control inflation.</p>
</li>
<li>
<p>Fuel for computation</p>
<p>Computation and storage resources consumed by canister smart contracts running on the ICP blockchain need to be paid for by burning ICP-generated &quot;Cycles&quot;. These Cycles are somewhat analogous to &quot;gas&quot; in Ethereum. However, ICP uses a &quot;contract pays&quot; model where contracts pre-load themselves with Cycles versus users paying for contract usage. Cycles are produced by burning ICP, causing deflationary pressure.</p>
</li>
<li>
<p>Fees for transactions and proposals</p>
<p>When users transfer ICP between wallets on the IC network, a small portion of ICP is paid as the on-chain transaction fee. Users also pay an ICP fee when submitting proposals to the governance system. These fees are acquired through burning ICP, producing deflation.</p>
</li>
</ol>
<h3 id="total-token-supply"><a class="header" href="#total-token-supply">Total Token Supply</a></h3>
<p>The total supply of ICP is not fixed - it fluctuates based on preset inflation and deflation mechanisms.</p>
<p>At mainnet launch on May 10, 2021, the total supply was 469 million ICP with 123 million ICP in circulation.</p>
<p>Currently (as of Sep 14, 2023), the total supply is 505.8 million ICP with 444.6 million ICP in circulation (87.5% of total supply).</p>
<ul>
<li>Staked ICP is 251.8 million ICP (49.8% of total supply)
<ul>
<li>81.8% of staked ICP chose unlocking delays longer than 1 year.</li>
<li>52.8% of staked ICP chose an 8 year unlocking delay.</li>
</ul>
</li>
</ul>
<blockquote>
<p>Circulation refers to ICP that has ever circulated. Part of it is locked in neurons as staked ICP.</p>
</blockquote>
<h3 id="icp-minting-and-burning"><a class="header" href="#icp-minting-and-burning">ICP Minting and Burning</a></h3>
<p>The NNS mints new ICP through:</p>
<ul>
<li>Staking ICP to participate in network governance.</li>
<li>Monthly rewards for node providers.</li>
</ul>
<p>The NNS burns ICP through:</p>
<ul>
<li>Burning ICP to mint Cycles to pay for computation and storage costs of smart contracts.</li>
<li>ICP transaction fees. Every ICP transfer on IC incurs a fixed 0.0001 ICP fee.</li>
<li>After rejecting an NNS proposal, the ICP submitted with the proposal is burned.</li>
</ul>
<p>Current circulating ICP and historical amounts minted and burned can be seen here. There is also a post on Dfinity research estimates for total ICP supply, if interested.</p>
<h3 id="governance-economics"><a class="header" href="#governance-economics">Governance Economics</a></h3>
<p>For governance, preventing any single party from acquiring 51% of voting power is critical. Even influencing vote outcomes without reaching 51% would be detrimental. Amassing such vast amounts of ICP would require huge capital, and these locked assets would also devalue if the network is attacked. So such an attack would be hugely unprofitable. Even malicious actors with deep pockets would find it hard to quickly acquire so much ICP from exchanges, since most are locked earning yields in neurons. This would force them to gradually accumulate over longer timespans, but the purchasing pressure itself would drive up prices, making subsequent purchases harder and harder.</p>
<p>Achieving 51% voting power without obtaining locked ICP is highly unrealistic. This is why the ICP network disallows neuron trading on markets. Because in times of market panic, malicious actors could compel holders to dump neurons cheaply and swiftly aggregate voting power. Of course, pulling off such an attack would be extremely difficult, but it does reflect the importance of prohibiting free neuron trading.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="what-is-canister"><a class="header" href="#what-is-canister">What is Canister?</a></h2>
<div class="center-image"> 
<img src="4.Canister/assets/Canister/image-20230918171556133.png" alt="img" style="zoom:33%;" />
</div>
<p>Inside a Canister there is something called WebAssembly (Wasm) bytecode that represents the program of the smart contract; there are also a set of memory pages that represent the state of the contract. A Canister is like a miniature server that can store data, maintain state, communicate over WebSocket, etc.</p>
<p>The memory pages are like a notebook for the contract. By installing or upgrading the computer, we can modify the Wasm bytecode. When we execute messages on a contract, the contract's state will change, as if we made edits in the contract's notebook.</p>
<p>Each Canister runs in a sandboxed environment, isolated from other Canisters and the rest of the system, ensuring privacy and integrity of data. Canisters execute via the WebAssembly (Wasm) runtime, which provides memory safety and type safety guarantees. Wasm also restricts the system calls a Canister can access, preventing malicious Canisters from performing harmful operations.</p>
<p>It's worth mentioning that currently many public blockchains like Ethereum, Polkadot, etc are considering transitioning to the Wasm virtual machine. Dfinity Foundation engineer Andreas, as the inventor, has participated in establishing most standards related to the Wasm VM.</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918204707755.png" alt="img" style="zoom:43%;" />
</div>
<p>WebAssembly is a virtual machine abstraction that provides a safe, portable, efficient, and lightweight execution environment. It enables fast cold start times in milliseconds and extremely low resource consumption. Existing programming languages like C/C++, Rust, etc. can be compiled to WebAssembly bytecode and executed in a sandboxed environment.</p>
<h2 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h2>
<p>WebAssembly (Wasm) is a universal code format that is efficient, portable, and supported by the open source community. Although it was initially designed for high-performance web applications, it is also well-suited for general-purpose computing. It is being widely used in web apps, client-server apps, blockchain apps, and more. As a faster, more efficient and portable code format, Wasm is key to building performant applications on the IC. Wasm is a stack-based virtual machine instruction format with a two-tiered design. In Dapp projects, the Wasm code for smart contracts is generated by compiling high-level languages like Rust and Motoko.</p>
<p>Wasm's portability and high performance have quickly made it one of the most popular code formats on the internet. Most high-level languages can compile to efficient, portable Wasm code. In addition to LLVM producing Wasm, popular languages like C/C++, Rust, Go, Java, JavaScript can efficiently compile to Wasm.</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918192150462.png" alt="img" style="zoom:37%;" />
</div>
<p>Wasm code can execute internally in browsers and also run in virtual machines with very little efficiency loss compared to native execution. For example, Cloudflare uses Wasm to provide ‚Äúserverless functions‚Äù, and advanced blockchains use it to run performant smart contracts.</p>
<p>Wasm is hardware and software agnostic, able to run in diverse environments with the goal of executing on stack-based virtual machines. Both browsers and standalone sandboxed processes can support Wasm execution via a VM. The Internet Computer utilizes the Wasmtime project to run user-defined Canister smart contracts with great performance.</p>
<p>Wasm code execution can easily be sandboxed for isolation. The Internet Computer leverages OS-level process isolation and sandboxing for protection. Each Canister compiles and runs Wasm code in its own sandboxed process, only communicating with the main process through secure, audited IPC. The sandbox is given the least privileges required to execute. Additionally, Wasm code can be formally verified.</p>
<p>Wasm has many advantages like formal specification, near-native performance, broad language support, evolving open source community, deterministic execution, and memory safety.</p>
<h2 id="diving-deeper-into-canisters"><a class="header" href="#diving-deeper-into-canisters">Diving Deeper into Canisters</a></h2>
<p>The IC is a revolutionary public blockchain that enables smart contracts to run directly on-chain in a secure and reliable way. On the IC, smart contracts exist in the form of Canisters. What are Canisters? They are computational units that bundle a smart contract's code and state together. Each Canister defines interfaces that can be called by other Canisters or users off-chain (via browser or app).</p>
<p>Multiple Canisters can communicate through asynchronous messaging. Each message execution is fully isolated, supporting massive concurrency. Additionally, a Canister smart contract can be upgraded - the controller (developer or other Canister) can update the Canister's code. </p>
<p>What's a controller? It is responsible for deploying the Canister to the IC, and can also control the Canister's start/stop, update the Canister's code, delete the Canister, etc.</p>
<p>A developer identity (dfx can generate multiple identities, i.e. principal ids) can act as a controller, controlling multiple Canisters. A Canister's controller can also add other controllers to the Canister.</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918191710205.png" alt="img" style="zoom:37%;" />
</div>
<p>To ensure smooth running of a Canister, the controller also needs to add sufficient Cycles to the Canister. Cycles are like Gas on the IC, used for the computational and storage resources required to execute the Canister. The subnet will monitor each Canister's resource consumption and deduct from its Cycles balance.</p>
<br>
<p>Although Canisters represent a huge leap over smart contracts, they are not the end goal. Canisters exist to enable a new generation of massively scalable, interoperable internet services. Everything we can build on the internet today can be rearchitected onto blockchains using Canisters. With close collaboration between potentially millions of Canisters, enormous decentralized networks can be built. </p>
<p>Services with billions of users may require thousands of Canisters collaborating to store and manage user data, serve content, execute transactions, etc. But this is the future the Internet Computer is designed for. Its network architecture and protocols are engineered for internet scale.</p>
<h3 id="user-access"><a class="header" href="#user-access">User Access</a></h3>
<p>Users can directly access Canisters using a browser or mobile app, no servers or command lines required. This is because the IC itself supports running web services. On the IC, tokens, smart contracts, databases, websites can all run directly inside a Canister. Decentralized apps are now truly decentralized, no longer relying on other centralized servers.</p>
<p>To ensure high performance of Canisters, the IC's servers are equipped with ample SSD storage and memory. Each Canister's state and code is replicated across nodes, allowing near instant access. State updates are verified via cryptographic signing by nodes. For isolation, each Canister runs in an independent sandbox. Every message spawns a Canister process to compile and execute code, update state, generate response, etc. Execution details are kept in the call context. This allows the Canister to run securely and reliably.</p>
<p>In summary, the Canister mechanism enables smart contracts to truly run in a decentralized, scalable, and secure way on a public blockchain. This will usher in a new era for blockchain applications. It is through Canisters that the IC becomes the first and only public blockchain capable of running web content and services at scale. No more clunky command lines and centralized servers - the future is here!</p>
<h3 id="external-user-authentication"><a class="header" href="#external-user-authentication">External User Authentication</a></h3>
<p>The IC does not have a centralized user registry to identify users. Before sending requests to subnets, users first generate a public-private key pair. The hash of the user's public key serves as their universal identifier (also called principal id) for identifying themselves to Canisters. </p>
<p>When sending messages to subnets, the message is signed with the private key. The signature and public key are then sent together to edge nodes, who verify the signature and pass the principal id to the target Canister. The Canister then approves the requested operation based on the principal id and other parameters specified in the message.</p>
<p>New users generate a key pair and derive their user identifier from the public key during their first interaction with the IC. Existing users authenticate using the private key stored in their client. Users can also delegate signing rights to associate multiple key pairs with a single user identity. This is useful for accessing the IC from multiple devices under the same identity.</p>
<p>In summary, the IC has users register identities via public key hashes and retain the corresponding private keys themselves. Each interaction is signed with the private key, automatically verified by the system via the signature and public key, identifying the source. New users register identities by generating key pairs, while existing users authenticate via their private keys. Thus decentralized user identity is achieved without centralized services. Pretty clever!</p>
<h3 id="actors"><a class="header" href="#actors">Actors</a></h3>
<p>Canisters follow the Actor model. State is not shared between containers and there are no state locks. Communication is used to coordinate transactions. Calls between Canisters are also asynchronous. Canisters can communicate but data is isolated - atomicity only exists within execution of a single method in a Canister.</p>
<p>In the Actor model, an Actor can modify its private state, send messages to other Actors, create new Actors, etc. The similarities between Actors and Canisters are very apparent:</p>
<ul>
<li>A Canister has private state that only it can modify.</li>
<li>It has single-threaded execution with no need for locking.</li>
<li>Canisters communicate via asynchronous message passing.</li>
<li>Canisters can create other Canisters.</li>
</ul>
<p>The core difference is that communication between Canisters is bidirectional with a request-response pattern. The IC handles callback of responses to callers.</p>
<p>In Actor terminology, each Actor has a mailbox address for receiving messages. Similarly, each Canister has a Canister id (fundamentally a type of principal id too) that allows Canisters and user interfaces to exchange messages.</p>
<p>Although individual Canisters have single-threaded state updates, the IC can massively parallelize execution across potentially millions of Canisters. This overcomes limitations of early smart contract platforms. Additionally, read-only queries can be parallelized internally in a Canister for huge scalability.</p>
<p>The Motoko language is directly inspired by the Actor model, providing a natural way to develop Canister logic.</p>
<h3 id="scalability"><a class="header" href="#scalability">Scalability</a></h3>
<p>On platforms like Ethereum, smart contract computation and storage are bundled together in a single unit - each smart contract handles its own data storage and logic. This makes horizontal scalability difficult. In contrast, the IC decouples computation (in Canisters) from storage (replicated across subnets). Storage and computation can scale independently.</p>
<p>This means, unlike monolithic smart contracts, Canisters can completely focus on computational logic while relying on the independent, persistent chain for data storage. If a Canister runs out of storage, additional Canisters can be created for storage. Or a &quot;parent Canister&quot; can be deployed solely for spawning Canisters - here's a demo project to try it out!</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918205247224.png" alt="img" style="zoom:42%;" />
</div>
<p>Canisters can also be dynamically instantiated and load balanced on demand. Internet Computer services can elastically scale to internet size, impossible on platforms bundling storage and computation.</p>
<p>Another key difference is that queries are read-only, allowing parallel execution. A Canister can handle potentially thousands of queries per second - overwhelming smart contract architectures. This unlocks use cases reliant on high query throughput and low latency, like serving interactive web experiences.</p>
<h3 id="query-calls-and-update-calls"><a class="header" href="#query-calls-and-update-calls">Query Calls and Update Calls</a></h3>
<p>In blockchain systems, every replica must reach consensus to update state - ensuring data consistency but inevitably introducing latency. If only querying state without modification, consensus can be skipped.</p>
<p>Each query call can be responded to autonomously by a single replica, like reading from a database, without going through consensus. This greatly reduces latency. Operations like viewing account balances or getting game leaderboards can leverage query calls. Query calls are like going to a restaurant and having the waiter immediately tell you what's on the menu, without needing to hold a staff meeting to decide!</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918202408934.png" alt="img" style="zoom:33%;" />
</div>
<p>Canisters expose two types of calls: <strong>update calls</strong> and <strong>query calls</strong>.</p>
<p>Update calls: create, update, delete. Modify in-memory data. Since they change data, consensus is required across subnets. Consensus necessitates <strong>single-threaded</strong> message handling, no concurrency.</p>
<p>Query calls: read. Each query call does a fast read of the node's current data. As no data is changed, no consensus is needed so <strong>multi-threaded</strong> execution is supported allowing concurrent handling. A Canister can process many query methods simultaneously.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Consensus?</th><th>Persistence?</th><th>Execution?</th><th>Latency?</th></tr></thead><tbody>
<tr><td>Update Call</td><td>Yes</td><td>Yes</td><td>Sequential</td><td>2-3 secs</td></tr>
<tr><td>Query Call</td><td>No</td><td>No</td><td>Parallel</td><td>&lt;100ms</td></tr>
</tbody></table>
</div>
<h3 id="certified-variables"><a class="header" href="#certified-variables">Certified Variables</a></h3>
<p>However, directly responding via query calls also poses security risks since a single replica is queried independently. If that replica is compromised by an attacker, incorrect results could be returned. Query results are also not recorded in consensus, so errors cannot be verified.</p>
<p>To address this, Dfinity introduced <strong>certified variables</strong>. Writes are automatically certified via subnet signatures. Anyone can verify the authenticity of these key data values using the subnet's public key. If a query call returns a certified variable's value, its trustworthiness matches update calls.</p>
<p>A Canister's certified variables are hashed and recorded in each round's certification state, which is consensus-based.</p>
<p>As part of each round's certification state, every subnet allocates a small set of bytes to record certified variables. Their values can be written via update calls, representing authoritative state that can be verified through the certification state mechanism each round.</p>
<p>Additionally, a Canister can use its certified variables to store the root of a Merkle tree. In this way, as long as a query call's response is a leaf node of the Merkle tree rooted at the Canister's certified variable, it can be verified.</p>
<p>This is like a restaurant menu listing original prices for dishes. The waiter tells you the discounted price. But with the original price printed as proof, you can verify the waiter's reply. This provides the low latency of query calls while still ensuring result integrity.</p>
<h3 id="canister-memory-management"><a class="header" href="#canister-memory-management">Canister Memory Management</a></h3>
<p>Canisters utilize two different types of memory. The first is heap memory, used as temporary data storage space. The second is stable memory, a larger pool for permanent data storage.</p>
<p>One is <strong>heap memory</strong>, the memory heap exposed by WebAssembly, similar to the heap used by programs at runtime. All variables and data structures defined in high-level languages are stored in the Wasm heap, which is a <strong>4 GiB</strong> 32-bit address space. However, the heap is best suited only as temporary space since it can be wiped clean on each smart contract upgrade. Data layouts may also change. Thus, it is not recommended to persist important data long-term in heap memory.</p>
<p>The other is <strong>stable memory</strong>, additional 64-bit addressable memory provided by the Canister, currently <strong>96 GiB</strong> in size. Developers must explicitly use stable memory via related APIs. Stable memory can be seen as persistent storage where developers can place data needing long-term retention. A common usage pattern is serializing heap state into bytes before and after upgrades and saving that to stable memory, then deserializing and loading it back in during recovery.</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918233748532.png" alt="img" style="zoom:37%;" />
</div>
<p>To enable orthogonal persistence and allow programs to resume after upgrades, Canisters employ some special mechanisms:</p>
<ol>
<li>Page protection - memory is split into 4KiB pages, with OS page protections enabling page faults on access to map persisted data into memory and track memory writes.</li>
<li>Heap delta - a persisted tree-like data structure tracks modified pages in memory.</li>
<li>Checkpoint files - every N block epochs a checkpoint file is generated to capture the current memory state.</li>
</ol>
<p>Additionally, the IC does some optimizations for performance:</p>
<ol>
<li>Memory map checkpoint files to reduce memory usage and read overhead.</li>
<li>Only track page modifications for update calls, not queries, accelerating queries.</li>
<li>Page prefetching on page faults, loading multiple pages to reduce faults and speed memory-intensive operations.</li>
</ol>
<p>Through this design, the IC provides developers a sophisticated memory management system combining orthogonal persistence, heap, and stable memory for seamless execution and data storage. Developers can write programs without worrying about persistence - the system automatically persists memory and recovers on failure. Various optimization mechanisms also ensure high performance. This reliable memory abstraction gives developers a foundation for building secure, reliable blockchain applications.</p>
<p>Under the hood, the IC system uses page protection, versioning, and performance optimizations to enable efficient memory handling.</p>
<p>You can learn more <a href="https://wiki.internetcomputer.org/wiki/IC_Smart_Contract_Memory">here</a>.</p>
<h3 id="inverse-gas-model"><a class="header" href="#inverse-gas-model">Inverse Gas Model</a></h3>
<p>We know Ethereum's high gas fees have long been lamented by users. But on the IC, the gas costs of running smart contracts are prepaid by developers, not users.</p>
<p>Accessing the internet should be free, as it is on Web2 - this dramatically lowers barriers for users and improves ease of use for applications.</p>
<p>The IC uses an inverse gas model where the costs of running Canisters (gas fees) are covered by the teams deploying the applications, by default. Of course, if each user needs to create their own Canister, the ability to top up Cycles can be added.</p>
<p>Gas consumed on the IC is called Cycles, obtained by burning ICP tokens. ICP can be one-way converted to Cycles. Cycles are stabilized algorithmically, pegged to 1 SDR (SDR can be seen as a stable unit calculated from a basket of fiat currencies). In addition to gas, Cycles will play a key role as a stablecoin and tradeable unit in the IC's future ecosystem.</p>
<p>Cycles Price Stability:</p>
<p>$$ 1\times\ 10^{12}\ cycles\ =\ 1\ SDR $$</p>
<p>(1 T Cycles is 1 Trillion Cycles. 1 TC is 1 T Cycles, where C is the abbreviation for Cycles.)</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230917152439549.png" alt="img" style="zoom:30%;" />
</div>
<p>A <a href="https://neutronstardao.github.io/constellationzh.github.io/4.%E5%AE%B9%E5%99%A8(Canister)/4.XRC.html">Canister</a> on the system subnet fetches price data from off-chain exchanges via HTTP out call to calculate how many Cycles can be exchanged for 1 SDR.</p>
<p>Each Canister has its own Cycles balance, and Canisters can send Cycles to each other.</p>
<p>Deploying a Canister initially requires a large amount of Cycles (minimum 0.1 Tcycles, default 3 Tcycles), but subsequent code updates consume very few Cycles.</p>
<p>If a Canister's Cycles become insufficient to sustain it for 30 days, the Canister enters a frozen state. After 30 days without recharging, the Canister will be deleted. Frozen Canisters cannot function normally - all calls will be rejected.</p>
<p>Through this inverse gas model, the IC removes the friction of gas costs for end users, improving mainstream adoption. The prepaid gas reserve also enables Canisters to run reliably without interruptions.</p>
<h3 id="random-numbers-provided-to-canisters"><a class="header" href="#random-numbers-provided-to-canisters">Random Numbers Provided to Canisters</a></h3>
<p>Random numbers are critical for many blockchain applications like gambling and lotteries that require unpredictable randomness. However, generating truly secure randomness has always been a huge challenge for deterministic distributed systems.</p>
<p>The IC solves this problem through a unique technical mechanism at its core - a component called the &quot;random tape.&quot; Each subnet generates a random tape during every round of the consensus protocol. It is a special digital signature that can seed a deterministic pseudorandom number generator.</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918211050335.png" alt="img" style="zoom:38%;" />
</div>
<p>The random tape has two key characteristics:</p>
<ol>
<li>It is unpredictable before generation. This ensures randomness.</li>
<li>The generation process does not introduce additional time delays. This ensures both efficiency and security.</li>
</ol>
<p>When a smart contract needs randomness, it can make a system call request. If the random tape for the next block has already been generated, the system will use it directly to seed and respond to the request. Since the random tape is generated synchronously during consensus, the call response is fast without impacting performance.</p>
<p>Per the first characteristic, we can ensure the random number is unpredictable at the time of request. Per the second, acquiring the random number generally won't cause extra latency.</p>
<p>This mechanism fundamentally resolves the conflicting requirements of deterministic execution and secure random number generation. It cleverly balances consistency of distributed state with the application's need for randomness.</p>
<p>Specifically, the random tape mechanism plays a crucial role in:</p>
<ol>
<li><strong>Ensuring randomness</strong> - each random tape is unpredictable before generation, providing a truly secure source of randomness for smart contracts.</li>
<li><strong>Efficient response</strong> - no additional latency introduced for random number generation, meeting performance requirements.</li>
<li><strong>Simple access</strong> - smart contracts just make a call to easily get randomness, very convenient.</li>
<li><strong>Self-consistent</strong> - deterministic algorithms generate consistent random numbers on each node from the random tape seed, preserving state consistency.</li>
<li><strong>Cryptographically secure</strong> - random tapes generated via BLS threshold signatures, resilient against prediction and manipulation attempts.</li>
</ol>
<h3 id="motoko"><a class="header" href="#motoko">Motoko</a></h3>
<p>Additionally, the IC needed a simple, safe language. The reason is simple - while the IC uses Wasm for smart contracts and is very open, programming languages with good Wasm support like C++ and Rust are relatively difficult for beginners.</p>
<div class="center-image">
<img src="4.Canister/assets/Canister/image-20230918212727579.png" alt="img" style="zoom:33%;" />
</div>
<p>The IC provides a purpose-built language called Motoko that embraces the IC's programming model and leverages unique blockchain capabilities. Motoko has a powerful type system, actor model, persistence support, asynchronous messaging, and other features, while also providing automatic memory management, generics, pattern matching and other modern language capabilities. This enables developers to write Canister smart contracts in a safe and efficient manner.</p>
<p>Learn more about Motoko <a href="4.Canister/./Motoko.html">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Motoko is ingeniously designed with clear goals to establish an easy-to-learn, easy-to-use, and powerful programming language tailored for application development on Internet Computer. It can be safely compiled to Wasm bytecode and deployed in Canisters.</p>
<p>It borrows the strengths in design from languages like Java, C#, JavaScript, Swift, Pony, ML, Haskell, etc, to provide programmers with an accessible and usable development tool. Its syntax style is similar to JavaScript/TypeScript, yet more concise than JavaScript.</p>
<br>
<p>Motoko contains the foresight and vision of its designers for the future. After gaining a deep understanding, you may be amazed by its elegantly concise syntax design.</p>
<p>Motoko pursues simplicity with understandable syntax to make it easy for average developers to get started. It perfectly supports the Actor model and is an excellent choice for writing distributed programs. It aligns closely with the execution models of WebAssembly and IC to maximize hardware performance. It also considers future extensibility needs by preserving compatibility.</p>
<p>Motoko is a class-based object-oriented language where objects are closures. Classes can be Actors.</p>
<p>Some other features:</p>
<ul>
<li>
<p>Async construct for direct style asynchronous messaging programming.</p>
</li>
<li>
<p>Structural type system, simple generics, and subtyping.</p>
</li>
<li>
<p>Overflow checking numeric types, explicit conversions.</p>
</li>
</ul>
<div class="center-image">
    <img src="4.Canister/assets/Motoko/1.png" alt="1" style="zoom:50%;" />
</div>
<p>So come check out Motoko's <a href="https://github.com/dfinity/motoko">source code</a> and <a href="https://github.com/dfinity/motoko-base">base library</a>! You can further dive into <a href="https://internetcomputer.org/docs/current/motoko/main/overview">Motoko docs</a>.</p>
<p>You can also directly deploy and test Motoko code through <a href="https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/">Motoko Playground</a> with just a browser webpage! It tremendously lowers the barrier of using Motoko and IC. Dfinity's Motoko team also frequently uses Playground to test simple Motoko code.</p>
<p>Also, Motoko's <a href="https://github.com/dfinity/vessel">package manager Vessel</a> is a very important part of the Motoko ecosystem. With just a few lines of config code, it helps developers pull in third-party libraries into their projects, or publish their own libraries for others to use.</p>
<p>Beyond the above, there is <a href="https://github.com/motoko-unofficial/awesome-motoko">more on Motoko in the community</a>.</p>
<br>
<h2 id="the-vision-of-internet-computer"><a class="header" href="#the-vision-of-internet-computer">The Vision of Internet Computer</a></h2>
<p>To fully understand Motoko's design philosophy and goals, we first need a brief overview of the Internet Computer project that drives its inception. The DFINITY Foundation is actively pushing forward this ambitious project, with the ultimate goal of building a &quot;World Computer&quot;, a distributed computing platform that is sufficiently powerful and open to everyone, which will provide the foundation for humanity to enter a more free and open digital civilization era.</p>
<p>In summary, the Internet Computer project aims to build a new kind of public computing infrastructure, similar to today's Internet, but with computing and data storage happening across many servers, instead of concentrated on servers in large data centers. This architectural difference brings tremendous decentralized advantages, making it inherently privacy-preserving, secure, and scalable.</p>
<p>To realize this grand vision, Dfinity needs technical innovation across layers from low-level network protocols to software ecosystem. And as the cornerstone of this layered innovation, a programming language tailored for this new platform is needed to provide direct development support for builders. Motoko comes into being, actualizing and practicing the core ideas of Internet Computer at the language level, providing crucial support to build the software foundation for this new world.</p>
<br>
<h2 id="motokos-design-philosophy"><a class="header" href="#motokos-design-philosophy">Motoko's Design Philosophy</a></h2>
<p>As a totally new built-from-scratch language, Motoko put some real thought into its overall design, with the goal of fully utilizing this language to develop for the brand spankin' new Internet Computer environment.</p>
<p>Motoko is a strongly-typed, actor-based language, with built-in support for orthogonal persistence and asynchronous messaging. Its productivity and safety features include automatic memory management, generics, type inference, pattern matching, and arbitrary and fixed precision arithmetic. Messaging is transparent, using Internet Computer's Candid interface definition language and wire format, enabling typed high-level cross-language interoperability.</p>
<p>Here are some of Motoko's core design philosophies:</p>
<ul>
<li>Actor-based: Motoko uses the Actor model as its core abstraction for concurrency and distributed programming. Actors are inherently concurrent and rock at asynchronous and parallel work. A Motoko program consists of multiple Actors. This model is fantastic for building distributed systems.</li>
<li>Supports asynchronous messaging: Actors primarily interact by asynchronously passing messages. This communication style works great for networks, avoiding blocking and waiting.</li>
<li>Built-in orthogonal persistence: Motoko greatly simplifies the complex problem of state persistence through language-level abstractions. Developers can ignore the details of saving and restoring state.</li>
<li>Designed for safety: Motoko strengthens various checks and protections in its type system, runtime, and concurrency control, significantly improving program robustness and security.</li>
<li>Multi-language interoperability: Motoko uses a universal interface definition language to enable safe interoperability between modules written in different languages.</li>
<li>Compiles to WebAssembly: Leverages WebAssembly's advantages including portability, security, and efficiency.</li>
</ul>
<p>As you can see, these design decisions closely match the architectural characteristics and application demands of Internet Computer, making Motoko the ideal language for developing apps on this brand new distributed platform.</p>
<h2 id="overview-of-motoko-language-features"><a class="header" href="#overview-of-motoko-language-features">Overview of Motoko Language Features</a></h2>
<p>In addition to the overall design philosophy, Motoko as a general purpose programming language also incorporates many excellent features and ideas from contemporary language design.</p>
<ul>
<li>Static type system: Provides compile-time type checking to catch some errors.</li>
<li>Automatic memory management: Compiler handles memory through reference counting garbage collection of unused objects.</li>
<li>Generics: Supports generics for increased code reuse.</li>
<li>Type inference: Compiler can infer most types, but type annotations sometimes needed.</li>
<li>Pattern matching: Support pattern matching on different types of values.</li>
<li>Immutability: Variables are immutable by default, use var to declare mutable variables.</li>
<li>Optional types: Optional types provided instead of null values.</li>
<li>Overflow checking: Runtime checks for integer overflows.</li>
<li>Concurrency safety: Actor message handling is atomic, maintaining atomicity within a function call.</li>
</ul>
<p>As seen from the above language features, Motoko draws the essence from decades of programming language theory and practice, incorporating many modern features that aid reliability and productivity.</p>
<h2 id="actor-model-and-asynchronous-handling"><a class="header" href="#actor-model-and-asynchronous-handling">Actor Model and Asynchronous Handling</a></h2>
<p>Actors are a core abstraction in Motoko, representing concurrently executing entities. A Motoko program consists of multiple Actors that interact via asynchronous message passing, with no shared state. Each Actor has its own private mutable state. Sending a message to an Actor does not block the sender, the Actor handles messages concurrently based on its state.</p>
<p>This message-passing based Actor model is great for building distributed systems. On Internet Computer, Actors compile to modules that can communicate across the network, called Canisters.</p>
<p>To make asynchronous programming more convenient, and allow it to be expressed in sequential &quot;direct style&quot;, another idea from programming language history and research was adopted in Motoko over 40 years ago, and fortunately has become more popular recently: Futures (also called promises in some communities), implemented in Motoko as &quot;async values&quot;, values of type &quot;async&quot; produced by expressions prefixed with the &quot;async&quot; keyword. Notably function bodies can be async expressions, naturally superceding the more singular &quot;async function&quot; concept present in some other languages.</p>
<p>With this, deductive styles can be async as long as their results are futures. Futures can be awaited to get their value, but again only inside another async expression, akin to async/await in other programming languages.</p>
<h2 id="orthogonal-persistence-abstraction"><a class="header" href="#orthogonal-persistence-abstraction">Orthogonal Persistence Abstraction</a></h2>
<p>For building distributed systems, saving and restoring state is a critical yet complex problem. Traditionally, developers have to handle checkpointing and recovery logic themselves. But Motoko provides &quot;orthogonal persistence&quot; abstraction at the language level, greatly reducing the work for developers.</p>
<p>Orthogonal persistence refers to the separation of concerns between state persistence and business logic.</p>
<p>Developers only need to focus on writing the application business logic, without worrying about saving and restoring state. This complex work is abstracted away, handled by the runtime in a transparent way.</p>
<p>Thus, business logic and state persistence as two crossing concerns are separated. Developers only need to focus on the former and can concentrate on the application's own functionality.</p>
<p>This abstraction allows developers to focus more on the application's business logic itself. The underlying platform transparently handles state persistence, restoring it when actors restart, without developers having to worry about those details.</p>
<p>How does Motoko achieve orthogonal persistence? The key is it provides an abstraction of an &quot;everlasting runtime&quot;.</p>
<p>For programmers, writing Motoko code feels like executing in an always-on runtime, where variables and state persist - no concept of program restarts.</p>
<p>Under the hood, the platform transparently persists state, and automatically restores it when actors restart, making execution continue as if nothing happened.</p>
<p>Technically, the platform tracks changes to actor mutable state, saving snapshots before each message handling, and restores on actor restarts. For immutable state, no special handling is needed.</p>
<p>Orthogonal persistence brings the following benefits:</p>
<ul>
<li>Developers can focus more on business logic without worrying about state persistence.</li>
<li>Avoids duplicate labor of writing checkpointing and recovery code.</li>
<li>State persistence code is centralized and optimized for efficiency.</li>
<li>Simplifies building complex distributed systems.</li>
<li>Lowers the bar for new developers.</li>
<li>Improves testability by confining tests to single runs.</li>
</ul>
<p>By providing the orthogonal persistence abstraction, Motoko greatly simplifies a key challenge in building distributed systems, a very clever language design innovation.</p>
<h2 id="multi-language-interoperability"><a class="header" href="#multi-language-interoperability">Multi-Language Interoperability</a></h2>
<p>Considering Internet Computer is an open environment where different teams may use their preferred languages, to enable smooth interoperation between modules written in different languages, Motoko adopts a universal interface description language Candid.</p>
<p>Each canister describes its exposed interfaces and message types in Candid. The Motoko compiler can automatically map these to internal Motoko types. Thus, canisters developed in different languages can interact through these shared interfaces while retaining type safety.</p>
<p>This cross-language interoperability mechanism is essential for an open distributed computing platform.</p>
<h2 id="webassembly-1"><a class="header" href="#webassembly-1">WebAssembly</a></h2>
<p>The ultimate target Motoko compiler generates is WebAssembly (abbreviated Wasm). Choosing Wasm as the target is a deliberate decision by Motoko designers, mainly based on the following considerations:</p>
<p><strong>What is WebAssembly</strong></p>
<p>WebAssembly is a future-oriented universal low-level bytecode format designed to be portable, secure, and efficient. Initially for web apps but applicable more broadly.</p>
<p>Wasm modules execute bytecode in a sandboxed environment agnostic of languages. The runtime uses a stack to execute instructions. Compared to VMs, Wasm is closer to hardware without language-specific optimizations.</p>
<p><strong>Why Choose Wasm</strong></p>
<p>Motoko chooses Wasm as compile target and canisters adopt Wasm mainly for:</p>
<ul>
<li><strong>Portability</strong>. Wasm runs on any platform supporting it, not dependent on specific languages or OS.</li>
<li><strong>Security</strong>. Wasm's sandboxed execution guarantees code safety isolation. Critical for blockchains and decentralized apps.</li>
<li><strong>Efficiency</strong>. Wasm has near-native execution efficiency, crucial for the performance-sensitive IC.</li>
<li><strong>Asynchronicity</strong>. Wasm has built-in support for async calls, suitable for the Actor model.</li>
<li><strong>Future-proofing</strong>. Wasm is evolving rapidly as an industry standard, pushed by major browser vendors, so choosing it is more future-proof.</li>
</ul>
<p>Choosing Wasm has advantages of:</p>
<ul>
<li>Ability to run cross-platform with excellent portability.</li>
<li>Sandboxed execution providing security guarantees.</li>
<li>Near-native execution efficiency critical for performance.</li>
<li>Built-in async call mechanisms suiting the Actor model.</li>
<li>As an evolving universal standard, Wasm has an optimistic future outlook.</li>
<li>Directly compiling Motoko to IC's target runtime code, technical alignment.</li>
</ul>
<p>Motoko's choice of Wasm as the compilation target is a very prudent design decision, leveraging Wasm's strengths to ensure Motoko's cross-platform portability, security, and efficiency. Enabling write once, run anywhere. Also increasing its industry impact. It is an exemplary engineering choice.</p>
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>Motoko is a brand new language meticulously built by Dfinity to provide programming language support for its radical Internet Computer project.</p>
<p>Motoko adopts innovative concepts like the Actor model, built-in orthogonal persistence in its overall design, and incorporates excellent features like static type checking, automatic memory management in the language itself. Motoko conducts extensive innovation across dimensions in its design, with the goal of reducing developer cognitive load so they can focus on building applications atop this futuristic distributed platform.</p>
<p>Although as a new language Motoko still has much work ahead, its ambitious vision is full of imagination for the future. Over time, Motoko will mature and eventually become a powerful tool for building the Internet Computer world.</p>
<p>Now with an understanding of Motoko, <a href="4.Canister/./DeployCanister.html">go ahead and try deploying your own canister!</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="experience-fast-dapp-development"><a class="header" href="#experience-fast-dapp-development">Experience Fast Dapp Development</a></h2>
<p>If you're interested, here is a small <a href="https://github.com/NeutronStarPRO/WeBlog">demo</a>. You can refer to the <a href="https://internetcomputer.org/docs/current/developer-docs/">official docs</a> to deploy locally and try it out, or deploy to the <a href="https://m7sm4-2iaaa-aaaab-qabra-cai.raw.ic0.app/">Motoko playground</a> to experience it. </p>
<br>
<p>After setting up the basic development environment, here are some concepts related to Canisters. </p>
<br>
<h3 id="canister-state"><a class="header" href="#canister-state">Canister State</a></h3>
<p>A canister has its own lifecycle with four states: Created, Running, Stopping, Stopped.</p>
<p>Created: No code, no memory, cannot receive or send messages.</p>
<p>Running: Code installed, can receive and send messages.</p>
<p>Stopping: No longer receives or processes new messages, only receives replies to previous messages.</p>
<p>Stopped: Stops running, canister can be deleted, code uninstalled or upgraded.</p>
<h3 id="wallet"><a class="header" href="#wallet">Wallet</a></h3>
<p>A wallet is a dedicated canister that allows storing and managing cycles. A wallet belongs to a principal.</p>
<h3 id="principal"><a class="header" href="#principal">Principal</a></h3>
<p>A principal is essentially an identifier that can be used to identify identities and canisters (possibly more in the future).</p>
<p>For example, a principal ID can identify an identity. When you first use the developer SDK, the dfx command line tool creates a default developer identity (with a key pair) - this default developer identity is identified by its Principal ID.</p>
<p>Note developer identities can also be used to derive Account IDs to represent &quot;identities&quot; that hold ICP tokens in the Ledger canister.</p>
<p>Similarly, a canister ID is also a principal.</p>
<p>So when referring to a principal, it could represent either an identity or a canister, like a wallet canister.</p>
<h3 id="controller"><a class="header" href="#controller">Controller</a></h3>
<p>A controller is a principal with the rights to install, upgrade, and delete a canister.</p>
<p>Typically a canister's controller can be set to an identity principal, or that identity's corresponding wallet canister.</p>
<p>In dfx 0.9 and later, the default identity is the controller of canisters by default, no longer the wallet canister (equivalent to dfx specifying --no-wallet).</p>
<h3 id="candid-ui"><a class="header" href="#candid-ui">Candid UI</a></h3>
<p>IC's application layer also integrates a message interface definition language and data format: Candid UI. When deployed, it can parse the public functions in the backend canisters and automatically generate a frontend webpage. This allows smart contract developers unfamiliar with frontends to easily test their contracts. It is used for typed, high-level, cross-language interoperability. This enables easy communication between any two canisters, even if written in different high-level languages.</p>
<p>The autogenerated Candid file looks like this. üëá Candid is a data description language and also a specification for cross-language calling. It can describe the interfaces and data types exposed by a canister.</p>
<div class="center-image">
<img src="4.Canister/assets/DeployCanister/image-20230221190505528.png" alt="image-20230221190505528" style="zoom:67%;" />
</div>
<p>After local deployment, it provides frontend and backend URLs. The frontend URL directly shows the frontend page, with the backend canister autogenerated by Candid UI.</p>
<div class="center-image">
<img src="4.Canister/assets/DeployCanister/image-20230221190800333.png" alt="image-20230221190800333" style="zoom:77%;" />
</div>
<p>The page generated by Candid UI looks like this:</p>
<div class="center-image">
<img src="4.Canister/assets/DeployCanister/image-20230221191148323.png" alt="image-20230221191148323" style="zoom:60%;" />
</div>
<p>Update call: Candid UI also simulates the actual latency of calling the IC, showing 6.59s in the bottom right corner. This function tells the canister to create a new canister to store the blog, which is time consuming.</p>
<div class="center-image">
<img src="4.Canister/assets/DeployCanister/image-20230221193245665.png" alt="image-20230221193245665" style="zoom:67%;" />
</div>
<p>Creating a blog post takes 2.116s, still decently fast.</p>
<div class="center-image">
<img src="4.Canister/assets/DeployCanister/image-20230221194229889.png" alt="image-20230221194229889" style="zoom:67%;" />
</div>
<p>Querying data takes 0.016s, blazing fast.</p>
<div class="center-image">
<img src="4.Canister/assets/DeployCanister/image-20230221194314126.png" alt="image-20230221194314126" style="zoom:80%;" />
</div>
<h3 id="canister-id"><a class="header" href="#canister-id">Canister id</a></h3>
<p>When creating a canister, the system assigns it a globally unique canister id. Edge nodes use the id to locate which subnet it is in, then forward messages there. Also, prepending the frontend canister id with the domain ic0.app forms the URL, e.g. <a href="https://zur5z-byaaa-aaaag-aaxeq-cai.ic0.app/">https://zur5z-byaaa-aaaag-aaxeq-cai.ic0.app</a> (my blog URL).</p>
<p><img src="https://neutronstardao.github.io/constellationzh.github.io/4.%E5%AE%B9%E5%99%A8(Canister)/assets/3.%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84Canister/1222.png" alt="img" /></p>
<p><img src="https://neutronstardao.github.io/constellationzh.github.io/4.%E5%AE%B9%E5%99%A8(Canister)/assets/3.%E9%83%A8%E7%BD%B2%E8%87%AA%E5%B7%B1%E7%9A%84Canister/image-20230221193009340.png" alt="image-20230221193009340" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="the-exchange-rate-canister-xrc"><a class="header" href="#the-exchange-rate-canister-xrc">The Exchange Rate Canister (XRC)</a></h2>
<p>The Exchange Rate Canister (XRC) is a powerful tool that can provide critical exchange rate information to various applications and businesses.</p>
<h3 id="who-are-you-xrc"><a class="header" href="#who-are-you-xrc">Who are you, XRC?</a></h3>
<p>If you're hearing about XRC for the first time, you may be a little confused. You might ask: &quot;What exactly is this XRC thing?&quot; Good question.</p>
<p>In short, XRC is a Canister running on the uzr34 subnet that mainly serves to provide exchange rate information to requesting Canisters. It's like a 24/7 exchange rate consultation advisor - whether you need rates for BTC/ICP, ICP/USD, or USD/EUR, it's there to serve you. And you can specify a timestamp to get the rate at that point in time. If no timestamp is provided, it will give you the current rate.</p>
<p>XRC acts as an on-chain exchange rate oracle, which is very useful for DeFi apps but can also add value to any application that needs exchange rate data.</p>
<p>The NNS Canister responsible for minting Cycles will use XRC to get the latest ICP/XDR rate, critical for converting ICP to Cycles.</p>
<h3 id="how-can-i-use-you-xrc"><a class="header" href="#how-can-i-use-you-xrc">How can I use you, XRC?</a></h3>
<p>&quot;This XRC sounds really cool, but how do I actually use it?&quot; Using XRC is very straightforward.</p>
<p>First, you need to know XRC's ID, which is uf6dk-hyaaa-aaaaq-qaaaq-cai. Then you can send it a request containing a base asset, a quote asset, and an optional timestamp.</p>
<pre><code>Copy codetype GetExchangeRateRequest = record {
   base_asset: Asset;
   quote_asset: Asset;
   timestamp: opt nat64;
};
</code></pre>
<p>After sending your request, XRC will reply with a result - either a successful exchange rate or an error message.</p>
<pre><code>Copy codetype GetExchangeRateResult = variant {
   Ok: ExchangeRate; 
   Err: ExchangeRateError;
};
</code></pre>
<p>Note your request must contain sufficient Cycles, otherwise XRC will return an error. In fact, the cost per call depends on the asset types requested and XRC's internal rate cache state.</p>
<h3 id="how-do-you-work-xrc"><a class="header" href="#how-do-you-work-xrc">How do you work, XRC?</a></h3>
<p>Now you may be curious how XRC actually works under the hood. After all, knowing how something operates allows you to better leverage it, right?</p>
<p>Upon receiving your request, XRC springs into action. It queries all supported exchanges to get the rate for your requested crypto assets against USDT. It then calculates a rate and caches it for next time.</p>
<p>If you request a crypto/crypto base-quote pair, XRC derives the B/Q rate from the queried B/USDT and Q/USDT rates.</p>
<p>In addition to querying exchanges, XRC also automatically retrieves FX rates from data providers, and polls rates for multiple stablecoins to infer a USD/USDT rate.</p>
<p>If successful, the response contains metadata in addition to the rate, which helps you determine the credibility of the returned rate.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="threshold-relay---an-elegant-on-chain-random-number-solution"><a class="header" href="#threshold-relay---an-elegant-on-chain-random-number-solution">Threshold Relay - An Elegant On-Chain Random Number Solution</a></h2>
<p>Whether in real life or in distributed systems like blockchain, random numbers are commonly used. In the realm of blockchain, the need for random numbers is particularly crucial.</p>
<p>In the underlying consensus protocols of blockchain, a random number is required to designate a leader for block creation. For example, in Ethereum's Beacon Chain, which utilizes a Proof of Stake (PoS) consensus, there are 36 slots in each epoch, with one block produced per slot (12 seconds). At the beginning of each slot, a validator is randomly selected from the validator set to be responsible for creating a block during that slot.</p>
<p>In higher-level applications, smart contracts also require random numbers for activities such as lotteries and dice rolling.</p>
<p>Additionally, the multiplication operations in some Multi-Party Computation (MPC) protocols rely on random number sources to generate arrays.</p>
<br>
<p>Therefore, providing a reliable source of random numbers for a group of participants is a critical issue that needs to be addressed.</p>
<br>
<h2 id="unpredictable-and-non-bias"><a class="header" href="#unpredictable-and-non-bias">Unpredictable and Non-Bias</a></h2>
<p>In a blockchain system, the first thing to ensure is that each member receives the same random number.</p>
<p>Secondly, it also needs to be reliable, meaning that the random number is unpredictable and non-bias:</p>
<ul>
<li>
<p>In the case where an adversary has both historical information and current information, it should still be impossible to predict future random numbers. </p>
<p>It is not acceptable for a malicious adversary to predict future random numbers, even if they can influence and predict a random number three rounds later by their current influence.</p>
</li>
<li>
<p>Non-bias can also be understood as destructiveness. That is, a malicious adversary cannot interfere with the random number generation process. For example, if an adversary manipulates the last few bits, causing damage to the original random number, it is considered insecure.</p>
</li>
</ul>
<p>In other words, no valid information should be extractable from different inputs.</p>
<br>
<h2 id="threshold-relay"><a class="header" href="#threshold-relay">Threshold Relay</a></h2>
<p>The scheme of using BLS threshold signatures to generate random numbers is a simple and practical approach. (Of course, BLS threshold signatures require a <a href="6.InternetServices/../3.ChainKey/Chainkey.html#nidkg">DKG protocol</a>, which is a disadvantage, but on the IC, the NIDKG has addressed this issue, so the rest is quite straightforward ~)</p>
<p>On the IC, there is a <a href="6.InternetServices/../3.ChainKey/Chainkey.html#summary-blocks">random beacon committee</a>, and the members of the committee are responsible for generating a random number in each round. The committee members are changed after each epoch, and the committee consists of a subset of all nodes in the subnet.</p>
<p>The committee can ensure that the performance does not degrade significantly when there are a large number of nodes in the subnet. The performance of the subnet is related to the number of nodes participating in the consensus; more nodes lead to increased communication and computation overhead.</p>
<p>The method of generating random numbers is also simple‚Äîby signing a message.</p>
<p>Let's consider generating a key pair first. <strong>Using a private key to sign a message results in a unique signature, given that the private key and the message are fixed.</strong> </p>
<p>Moreover, before the signature is produced, no one knows what the signature will be.</p>
<blockquote>
<p>Of course, if the private key is compromised, others can use it to sign the message and, therefore, learn the signature content in advance.</p>
</blockquote>
<div class="center-image">
<img src="6.InternetServices/assets/RandomNumberOnChain/image-20240206202852997.png" style="zoom:57%;" />
</div>
<p>While threshold signatures do not have a unique private key, each member independently computes a signature fragment using their private key share. These signature fragments are then collected through broadcasting, and once a sufficient number is gathered, the signatures are synthesized.</p>
<p>Hence, even the members responsible for signing cannot predict the signature outcome and cannot interfere with the signing process. Only with the aggregation of signature fragments is the result known. Subsequent signatures require nodes to broadcast new signature fragments in the next round to complete the entire signature and obtain the random number.</p>
<p>Assuming a total of 7 members with a threshold of 5, even if 2 members refuse to sign, it does not affect the generation of the signature.</p>
<div class="center-image">
<img src="6.InternetServices/assets/RandomNumberOnChain/image-20240206203127386.png" style="zoom:57%;" />
</div>
<p>As long as the message being signed is different each time, the resulting signature will also be different each time.</p>
<p>We can hash the result of the previous round's signature, sign it again to generate a new signature. This new signature can then be used as a seed to derive a random number. This process can be repeated by hashing the signature and signing it again, creating a chain of linked signatures.</p>
<div class="center-image">
<img src="6.InternetServices/assets/RandomNumberOnChain/image-20240206204454662.png" style="zoom:50%;" />
</div>
<p>In each round, the process involves signing the previous signature, creating a nested chain of signatures. </p>
<div class="center-image">
<img src="6.InternetServices/assets/RandomNumberOnChain/image-20240206204937628.png" style="zoom:80%;" />
</div>
<p>The process of generating random numbers is manipulable, unpredictable, low-cost, fast, and convenient. It is difficult to collude, making it an ideal random number generation scheme. üòéüí™üöÄ </p>
<p>Here is a <a href="https://dfinity.org/pdf-viewer/pdfs/viewer?file=../library/threshold-relay-blockchain-stanford.pdf">presentation</a> from 2017 regarding threshold relay. </p>
<br>
<p>Moreover, everyone can verify the generated random numbers (signatures) using the subnet's public key. This achieves a publicly verifiable, unpredictable, secure, fast, and efficient random number generation (buffed up with confidence). Using the BLS threshold signature scheme allows continuous and uninterrupted output of signatures, round after round, making it extremely convenient. </p>
<br>
<p>After solving the key distribution problem with NIDKG, BLS threshold signatures can be used to generate random numbers. Using such verifiable random numbers in consensus algorithms can achieve effects similar to Proof of Work (PoW), ensuring a secure and random selection of block-producing nodes. Each member of the consensus committee has the opportunity to produce a block. </p>
<p>Smart contracts (Canisters) can also derive random numbers from this seed. </p>
<p>For each subnet and each round, different random numbers are generated. </p>
<div class="center-image">
<img src="6.InternetServices/assets/RandomNumberOnChain/image-20240203102147977.png" alt="img" style="zoom:37%;" />
</div>
<br>
<br>
<br>
<p><strong>What are true random numbers and pseudo-random numbers? What is the difference between the two?</strong></p>
<p>Pseudo-random numbers are generated by deterministic algorithms, and their distribution and correlation can be assessed through statistical tests. However, as pseudo-random numbers are generated by algorithms rather than from a genuine random process, they can only simulate true randomness as closely as possible. Pseudo-random numbers are predictable and controllable since they depend on a &quot;seed value&quot; for initialization. Common pseudo-random number generation algorithms include linear congruential methods, Mersenne Twister, etc.</p>
<p>On the other hand, true random numbers are entirely unpredictable and non-repetitive. True random numbers typically rely on some physical process for generation, such as dice rolling, spinning wheels, noise from electronic components, and nuclear fission. Implementing true random number generators is challenging, and they tend to be less efficient.</p>
<p>Additionally, true randomness may not be achievable if the entropy source information is limited. Higher entropy corresponds to better randomness, meaning more disorder and unpredictability. From a probability theory perspective, true random numbers can be further categorized into statistical randomness and quantum randomness. Quantum random numbers are influenced by the inherent randomness in quantum mechanics, theoretically making them more &quot;true&quot; than statistical random numbers.</p>
<blockquote>
<p>Traditional randomness fundamentally depends on the lack of understanding of various variables, making it impossible to calculate or predict. If we have precise data on variables such as gravity acceleration at the picometer level, the air model for the entire enclosed space, all forces acting during a coin toss, the mass density material of the coin, etc., along with powerful computational resources, we could calculate the coin's motion and outcome.</p>
</blockquote>
<p>In computing, the Linux kernel implements a statistical true random number generator by collecting various noises during machine runtime, including hardware runtime speed, user-computer interaction speeds (e.g., keypress intervals, mouse movement speed), intervals between specific interrupts, and response times for block IO requests. A random number generator is an example of utilizing atmospheric noise to produce true random numbers. Some systems attempt to obtain even truer random numbers by monitoring the spontaneous behavior of quantum particles.</p>
<br>
<p><strong>Criteria for Evaluating Random Number Generation Schemes:</strong></p>
<ol>
<li>
<p><strong>Unpredictability:</strong> Unpredictability applies to all participants, producers, and consumers alike. It means that, based on historical data, no one can predict the possible values of the next random number, maintaining a Markov property. In public random number schemes, it is required that no one can improve prediction probabilities based on any public information.</p>
</li>
<li>
<p><strong>Immutability:</strong> During the generation of random numbers, collaborating participants cannot affect the process, change the outcome, or gain other advantages, such as obtaining the result of an upcoming random number in advance.</p>
</li>
<li>
<p><strong>Non-Acquaintance:</strong> Simultaneous knowledge of the random number is shared among all participants. No party can know the result in advance.</p>
</li>
<li>
<p><strong>Tamper Resistance:</strong> The producer of random numbers cannot forge a random number. Once a random number is generated, it cannot be modified by anyone.</p>
</li>
<li>
<p><strong>Non-Selection:</strong> In the process of producing random numbers, multiple random numbers may be generated simultaneously. The producer cannot selectively present only one of them or substitute one for another.</p>
</li>
<li>
<p><strong>Non-Concealment:</strong> Once the random number is generated, the producer cannot refuse to disclose it publicly. The generated random number must be made public and cannot be hidden or retracted.</p>
</li>
<li>
<p><strong>Participation:</strong> In the random number generation process, relevant parties can easily participate. The random number generation scheme should facilitate broad participation by the general public, reducing or eliminating participation barriers, and the right to participate should not be deprived.</p>
</li>
<li>
<p><strong>Auditability:</strong> After the completion of the random number generation process, the entire process should be auditable.</p>
</li>
<li>
<p><strong>Cost:</strong> The production cost of random numbers should be as low as possible.</p>
</li>
<li>
<p><strong>Response Speed:</strong> The random number generation process should be fast enough.</p>
</li>
</ol>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="trusted-execution-environment-tee"><a class="header" href="#trusted-execution-environment-tee">Trusted Execution Environment (TEE)</a></h2>
<p>Trusted Execution Environment (TEE) is a secure area within the CPU that runs in an isolated environment, parallel to the operating system. When Apple released the iPhone 5S in 2013, most people focused on new features like the camera and Touch ID. However, above these features, Apple introduced a concept considered to have profound implications for the cryptography world. As the foundation of Touch ID, the Secure Enclave Processor (SEP) was presented as a separate sub-processor used to store sensitive data and run programs on it. These sensitive data are not accessible by regular apps. Apple kept its design and internal operations confidential, releasing only limited internal information. </p>
<p>Shortly after, Intel also began offering a feature called Intel Software Guard Extensions (SGX), promising to keep data encrypted even while in use. Soon after, AMD released a similar product, and even Amazon AWS developed its own software-based secure enclave. Although there are some significant differences between these 4 products, they all focus on protecting data in use, aimed at slightly different use cases.</p>
<p>Currently, TEE has different implementation schemes on different CPUs. On Intel CPUs, the technical solution to implement TEE is called SGX, short for Intel Software Guard Extension. AMD's SEV scheme. On ARM architecture CPUs, the technical solution to implement TEE is called TrustZone, but because of the openness of the ARM architecture, major manufacturers will adopt different solutions when customizing.</p>
<br>
<h3 id="vault"><a class="header" href="#vault">Vault</a></h3>
<p>The CPU will ensure that the code and data in the TEE are both confidential and intact. The most powerful part of the TEE is that it can isolate itself from the computer system, as if a small safe is set up inside the computer, so that bad guys can't easily mess around. Important things like your passwords and payment information are inside. Therefore, even if the computer is attacked by a virus, this important information is still safe and sound. </p>
<p>The TEE has its own &quot;execution space&quot;, which means that what it uses is separate from our normal operating system. In the TEE, there are some trusted applications that can access important parts of the device. The job of hardware isolation is to protect the TEE from the influence of ordinary apps in the system.</p>
<p>The code and data inside the TEE are strictly protected during execution. The TEE usually provides security mechanisms such as encryption and digital signatures to ensure the integrity of code and data, while ensuring the confidentiality of communications through secure protocols. This makes the TEE an ideal place to store and process sensitive information.</p>
<br>
<p>When the TEE starts up, it goes through a series of verifications to ensure that the entire system is secure. For example, first load some secure boot programs, and then gradually verify the critical code in the secure operating system boot process to ensure the security of everything in the TEE. </p>
<p>The TEE has its own execution space, and the software and hardware resources it can access are separate from the operating system. The TEE provides a secure execution environment for authorized secure software or trusted security software (Trust App), protecting its data and resource confidentiality, integrity, and access rights. During startup, the TEE verifies step-by-step to ensure the integrity of the TEE platform in order to ensure the security of the entire system. When the device is powered on, the TEE first loads the secure boot program in ROM and verifies its integrity using the root key.</p>
<p>It then enters the TEE initialization phase and starts the built-in secure operating system of the TEE, level by level checking the critical code at each stage of the secure operating system boot process to ensure the integrity of the secure operating system, while preventing unauthorized or maliciously tampered software from running. After the secure operating system starts, it runs the boot program for the non-secure world and starts the normal operating system. At this point, based on the chain of trust, the TEE completes the secure boot of the entire system and can effectively defend against malicious behaviors such as illegal tampering and code execution during the TEE boot process.</p>
<br>
<p>In recent years, cryptography in use has been a very popular topic in the security and privacy community. As with any relatively popular topic, multiple solutions emerge to address the problem at hand. In the privacy/security realm, these solutions are called Privacy Enhancing Technologies (PETs), with secure enclaves being the most widely adopted solution in the industry due to their ease of use, availability, and performance.</p>
<br>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<p>The application scope of TEE is very wide, covering multiple fields. One of them is secure payment. TEE can be used to protect transaction information in payment applications to prevent malware and attackers from stealing users' financial data. Another important application area is the Internet of Things (IoT). TEE can protect sensitive information in embedded devices and prevent unauthorized access and control.</p>
<p>TEE also plays an important role in cloud computing. By introducing TEE into cloud services, users can run code and process data in the cloud while ensuring their privacy and security. This provides higher security for cloud computing, attracting many enterprises and organizations to adopt cloud services.</p>
<p>Moreover, TEE will also be integrated into more cutting-edge technologies such as artificial intelligence and blockchain, giving it more functionality. As a decentralized cloud service, IC uses TEE to enhance the protection of subnet data, further enhancing on-chain privacy. Even node operators do not know what data is running on the machines in the nodes.</p>
<br>
<p>With the continuous advancement of digitalization, TEE will continue to play an important role and be further developed in the future. On the one hand, hardware isolation technologies will become more advanced, providing more powerful protection mechanisms. On the other hand, TEE will be more integrated into emerging technologies such as artificial intelligence and blockchain, providing a more reliable security foundation for these fields.</p>
<p>At the same time, TEE may face challenges in terms of standardization and cross-platform compatibility. In order to more widely promote TEE technology, the industry needs to establish consistent standards to ensure interoperability between different manufacturers and devices.</p>
<p>As a key security technology, the trusted execution environment provides powerful protection for data security and privacy. Its principles are based on hardware isolation and secure execution, with a wide range of applications covering payments, Internet of Things, cloud computing and other fields. In the future, with the continuous advancement of technology, TEE will continue to play an important role and demonstrate broader prospects in emerging technology fields.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="my-account-snatched"><a class="header" href="#my-account-snatched">My Account, Snatched!</a></h2>
<p>It was a dark and stormy night in 2009. In a dingy internet cafe, the air was thick with cigarette smoke and the scent of instant noodles, mingling with the cacophony of furious typing, satisfied slurping, frustrated cursing, desperate cries to teammates, and groans of despair as defeat loomed - the din filled the room.</p>
<p>Amidst the chatter and whir of computers, no one noticed the cryptic code flickering on John Smith's screen as his fingers flew across the keyboard. The monitor's wavering glow lit his face indistinctly, but a sly twinkle could be glimpsed in his eyes.</p>
<p>Streams of code flowed from his fingertips, through the keyboard into the CPU, then jumped into the LAN cable, fiber optic lines, as if heeding their master's call. Surging underground in the city, stealthily crossing under the sea, darting between mountains - crossing thousands of miles in a blink, flashing through the vast network topology, heading for the target address.</p>
<p>At the other end of the wire, a hapless victim sat numbly clicking his mouse.</p>
<p>&quot;Security risks detected. Click here to download protective software.&quot;</p>
<p>&quot;Uh, okay.&quot;</p>
<p>Little did he know, sinister code was approaching, poised to strike his computer a fatal blow. Instructions from thousands of miles away had already infiltrated his digital domain through the trojan. Bringing back his account and password to John's screen.</p>
<p>John was gloating in his dim, noisy corner - yes! Another fish on the hook. That's the 7th catch today.</p>
<h2 id="please-enter-your-password"><a class="header" href="#please-enter-your-password">Please Enter Your Password</a></h2>
<p>Over 10 years ago, losing accounts was quite common. Countless John Smiths lurked in obscure corners, cracking countless user accounts. Times have changed, and today's internet environment is much safer than before.</p>
<p>Since the early information age of the 21st century, our lives have become increasingly reliant on the internet. Shopping, chatting, gaming, watching videos, getting things done - everything requires logging into various websites and apps. But with it comes the headache of managing passwords.</p>
<p>Most netizens lack security awareness. With so many accounts, people find it hard to remember them all, so many opt for simple username and password combinations.</p>
<p>However, this approach has many flaws.</p>
<p>Firstly, our brains are not good at memorizing so many passwords. Most people have numerous online accounts, each requiring a unique password for security. But remembering all these is nearly impossible, so people tend to reuse passwords or use simple, easy ones. While convenient, this greatly compromises account security.</p>
<p>Even with complex passwords, attackers can still steal them through phishing, keyloggers, cracking, etc. Once they have the password, they can impersonate us for malicious acts.</p>
<p>Also, when we forget passwords, we have to reset via email or SMS, which can be insecure. Hackers can steal the reset messages to hijack accounts.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231005170936235.png" alt="img" style="zoom:57%;" />
</div>
<p>Losing an account means losing online data, friends, comments, activity records - everything gone in a flash.</p>
<p>To address this, many sites now use two-factor authentication - after username and password entry, users have to further verify via SMS code, email code, etc. No doubt this improves security, but also increases complexity.</p>
<p>Website login is shifting towards &quot;single sign-on&quot; - ideally, one account for all sites.</p>
<p>WeChat and Google have achieved this. They allow logging into many third-party mini programs and sites directly through phone-binding. This &quot;scan to login&quot; is more secure and convenient than pure username-password.</p>
<p>It would be so much easier if all sites could log in with one account like WeChat or Google. Then we'd only need one password to seamlessly browse the entire web. But not all sites support Google login, and as people become more privacy-conscious, centralizing account data under big corporations is risky.</p>
<p>We must also consider privacy. Many sites secretly collect personal info like login times, locations, devices. This valuable data can be abused to track our online activities or even sold to mysterious advertisers or third parties.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231005170715275.png" alt="img" style="zoom:35%;" />
</div>
<p>Also, people may not realize accounts don't fully belong to them. They can be forgotten, lost, or revoked. Today's internet services typically require registration with phone number or email.</p>
<p>But users don't really own those either. Phone numbers belong to telcos, emails belong to email and domain providers. If they take back your number, email, domain, your account will be in trouble and possibly lost if you can't change it.</p>
<p>Not only do users not own account names, they don't legally own the accounts either.</p>
<p>For example, WeChat account ownership belongs to <a href="https://tech.sina.com.cn/roll/2020-09-08/doc-iivhuipp3172175.shtml">Tencent</a>. Article 7.1.2 of its <a href="https://weixin.qq.com/agreement?lang=zh_CN">Terms of Service states</a>:</p>
<blockquote>
<p>&quot;<strong>Ownership of all Weixin accounts belong to Tencent. After completing the application for registration, the user only obtains the right to use the Weixin account, and the usage right only belongs to the initial registrant.</strong>&quot;</p>
</blockquote>
<p>Essentially, account ownership lies with service providers, users only have usage rights. Thus, providers can unilaterally suspend or cancel accounts, which is legally valid. Platform account bans, Trump's Twitter ban, etc are such cases.</p>
<p>We need new solutions to this problem - more secure password tools, advanced encryption, new authentication methods like behavior-based - and to develop ways for users to truly own and fully control their online identities, so they can never be lost or taken away.</p>
<h2 id="finding-better-solutions"><a class="header" href="#finding-better-solutions">Finding Better Solutions</a></h2>
<p>There are solutions, and they already exist.</p>
<p>That is to rebuild the internet's identity system in a decentralized way using blockchain:</p>
<ol>
<li>Use decentralized networks and blockchain tech. Accounts and content are stored in user-controlled decentralized networks, not relying on any centralized platforms.</li>
<li>Employ self-sovereign identity tech. Users can create and control their own digital identities, no reliance on phone numbers or emails.</li>
<li>Use peer-to-peer networks for direct user connections, no need for centralized servers. Content is distributed across the network, not dependent on single platforms.</li>
<li>Encrypt and distributedly store user data, not centralized, harder to delete.</li>
<li>Utilize open source software and protocols, avoid reliance on proprietary corporate platforms.</li>
</ol>
<p>Although there is still much work to be done, these technologies provide hope for users to truly control their digital lives. We should continue pushing their development, empowering each user with decentralized network ownership.</p>
<p>DFINITY has created an advanced, secure decentralized identity called <strong>Internet Identity</strong> (also called &quot;ii&quot;), which can be used on apps in its ecosystem. Logging into Dapps requires no passwords, no memorizing complex private keys or seed phrases - just easy control of your decentralized identity.</p>
<p>Websites collect no information about users' online activities when using <a href="https://identity.ic0.app">Internet Identity</a>. It creates and manages anonymous, independent accounts for you on each site, letting you enjoy the privacy protection of having many accounts without the hassle of managing them. It frees you not just from complex username and password management, but also makes your use of web services more secure and private overall.</p>
<p>Users can create a decentralized identity by facial scan, fingerprint, Ledger or <a href="https://en.wikipedia.org/wiki/YubiKey">Yubikey</a> hardware wallet. This identity can then log in/register with various Dapps.</p>
<p>Logging into different Dapps with the same identity will generate different accounts. That is, identities are isolated and non-portable (unlike ETH). The identity is a completely isolated account on each Dapp. It's like each Dapp gets a derived identity, a subgroup, from the main identity, controlling all Dapps with one DID. And you can log in from different devices but get the same identity on the Dapp.</p>
<p>Let's take a deeper look at ii:</p>
<p>ii is an identity authentication mechanism, still based on private keys, public keys, etc under the hood. But users don't have to log in with private keys or seed phrases.</p>
<p>There are two key concepts: delegation chain, DID identity.</p>
<p>Let's look at them one by one:</p>
<h2 id="delegation-chain"><a class="header" href="#delegation-chain">Delegation Chain</a></h2>
<p>The user's phone and computer have a TPM secure enclave chip that can generate a keypair. The public key will be uploaded and stored in the ii backend Canister; the private key is generated and saved by the device's TPM chip, inaccessible by anyone (including the user).</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231009234513526.png" style="zoom:65%;" />
</div>
<p>To interact with IC's smart contracts, all messages need to be signed as a whole. On IC, user-Dapp interactions also require signature authentication every time, and the private key is in a secure enclave requiring fingerprint to use. Of course users can't be asked to fingerprint sign every request.</p>
<p>So ii uses delegation to form a delegation chain. Expiry times are set for delegated keys, which then sign with their private keys.</p>
<p>First the browser can generate a temporary keypair (session key).</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231009234607478.png" alt="image-20231009234607478" style="zoom:70%;" />
</div>
<p>Then the secure enclave's private key signs the expiry time, user identity, third party domain name, etc.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231009234801260.png" style="zoom:41%;" />
</div>
<p>This signature is the delegation. (The seed is a secret generated by ii's Canister).</p>
<p>The delegation is the secure enclave's private key signing some information, indicating the private key trusts these delegated data to do other things on its behalf.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20230710130244492.png" alt="image-20230710130244492" style="zoom:33%;" />
</div>
<p>With this delegation, the browser's temporary private key can now sign requests.</p>
<p>We send out the delegation, blue public key, temporary private key signed request, pink temporary public key. As shown below.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20230717101308922.png" alt="img" style="zoom:50%;" />
</div>
<p>The receiver gets the <strong>blue public key</strong>, delegation, pink private key signed content, <strong>pink public key</strong>.</p>
<p>Use the <strong>blue public key</strong> to decrypt the signature, finding the <strong>pink public key</strong> inside, meaning the <strong>blue private key</strong> has signed the <strong>pink public key</strong>. This proves the blue private key has delegated authority, like a general wielding the emperor's tiger tally to dispatch troops and commanders, the tiger tally representing the emperor's authorization.</p>
<p>But it's not fully done yet. We still have to send all these to ii's backend Canister for certification before it takes effect.</p>
<p>When you send that info, inside ii's Canister it will generate a unique identity identifier for the user's logged in Dapp - <a href="7.ii/pid.html">the Principal id</a>, pid for short.</p>
<p>Next comes how ii derives identities for users, so sit tight!</p>
<h2 id="did-identities"><a class="header" href="#did-identities">DID Identities</a></h2>
<p>Compared to traditional centralized identity systems, DID's main features and advantages lie in its decentralization, self-sovereign control, and privacy protection.</p>
<p>Decentralized Identity (DID) is a digital identity model not dependent on centralized authorities. It allows individuals and organizations to own and control their digital identities without requiring validation through any third-party intermediaries. Traditional identity models typically rely on centralized identity providers like government agencies, social media platforms, or corporations that hold and manage users' personal information, posing privacy and security risks.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231005172806194.png" alt="img" style="zoom:33%;" />
</div>
<p>DID uses an entirely different approach. Based on blockchain technology, it enables individuals to create their own digital identity without reliance on any single centralized authority. Each DID is unique, cryptographically secure, with users fully controlling their own identity data. This means users can better safeguard their privacy by choosing what entities to share their identity with, when, and how much. Unlike traditional models, DID gives users greater control and self-sovereignty over their identities.</p>
<p>DID also helps lower risks of identity theft and data breaches since there is no centralized database for attackers to target. Additionally, DID's portability allows users to seamlessly share their identity information across online services without having to repeatedly verify and recreate identities.</p>
<p>Decentralized identity represents a more secure, private, and user-friendly identity model with the potential to transform the digital identity landscape and power the digital society of the future. Internet Identity (ii) is one example of a DID-based digital identity system. When it comes to ii identities, the Principal id is essential.</p>
<h3 id="principal-id"><a class="header" href="#principal-id">Principal id</a></h3>
<p>Principal id (pid for short) is essentially an identifier that can be used to identify identities and Canisters.</p>
<p>For example:</p>
<p>When you log into a Dapp with ii, ii will generate a pid for you.</p>
<p>When you first use IC's SDK, the dfx command line tool will create a default developer identity (with a keypair) for you - this developer identity is a pid.</p>
<p>When you deploy a Canister to the mainnet, the NNS system will also allocate a pid to the Canister, though we prefer calling it a Canister id to distinguish it.</p>
<p>The pids used in ii are derived from the Anchor and Dapp domain name. The Anchor is like a username, a string of numbers assigned when you register with ii (similar to a QQ number).</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231005175044245.png" alt="img" style="zoom:39%;" />
</div>
<p>The specific derivation process is:</p>
<p>First compute a seed:</p>
<ul>
<li>ii's Canister takes a random system seed salt (32 bytes) from the subnet's random beacon.</li>
<li>Get the app domain name and Anchor.</li>
<li>Concatenate the <strong>length of salt, salt, length of Anchor, Anchor, length of domain, domain</strong>.</li>
<li>Hash the concatenated string with SHA256 to get the seed.</li>
</ul>
<p>Then compute the user's raw pid:</p>
<ul>
<li>Concatenate the <strong>length of ii Canister id, ii Canister id, and seed</strong>.</li>
<li>DER encode the concatenated string.</li>
<li>Hash the DER encoding with SHA224 to get the body of the raw pid.</li>
<li>Finally append 0x02 to the end of the raw pid body to form the user's raw pid.</li>
</ul>
<p>Then convert the raw pid's format:</p>
<ol>
<li>Calculate the 4 byte CRC32 checksum of the raw pid binary value.</li>
<li>Prepend the checksum to the raw pid value.</li>
<li>Base32 encode the connected result.</li>
<li>Insert <code>-</code> every 5 characters as separator.</li>
<li>Uniformly display in lowercase.</li>
</ol>
<p>For example, take a raw pid: 0xABCD01</p>
<ol>
<li>Its CRC32 checksum is 0x233FF206</li>
<li>Encoding after attaching the checksum gives em77ebvlzuaq</li>
<li>Inserting <code>-</code> every 5 chars gives em77e-bvlzu-aq</li>
</ol>
<blockquote>
<p>This seed-derived key approach enhances anonymity and cross-domain portability of user identities.</p>
</blockquote>
<p>Through this random seed approach, independent pids can be derived for each Anchor and frontend domain.</p>
<p>Including the ii Canister id in pid derivation can prevent collisions of the same seed generating the same pids in different Canisters, improving isolation.</p>
<h3 id="dapp-sub-identities"><a class="header" href="#dapp-sub-identities">Dapp Sub-identities</a></h3>
<p>For example, if your Anchor is 77752, to log into the NNS Dapp, you need to derive an identity exclusive to NNS from 77752 and nns.ic0.app. The ii Canister id remains unchanged.</p>
<p>Logging into a Dapp from different devices with the same Anchor generates the same pid identity, since the domain name and Anchor are unchanged.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231005174705334.png" alt="img" style="zoom: 23%;" />
</div>
<p>When a user logs into different Dapps with one Anchor, the pid identities differ, because the Dapp domain names differ.</p>
<p><strong>Essentially, pids are sub-identities of a user (Anchor) when logging into different Dapps.</strong></p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231005173538361.png" alt="img" style="zoom:35%;" />
</div>
<blockquote>
<p>However, there's an issue - currently most Dapp domain names contain the Canister id, so when a Canister is deleted and redeployed, the Dapp's identity data will change.</p>
<p>To address this, on IC when a Canister is deleted its Canister id is still reserved for the controller (developer who deployed it). The developer can keep using the previous Canister id when redeploying.</p>
</blockquote>
<p>After all the above steps, ii's Canister will have generated a unique pid (sub-identity) for you.</p>
<p>After ii's series of checks, it will also add the non-public seed, Dapp domain, Anchor, expiry time, temporary public key into the delegation. The Canister will sign this delegation with a public key it constructs, saving the signature in ii Canister's certification variable.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231010000139530.png" alt="image-20231010000139530" style="zoom:50%;" />
</div>
<p>Canisters can sign messages:</p>
<ul>
<li>The public key contains the Canister id and a seed, different seeds can generate different public keys for that Canister.</li>
<li>The signature is a certificate which contains a hash tree. The hash of the signed message is embedded in the tree.</li>
</ul>
<p>When verifying the signature, first check if the certificate is valid, the certificate must contain the Canister id of the signer. Then check if the tree is valid, if it contains the hash computed from the seed and message.</p>
<p>If both of these checks pass, then the signature is valid.</p>
<p>In this way, a Canister can use the state tree to do digital signatures without relying on an external private key. The signature information is directly embedded in the Canister's authentication variables.</p>
<p>This mechanism has many advantages: the signing process is fully controlled by the Canister itself. Each Canister can have multiple key pairs. And the signature information is written to the system's state tree, ensuring non-repudiation. The certificate mechanism provides high flexibility and fast validation.</p>
<p>After signing, it returns to the frontend browser (frontend is polling all the time), now the browser can sign the request with the temporary private key. The user's browser sends the message, signature of the message, temporary public key, and delegation to the subnet, so the subnet knows the temporary private key's signature is ok and can interact with the subnet.</p>
<p>The client (whether using agent-js, agent-rs or any way to communicate with the IC API) must sign the message before sending it to a canister on the IC. The subnet will verify this signature and derive the caller's pid from the signature. So unless the client has the same private key, it cannot impersonate someone else's delegation.</p>
<p>Let me add one more point.</p>
<h2 id="device-binding"><a class="header" href="#device-binding">Device Binding</a></h2>
<p>Previously I said: <em>Logging into a Dapp from different devices with the same Anchor generates the same pid identity, since the domain name and Anchor are unchanged.</em></p>
<p>Wait, how does ii enable logging into Dapps with the same Anchor across devices?</p>
<p>ii is an identity authentication mechanism. It doesn't store user info, only a user's ii identity. User data is stored by the Dapps themselves.</p>
<p>ii's Canister stores Anchors and user devices. Anchors start from 10000 and increment.</p>
<p>Each device saved by a user in ii is a public key. Users can add, remove devices, i.e. manage these public keys. So if a user loses their phone, it's like losing a public key - they can log in with the Anchor on another device and remove the lost phone device.</p>
<p>ii's backend Canister will add a user's different device public keys, binding them to the user's Anchor corresponding Master key, which is internal to the Canister. This way, as long as one device is added, the devices (public keys) saved in ii can be changed, without the user needing to handle private keys.</p>
<div class="center-image">
<img src="7.ii/assets/ii/image-20231009234300813.png" style="zoom:43%;" />
</div>
<p>This Master key can be seen as an overarching private key. As long as devices are bound to it, there's no need to worry about losing the ii identity. If all devices are lost, login is still possible with a recovery phrase. If that is lost too, then it's gone üòù.</p>
<p>This achieves the effects described earlier:</p>
<ul>
<li>The pid identity differs when a user logs into different Dapps with one Anchor.</li>
<li>The pid identity is the same when a user logs into a Dapp from different devices with one Anchor.</li>
</ul>
<p>That covers the basics of Internet Identity (ii).</p>
<p>Here are some ii resources to get started with development and use:</p>
<p>Official docs: https://internetcomputer.org/docs/current/samples/internet-identity-sample</p>
<p>Official code samples: https://github.com/dfinity/examples/tree/master/motoko/cert-var</p>
<p>npm package: https://www.npmjs.com/package/@dfinity/auth-client?activeTab=readme</p>
<p>Kyle's blog post on integrating ii login: https://kyle-peacock.com/blog/dfinity/integrating-internet-identity</p>
<p>Integration demo: <a href="https://sdk.nnsdao.com/docs/quick-start/dfinity-progarmming-practice/#identity%E7%BB%91%E5%AE%9Awallet">https://sdk.nnsdao.com/docs/quick-start/dfinity-progarmming-practice/#identity%E7%BB%91%E5%AE%9Awallet</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="principal-id-pid"><a class="header" href="#principal-id-pid">Principal id (pid)</a></h2>
<p>The generation of principal id (pid) is controlled internally by the IC system. <a href="https://internetcomputer.org/docs/current/references/ic-interface-spec/#principal">Here</a> you can find more details about the design of pid.</p>
<p>There are currently two main ways:</p>
<ol>
<li>
<p>Opaque ID randomly generated by the system</p>
<p>This is the most common form. The system uses a random number generator to randomly generate a binary value of 0-29 bytes in length, and appends 0x01 at the end. This process is completely controlled internally by the system and cannot be influenced externally, so it is opaque externally. This type of ID is randomly generated.</p>
</li>
<li>
<p>Self-authenticating ID based on a public key</p>
<p>This type of pid requires an external public key, usually controlled by the user. The system will DER encode this public key, take the SHA-224 hash of it, and append 0x02 at the end to form a 29 byte Principal id. A user with the corresponding private key can then use this ID for authentication, signing and other operations.</p>
</li>
<li>
<p>The system can also derive new ID from an existing Principal:</p>
<p>Append a nonce to the Principal, compute the hash, and append 0x03. This generates an ID space that only that Principal can register.</p>
</li>
<li>
<p>Anonymous ID</p>
<p>These take the form <code>0x04</code>, and are used by anonymous callers. They can send call and query requests to the IC network without signatures.</p>
</li>
<li>
<p>Reserved ID</p>
<p>Reserved ID are a special Principal format. They are not real ID, but have a similar format and provide more expressiveness for Dapps.</p>
</li>
</ol>
<br>
<p>The format is: <code>blob ¬∑ 0x7f</code>, where <code>0 ‚â§ |blob| &lt; 29</code> (an arbitrary byte sequence of 0 - 28 bytes + 0x7f).</p>
<p>Reserved ID do not correspond to any real principals. Their purpose is for Dapps to reuse the text representation format of Principals, while explicitly indicating the ID does not point to a real canister or user.</p>
<p>For example, if a Dapp needs to display an ID that looks like a Principal but does not represent a real pid, it can construct a reserved ID like:</p>
<pre><code>0x123456789520 + 0x7f
</code></pre>
<p>This generates a reserved ID that has a text representation like a Principal, but the Dapp and system know it does not correspond to a real principal.</p>
<p>The maximum length of a reserved ID is also 29 bytes, consistent with other forms of Principal ID. It is only constructed by Dapps, the system does not generate reserved ID when creating new Principal ID.</p>
<br>
<p>The text format of Principal is defined as follows:</p>
<ol>
<li>Compute a 4 byte CRC32 checksum of the raw principal binary value.</li>
<li>Prepend the checksum to the Principal value.</li>
<li>Base32 encode the concatenated result.</li>
<li>Insert a &quot;-&quot; every 5 characters as a separator, for grouped display.</li>
<li>Uniformly display in lowercase.</li>
</ol>
<br>
<p>For example, for a Principal with ID 0xABCD01:</p>
<ol>
<li>Its CRC32 checksum is 0x233FF206.</li>
<li>Base32 encoding the concatenated result gives em77ebvlzuaq.</li>
<li>Inserting &quot;-&quot; every 5 chars, the text format is em77e-bvlzu-aq.</li>
</ol>
<br>
<p>This format has many benefits:</p>
<ul>
<li>Uniform display format suitable for different contexts</li>
<li>Fixed maximum length of 63 bytes, easy to process</li>
<li>CRC checksum can detect conversion errors</li>
<li>Case insensitive parsing</li>
</ul>
<br><div style="break-before: page; page-break-before: always;"></div><h2 id="cryptographic-fundamentals"><a class="header" href="#cryptographic-fundamentals">Cryptographic Fundamentals</a></h2>
<p>Cryptography is a fascinating and highly significant field that explores how to encode and decode information to achieve confidentiality. </p>
<br>
<p>Its origins can be traced back thousands of years when ancient governments used codes for transmitting confidential information, and merchants employed them to safeguard trade details. For instance, the Caesar cipher from ancient Rome involved shifting letters by a certain number of positions for encryption. Though simple, such encryption methods were effective for their time.</p>
<p>Over the centuries, cryptographic techniques have evolved. In the medieval period, more complex encryption methods emerged. True modern cryptography, however, began in the 20th century, thanks to advancements in computing that supported more sophisticated algorithms.</p>
<p>Cryptography primarily focuses on two aspects: cryptographic algorithms and cryptanalysis. Cryptographic algorithms encompass the rules for encryption and decryption, essentially the encryption and decryption algorithms. Symmetric encryption and asymmetric encryption are typical examples.</p>
<br>
<p>Symmetric encryption, the most basic encryption method, employs the same key for both encryption and decryption. Classical examples like the Caesar cipher fall under symmetric encryption. However, a drawback is that both the sender and receiver need to know the same key, introducing risks in key distribution and storage.</p>
<p>This led to the development of asymmetric encryption. Asymmetric encryption uses a key pair, with the public key being openly shared and the private key kept confidential. Information encrypted with the public key can only be decrypted using the corresponding private key, resolving the key distribution issue. Asymmetric encryption forms the foundation of modern cryptographic systems.</p>
<br>
<p>Cryptanalysis involves methods to decipher encrypted information. Techniques for breaking codes have evolved over time. Simple codes can be cracked using frequency analysis, while complex passwords may require high-performance computers for brute-force attacks. Hence, modern encryption algorithms aim for high computational complexity to resist brute-force attacks. The emergence of quantum computing technology poses a threat to many current encryption algorithms.</p>
<br>
<p>Cryptography has numerous crucial applications in today's society, including ensuring the security of internet communications, electronic payment transactions, and privacy protection. It has become an integral component of the foundational infrastructure of modern information society. Without reliable cryptographic protection, many internet services would face severe security risks.</p>
<p>Although cryptography has a long history, it remains an active field, playing a vital role in supporting various digital activities in contemporary society.</p>
<br>
<h2 id="symmetric-encryption"><a class="header" href="#symmetric-encryption">Symmetric Encryption</a></h2>
<p>Symmetric encryption is one of the origins of modern cryptography, where a single key is used for both encrypting and decrypting information. Its roots can be traced back to ancient times, with examples like the Caesar cipher representing a simple substitution encryption method.</p>
<img src="8.CryptographyInIC/assets/BasicCryptography/image-20240130180749760.png" alt="img" style="zoom:55%;" />
<p>In symmetric encryption, communicating parties agree on an encryption method and then encrypt and decrypt messages using the corresponding key (decryption method). It's a straightforward process.</p>
<br>
<p>Imagine symmetric encryption like two good friends, A and B, who want to encrypt their letters using a code to keep others from understanding the contents. They decide on a rule: shifting each letter in the alphabet three positions to the right, turning 'a' into 'd,' 'b' into 'e,' and so on.</p>
<p>Now, they can use this rule to encrypt and decrypt each other's letters. As long as they keep this rule secret, others won't understand the content of their letters. This rule is the encryption key.</p>
<p>The significant advantage of symmetric encryption is that it uses the same key for both encryption and decryption, providing fast computation suitable for encrypting large amounts of data. However, the challenge lies in the secure distribution and storage of the key.</p>
<p>A and B cannot communicate the key through public letters or phone calls due to the risk of eavesdropping. Therefore, complex protocols are needed for a secure key exchange, often involving encryption algorithms.</p>
<p>Moreover, symmetric encryption requires each pair of users to have a unique key. When dealing with many users, this results in a large number of keys, which must be securely stored, adding a considerable burden.</p>
<br>
<p>Before the 1970s, symmetric encryption dominated practical applications. In the 1970s, asymmetric encryption was invented, marking another significant milestone. Asymmetric encryption uses different keys for encryption and decryption.</p>
<p>Typical symmetric encryption algorithms include DES (Data Encryption Standard), AES (Advanced Encryption Standard), etc.</p>
<br>
<p>Symmetric encryption is simple and user-friendly but faces challenges in key distribution.</p>
<p>To address this issue, asymmetric encryption, also known as public-key encryption, was developed.</p>
<br>
<h2 id="asymmetric-encryption"><a class="header" href="#asymmetric-encryption">Asymmetric Encryption</a></h2>
<p>Typical asymmetric encryption algorithms include RSA, ECC, etc.</p>
<br>
<p>Asymmetric encryption involves each person generating 2 keys: one public key and one private key. The public key is openly shared, which eliminates the difficulty of transmitting the key, while the private key is kept secret. </p>
<p><strong>Information encrypted with the public key can be decrypted with the private key. Conversely, information encrypted with the private key can also be decrypted with the public key.</strong></p>
<p>For example, if person A and person B are communicating, they publicly share their public keys. </p>
<p>Person A can encrypt information with Person B's public key and send it to Person B. Then Person B can decrypt the information with their own private key.</p>
<div class="center-image">
<img src="8.CryptographyInIC/assets/BasicCryptography/image-20240206212202488.png" style="zoom:50%;" />
</div>
<p>If B encrypts a message with their private key and sends it to A, then A can decrypt it using B's public key. If A can successfully decrypt the message, it proves that the message definitely came from B and was not forged by someone else. </p>
<p>Since the public key is openly available, anyone can use B's public key to verify messages from B. </p>
<div class="center-image">
<img src="8.CryptographyInIC/assets/BasicCryptography/image-20240206213518525.png" style="zoom:50%;" />
</div>
<p>In other words, B has applied a &quot;signature&quot; (digital signature) to the information.</p>
<p>Digital signatures can also derive various variants, such as ring signatures which can hide the identity of the signer, threshold signatures which can distributedly generate the private key to reduce single point of failure. If you want to sign multiple documents with one signature, use aggregate signatures. There are also identity-based signatures, etc.</p>
<br>
<p>However, directly encrypting a message with the private key is very inefficient and computationally expensive. If the message is large and complex, it becomes even harder to encrypt, requiring a lot of time.</p>
<p>This is when hash algorithms become very useful.</p>
<br>
<h2 id="hash-algorithms"><a class="header" href="#hash-algorithms">Hash Algorithms</a></h2>
<p>A hash algorithm converts input content of arbitrary length into a fixed length output. No matter how long the input message is, the length of the computed message digest is always fixed. It is mainly used to more quickly determine if two contents are the same, or to check if a published source file has been tampered with or corrupted.</p>
<blockquote>
<p>A message digest is a type of hash algorithm, but with additional stricter requirements, such as being non-reversible, more stringent collision resistance, etc.</p>
</blockquote>
<p>Given the same algorithm and encoding, a message corresponds to a unique hash value. And it is impossible to compute the original message from a hash value, the hash value can only be derived from the message. </p>
<div class="center-image">
<img src="8.CryptographyInIC/assets/BasicCryptography/image-20240131102922515.png" alt="img" style="zoom:57%;" />
</div>
<p><strong>A hash algorithm generates a unique fingerprint for a file.</strong> (The probability of hash collisions can be ignored.)</p>
<p>For example, I hash <code>NeutronStar</code> using the SHA-256 algorithm to get (HEX) this string:</p>
<p><code>2d7d57c075dd0f07eaca5c61c1e2a52d9f851f2e17d495540e7165fc98a648b1</code></p>
<p>Hashing <code>Neutronstar</code> gives: </p>
<p><code>89096b669b06b3150db816f060ea8067a15d51f11b94c882c9cf1d9e68dab4f9</code></p>
<p>Even a slight change in the message results in a very different value.</p>
<p>Hashing <code>0</code> with SHA-256 algorithm gives:</p>
<p><code>5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9</code></p>
<p>We can also hash the above long string again using SHA-256, computing the hash of 5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9:</p>
<p><code>5122a1d1bc9d87662dcf5fb870adf8c55faf2ce12fad1bacac2fe7df88172466</code></p>
<p>By hashing like this, we always get a hash value of the same length.</p>
<br>
<h2 id="digital-signatures"><a class="header" href="#digital-signatures">Digital Signatures</a></h2>
<p>With hash algorithms, implementing signatures becomes much easier. </p>
<div class="center-image">
<img src="8.CryptographyInIC/assets/BasicCryptography/image-20240206214932791.png" style="zoom:57%;" />
</div>
<p>Simply hash the original file first, then encrypt the hash value with the private key to get the file's signature. </p>
<p>Verifying the signature is also very simple. Just decrypt the signature using the signer's public key. And hash the source file too, compare the 2 hash values. If the hash values are the same then there is no problem.</p>
<div class="center-image">
<img src="8.CryptographyInIC/assets/BasicCryptography/image-20240206215101690.png" style="zoom:50%;" />
</div>
<p>What if the hash value we get after decrypting with the public key is different from the hash of the original file? </p>
<p>It could be that the original file was damaged or replaced, or the public key was replaced by an attacker, or the signature was replaced. </p>
<br>
<p>Signatures can ensure three things: </p>
<ul>
<li>Confirm the information is sent by the signer, anyone can verify the validity of the signature.</li>
<li>Confirm the information has not been modified from signing to receiving, including modifications by intermediaries during transmission. </li>
<li>Confirm the information has not been lost during transmission.</li>
<li>The signature cannot be forged. No one else can forge the signature.</li>
<li>The signed message cannot be altered: A signed message cannot be tampered with. As soon as a signed message is tampered with, any person can discover the inconsistency between the message and the signature.</li>
<li>The signature is non-repudiable: The signer cannot later deny their own signature.</li>
</ul>
<br>
<p>Traditional digital signature technology implements basic authentication functions. In some blockchain application scenarios, there are special privacy protection needs such as identity anonymity and content hiding. </p>
<p>In these cases, special digital signature technologies such as group signatures, ring signatures, or blind signatures are needed to achieve this. For example, in a weakly centralized or multi-centralized blockchain scenario, in order to achieve complete anonymity, the signer only wants to prove that they are within a certain range of legitimate users, rather than allowing a regulatory role to deduce the signer's identity. This requires the use of multi-signature technology. </p>
<br>
<h3 id="multi-signature"><a class="header" href="#multi-signature">Multi-Signature</a></h3>
<p>Multi-signature is a very important signing method. </p>
<p>Multi-signature requires multiple parties to jointly complete the signing. 7 people, each with a private key, set the threshold to 5. That is, at least 5 out of the 7 people need to sign for it to take effect.</p>
<p>For example, a document that needs to be signed jointly by multiple departments, or a property jointly held by multiple banks.</p>
<h3 id="group-signature"><a class="header" href="#group-signature">Group Signature</a></h3>
<p>The concept of group signatures was first proposed by Chaum and Heyst in 1991. A member within a group can anonymously sign on behalf of the group, the signature can prove it comes from the group, but cannot determine which member it comes from. </p>
<p>The key to group signature schemes is the group manager, who is responsible for adding group members and revealing the signer's identity in case of disputes.</p>
<p>In some group signature designs, the responsibilities of adding group members and revoking signature anonymity are separated and assigned to the group manager and the revocation manager, respectively.</p>
<h3 id="ring-signature"><a class="header" href="#ring-signature">Ring Signature</a></h3>
<p>Let's say I'm an early contributor and core developer of Bitcoin. </p>
<p>I want to anonymously publish a message (revealing who Satoshi Nakamoto is), but I don't want to be completely anonymous. I want to reveal to the outside world that I am one of the early developers of Bitcoin, so I have credibility.</p>
<p>This is where ring signatures come in handy.</p>
<p>In a ring signature, I first need to select a temporary set of public keys that includes my own. Then, using my private key and the public keys of others in the set, I independently generate a signature, without any other setup required. </p>
<div class="center-image">
<img src="8.CryptographyInIC/assets/BasicCryptography/image-20240131201739665.png" alt="img" style="zoom:35%;" />
</div>
<p>The other members in the signature set may not even know that they have been included in the final signing set. One of the security properties of ring signatures is that determining which member's key was used to generate the signature is computationally infeasible.</p>
<p>Ring signatures are similar to group signatures, but differ in two places: first, the anonymity of individual signatures cannot be revoked; second, any user group can serve as a group.</p>
<h3 id="blind-signature"><a class="header" href="#blind-signature">Blind Signature</a></h3>
<p>Blind signatures were proposed by David Chaum in 1982. It refers to the signer signing a message without being able to see the original content.</p>
<p>On the one hand, blind signatures can protect the signed content and prevent the signer from seeing the original content.</p>
<p>On the other hand, blind signatures prevent tracking, as the signer cannot correlate content with signature results.</p>
<h3 id="threshold-signature"><a class="header" href="#threshold-signature">Threshold Signature</a></h3>
<p>In 1979, after Shamir proposed <a href="8.CryptographyInIC/./SecretSharing.html">the secret sharing</a> technique, Desmedt et al formally proposed the concept of threshold signatures in 1994.</p>
<p>In a threshold signature, each key shard is only part of the total private key. </p>
<p>Each member uses the key shard to generate a signature shard for the information. After collecting enough signature shards, the complete signature is assembled. This process is done off-chain. </p>
<p>During verification, only one on-chain verification is required.</p>
<p>This does not rely on the signature of a single entity. Even if some key shards are leaked or some participants have problems, as long as the number of leaked key shards does not reach the threshold, the signature remains secure.</p>
<p>Note that multi-signature and threshold signatures are different technologies. The members of a multi-signature are fixed. Multiple participants sign multiple times using different private keys, with each signature being independent of each other. Final verification is done by scripts or contracts to determine if each signature can be verified, requiring multiple verifications.</p>
<p>Threshold signatures are used for key escrow, recovery, power distribution, etc., and are also endowed with more features such as dynamic thresholds, active private key updates, public verifiability of sub-shards, etc.</p>
<p>In recent years, threshold signatures have been gradually applied in blockchain systems. Threshold signatures are commonly used in random oracles, censorship resistance, consensus algorithms, and distributed pseudorandom number generators.</p>
<p>Similar to the signature mechanism in asymmetric encryption, the threshold signature mechanism also consists of two parts: threshold key generation &amp; distribution, and threshold key signing.</p>
<p>When generating the threshold key, it relies on the Distributed Key Generation (DKG) protocol, which brings multiple participants together to generate a total key pair and key share that meets certain requirements. Each member corresponds to a private key shard, and each member can only know their own private key shard, no one knows the total private key. </p>
<p>Learn more <a href="8.CryptographyInIC/./SecretSharing.html">here</a>. </p>
<br>
<div style="break-before: page; page-break-before: always;"></div><p>Secret Sharing is an important technique in cryptography that provides a method for distributing secret information among multiple entities, thereby achieving control over the secret.</p>
<blockquote>
<p>It can implement both the (t) of (n) scheme and reduce the size of signature results, falling into the category of threshold signatures.</p>
<p>The key is divided into (n) pieces of key fragments, each saved by one of the (n) members. As long as at least (t) fragments of the secret are gathered, the complete key can be recovered, thus completing the signature.</p>
</blockquote>
<br>
<h2 id="what-is-secret-sharing"><a class="header" href="#what-is-secret-sharing">What is Secret Sharing</a></h2>
<p>In simple terms, Secret Sharing involves splitting a secret into multiple &quot;shares&quot; and distributing them to different entities. Only when a sufficient number of &quot;shares&quot; are collected can the secret be reconstructed. For example, a password can be split into 5 shares and given to individuals A, B, C, D, and E. It is specified that only by simultaneously collecting at least 3 shares held by different people can the password be reconstructed. Therefore, it is impossible to derive the original password using the shares of 1 or 2 individuals. This prevents information leakage from a single entity.</p>
<div class="center-image">
<img src="8.CryptographyInIC/assets/ÁßòÂØÜÂÖ±‰∫´/image-20231226145124652.png" style="zoom:39%;" />
</div>
<p>Secret Sharing can:</p>
<ul>
<li>Enhance the security of secrets by preventing single-point leakage through splitting and distribution.</li>
<li>Implement access control for secrets by specifying the minimum number of shares required to reconstruct the secret, achieving access policy control.</li>
<li>Improve the availability of secrets, allowing reconstruction of secret shares even if some shares are lost, resetting key fragments.</li>
</ul>
<br>
<h2 id="application-scenarios"><a class="header" href="#application-scenarios">Application Scenarios</a></h2>
<p>Secret Sharing technology is widely used in various scenarios, such as:</p>
<ul>
<li>Key management: Encrypt certificates or keys and distribute them into multiple shares to multiple certificate authorities or key management nodes, avoiding single-point failures.</li>
<li>Multi-signature accounts in blockchain: Require transactions to be approved by a certain number of nodes before taking effect.</li>
<li>Sensitive data storage: Split critical data into multiple shares and store them with different cloud service providers to prevent data leakage from a single provider.</li>
<li>Voting systems: Split voting keys based on threshold policies, and only collecting enough voting nodes can open the vote count.</li>
<li>Military permission control: Different levels of command need to collect the corresponding number of key shares to activate weapon systems.</li>
</ul>
<p>In practical applications, different Secret Sharing algorithms can be chosen based on the needs, determining the number of distributed shares, and the minimum number of shares required for reconstruction, thus achieving a customized access structure.</p>
<br>
<h2 id="secret-sharing-algorithms"><a class="header" href="#secret-sharing-algorithms">Secret Sharing Algorithms</a></h2>
<p>To implement Secret Sharing, relevant mathematical algorithms are required. The initial Secret Sharing algorithms were independently proposed by G. R. Blakley and A. Shamir in 1979. Common Secret Sharing algorithms include:</p>
<ul>
<li>Shamir's Secret Sharing: Based on polynomial interpolation, it is the most commonly used algorithm.</li>
<li>Asmuth-Bloom Secret Sharing: Shared using the Chinese Remainder Theorem.</li>
<li>Blakley's Geometric Secret Sharing: Based on the intersection points of hyperplanes.</li>
</ul>
<p>These algorithms usually rely on mathematical principles (such as polynomials, vector spaces, etc.) to split the secret into multiple shares, and only by collecting a sufficient number of shares can the secret be reconstructed. Due to space constraints, the details of the latter two algorithms are not discussed here, with a focus on introducing Shamir's Secret Sharing.</p>
<br>
<h2 id="shamirs-secret-sharing"><a class="header" href="#shamirs-secret-sharing">Shamir's Secret Sharing</a></h2>
<p>Shamir's Secret Sharing is a secret sharing algorithm based on polynomial interpolation, proposed by Adi Shamir in 1979.</p>
<p>It mainly involves two processes: splitting the secret and reconstructing the secret.</p>
<br>
<h3 id="splitting-the-secret"><a class="header" href="#splitting-the-secret">Splitting the Secret</a></h3>
<p>Choose a prime number (p), and construct a random polynomial of degree (t-1) in the integer ring (Z_p):</p>
<p>$$
f(x) = a_0 + a_1x + a_2x^2 + \ldots + a_{t-1}x^{t-1} \mod (p)
$$</p>
<p>Where (p) is a large prime, and (f(0) = a_0 = s) (where (s) is the secret), and (s &lt; p).</p>
<p>Generate (t-1) random numbers (a_1, a_2, \ldots, a_{t-1}) less than (p), and randomly select (n) distinct integers (x_1, x_2, \ldots, x_n).</p>
<p>Evaluate the polynomial at (n) points to obtain (n) values (s_1 = f(x_1), s_2 = f(x_2), \ldots, s_n = f(x_n)).</p>
<p>Distribute the (n) calculated values to (n) participants, where the (i)-th participant receives ((x_i, s_i)) (as the secret that the participant needs to strictly keep).</p>
<p>Finally, destroy (f(x)). According to the properties of the polynomial function, less than (t) participants cannot reconstruct this polynomial.</p>
<br>
<p>For example, let's take the example of (t = 3, n = 4). Here, (t) is the reconstruction threshold, and (n) is the total number of secret shares.</p>
<p>Assuming the secret (s = 2), (p = 23), the constructed (f(x)) is:</p>
<p>$$
f(x) = 2 + 3x + 2x^2 \mod (23)
$$</p>
<p>Choosing (x_1 = 1, x_2 = 2, x_3 = 3, x_4 = 4), and evaluating the function, we get (f(1) = 7, f(2) = 16, f(3) = 6, f(4) = 0). Thus, 4 secrets are split.</p>
<br>
<h3 id="reconstructing-the-secret"><a class="header" href="#reconstructing-the-secret">Reconstructing the Secret</a></h3>
<p>Since we have a (t, n) secret sharing ((3, 4)), with 4 secrets split, knowing any 3 of them can reconstruct the initial secret.</p>
<p>Here, (t) is set to (3), meaning the threshold for reconstructing the secret is (t).</p>
<p>Randomly select 3 sets of data ((1, 7), (3, 6), (4, 0)) and use Lagrange interpolation formula for reconstruction.</p>
<br>
<p>In the Shamir Secret Sharing algorithm, the secret (s) is the constant term of the polynomial. Given three points, we can use Lagrange interpolation to find the corresponding polynomial.</p>
<p>The general form of the Lagrange interpolation polynomial is:
$$
L(x) = \sum_{i=1}^{k} y_i \prod_{j=1, j\neq i}^{k} \frac{x - x_j}{x_i - x_j} \mod p
$$
where ((x_i, y_i)) are the given points.</p>
<p>$$
L(x) = 7 \cdot \frac{(x-3)(x-4)}{(1-3)(1-4)} + 6 \cdot \frac{(x-1)(x-4)}{(3-1)(3-4)} + 0 \cdot \frac{(x-1)(x-3)}{(4-1)(4-3)} \mod 23
$$
Simplifying, we get:</p>
<p>$$
f(x) = 2 + 3x + 2x^2 \mod (23)
$$
This matches the original polynomial we started with. Therefore, the secret (s) is the constant term of the polynomial, i.e., (s = 2). So, the secret (s) is 2.</p>
<br>
<p>This is the core idea of Shamir's Secret Sharing algorithm, which applies knowledge of abstract algebra and polynomial interpolation theory to provide information-theoretic security guarantees. This secret can be a private key or extended to any other information, such as encrypted information, puzzle answers, secret wills, etc.</p>
<p>It not only enables multi-party management but also provides a certain fault tolerance mechanism, allowing up to (n - t) share data to be lost.</p>
<br>
<p>However, technically, it belongs to single signature since, in the end, a private key signature needs to be reconstructed, rather than directly splitting multiple private key fragments for signing.</p>
<p>Threshold signatures, derived later, allow signing with the split private key fragments. Each member generates a signature fragment using their private key fragment, and by aggregating enough signature fragments, the complete signature can be reconstructed.</p>
<p>In the entire process of threshold signatures, the complete private key is never exposed, ensuring high security. Each member only knows their own portion of the private key fragment.</p>
<br>
<h3 id="shortcomings"><a class="header" href="#shortcomings">Shortcomings</a></h3>
<p>But!</p>
<p>The original Shamir key sharing scheme can only split the key and has several issues.</p>
<p>Firstly, the key distributor who knows the complete private key has single-point control over the key, posing a possibility of malicious behavior, such as issuing incorrect private key fragments to some members.</p>
<p>Additionally, holders of private key fragments may provide false fragments or distribute private keys only to a subset of people, not meeting the threshold! For example, if there are 7 members with a threshold of 5, but private keys are only given to 4 members - it cannot be used! Therefore, the integrity of distributing private keys also needs to be verified.</p>
<br>
<p>To address these issues, an improved mechanism based on Shamir key sharing is Verifiable Secret Sharing (VSS).</p>
<p>Regarding VSS, we will directly discuss the practical Feldman VSS scheme. Although there are other scheme designs from Shamir's key sharing (1979) to Feldman's VSS scheme (1987).</p>
<blockquote>
<p>The concept of VSS was first proposed by Benny Chor, Shafi Goldwasser, Silvio Micali, and others in 1985.</p>
</blockquote>
<br>
<h2 id="feldman-scheme---verifiable-secret-sharing"><a class="header" href="#feldman-scheme---verifiable-secret-sharing">Feldman Scheme - Verifiable Secret Sharing</a></h2>
<p>The Feldman Scheme is a verifiable secret sharing technique that allows the owner Alice of a key to split the key into multiple shares distributed to others. Moreover, these individuals can verify whether the received key share is correct, but they cannot obtain the entire original key.</p>
<p>To make the data of the distributed secret fragments verifiable, the person distributing the private key fragments, besides providing the private key fragments, must also provide the corresponding commitment ((c_0, c_1,... )).</p>
<br>
<p>The basic idea of this scheme is as follows:</p>
<p>Alice, as the private key distributor, selects a large prime number (p) and a generator (g), where (g) belongs to (Z_{p}^{*}) and is a (q)-order element. In practice, the key sharing involves operations in the cyclic group of a finite field, using the public (g) as the generator.</p>
<p>(q) is a large prime factor of (p - 1). Publicly disclose (p, q, g).</p>
<p>(s) is a randomly generated original key, (t) is the threshold, and (n) is the total number of members.</p>
<p>Generate the polynomial:
$$
f(x) = a_{0} + a_{1}x + a_{2}x^{2} + \ ...\ +a_{t-1}x^{t-1} \mod(p)
$$
where (a_0) represents the private key, i.e., the secret of the polynomial.</p>
<p>Compute the commitment:
$$
c_0=g^{a_0}, \ c_1=g^{a_1}, \ c_2=g^{a_2}, \ ..., \ c_{t-1}=g^{a_{t-1}}
$$</p>
<p>Alice publicly reveals the commitment ((c_0, c_1, \ ,\ c_2...\ ,\ c_{t-1})) to all members.</p>
<p>Next, Alice needs to split the private key (s) into (n) shares (s_i) and distribute them to (n) members.</p>
<p>A member who receives (s_i) can use the commitment to verify the private key fragment: calculate ( g^{s_{i}} = {\textstyle \prod_{j=0}^{k-1}} (C_j)^{i_{j}} \mod{p} ).</p>
<p>If the result is equal, it indicates that this private key fragment is correct. Since the commitment is bound to the coefficients, if Alice provides a commitment not using the real coefficients of the polynomial equation, the verification will fail.</p>
<p>Everyone can verify their own private key fragments, but no one can obtain (s) unless all (n) people collaborate.</p>
<br>
<p>Thus, the Feldman Scheme achieves verifiable secret sharing, ensuring the security of the key while allowing each person to verify that they have received the correct key fragment. This has applications in many cryptographic systems and blockchain technologies.</p>
<br>
<h2 id="updating-secrets---dynamic-secret-sharing"><a class="header" href="#updating-secrets---dynamic-secret-sharing">Updating Secrets - Dynamic Secret Sharing</a></h2>
<p>The Feldman Scheme added a verification step based on the original Shamir Scheme, addressing the issue of dishonest secret distributors in traditional secret sharing.</p>
<p>However, this scheme assumes that attackers cannot obtain enough private key fragments throughout the entire system's lifecycle. A more practical scenario is that attackers can slowly infiltrate different members over different time periods, compromising them one by one.</p>
<p>In cases where the secret itself has a long lifecycle, it is vulnerable to being compromised one by one. For example, if a node is subject to a virus attack, or if private key fragments are leaked or forgotten, verifiable secret sharing schemes may not maintain optimal security against prolonged destructive attacks.</p>
<p>While it is possible to mitigate this problem by changing the original private key (secret), there are situations where the private key must remain unchanged for an extended period (such as in business or military secrets).</p>
<br>
<p>Dynamic secret sharing schemes address the security issues of secret sharing schemes in long-term storage without changing the secret.</p>
<p>By periodically replacing private key fragments, each time a new set of fragments is replaced, any private keys obtained by attackers in the previous cycle become invalid.</p>
<p>This allows adjusting the length of the private key fragment retention period based on the potential threat to the key. For example, if the secrecy level of the private key is very high, the cycle for replacing private key fragments should be short and frequent. Conversely, for lower-security levels, the replacement cycle can be longer.</p>
<p>This ensures the security of the private key within each cycle, and expired private key fragments do not affect the newest ones. It eliminates the cumulative effect of secrets obtained by attackers in the previous cycle as time progresses.</p>
<p>In this way, even if an attacker gains a previous set of private keys for a node, they cannot forge the identity of that node in the next cycle. This is because the node has updated its private key. The attacker is unable to obtain the new private key for signing.</p>
<p>It's important to note that if an attacker not only obtains the old private key but also maintains control of the node in the next cycle, they can create a new key pair and broadcast it. However, since the real node will also broadcast its true new public key, there will be conflicting public keys in the network. Other nodes will detect this and determine that the node has been compromised. At this point, the node needs to be reset, and a completely new operating system and private key need to be installed.</p>
<br>
<p>There have been several dynamic secret sharing schemes proposed, and the scheme proposed by <a href="https://sites.google.com/site/amirherzberg/home">Amir Herzberg</a> in 1995 is a classic one. This scheme dynamically adapts Shamir's secret sharing scheme.</p>
<br><div style="break-before: page; page-break-before: always;"></div><h2 id="bilinear-mapping"><a class="header" href="#bilinear-mapping">Bilinear Mapping</a></h2>
<p>Bilinear mapping is a very important cryptographic primitive, usually denoted as \(e\): \(G_1\) \(\times\) \(G_2\) \(\rightarrow\) \(G_T\). Where \(G_1\), \(G_2\) and \(G_T\) are cyclic groups of the same order.</p>
<blockquote>
<p>Definition: A bilinear mapping is a function from two vector spaces to a third vector space, such that the function is linear in each of its arguments. </p>
</blockquote>
<p>The bilinear mapping \(e\) needs to satisfy the following two conditions:</p>
<ol>
<li>Bilinear For any \(g_1\in G_1\), \(g_2\in G_2\) and \(a,b\in\mathbb{Z}\), we have:</li>
</ol>
<p>$$e(g_1^a, g_2^b) = e(g_1, g_2)^{ab}$$</p>
<ol start="2">
<li>Non-degenerate There exist \(g_1\in G_1\) and \(g_2\in G_2\) such that: </li>
</ol>
<p>$$e(g_1,g_2)‚â†1_{G_T}$$</p>
<p>\(e\) needs to be homomorphic in each variable and cannot map all elements to 1.</p>
<p>If A, B, C are three vector spaces, and \(e:A\times B\rightarrow C\) is a bilinear mapping, then fixing A and varying B, the mapping from B to C is linear. Fixing B and varying A, the mapping from A to C is also linear. That is, keeping either parameter of the bilinear mapping fixed, the mapping of the other parameter to C is linear. </p>
<p>So a bilinear function has two inputs, and is linear in each input separately.</p>
<p>For example, matrix multiplication and Cartesian product of two database tables are examples of bilinear pairing.</p>
<p>Matrix multiplication satisfies:</p>
<p>\((A+B)C = AC + BC\) (linear in C) </p>
<p>\(A(B+C) = AB + AC\) (linear in A)</p>
<p>Cartesian product of two tables satisfies similar properties.</p>
<p>Bilinear mapping is a very powerful tool that enables many public key cryptosystems based on hard problems. For example, BLS signatures are built on the hardness of bilinear Diffie-Hellman problem.</p>
<p>Bilinear mappings are often implemented by pairing functions. Commonly used pairing functions include Tate pairing, Weil pairing, etc. These pairing functions can be constructed from specific elliptic curves. </p>
<p>Bilinear mapping allows easy conversion between groups and utilizing relationships between groups to design various cryptosystems. It is a critical foundation for many cryptographic protocols and an important development in modern cryptography.</p>
<br>
<h2 id="bls-signatures-1"><a class="header" href="#bls-signatures-1">BLS Signatures</a></h2>
<p>BLS signature is a digital signature scheme based on bilinear pairings. </p>
<p>The cryptography behind it is:</p>
<p>Choose a bilinear group \((G_1, G_2)\) where \(G_T\), \(G_1\) and \(G_2\) are cyclic groups of order a large prime \(q\). \(P\) is a generator of \(G_1\).</p>
<p>KeyGen: Generate keys by choosing a random private key \(sk\) and computing public key \(pk=sk‚àóP\). </p>
<p>Sign: To sign a message \(m\), first hash it to get \(H(m)\). Then compute signature \(œÉ = sk ‚àó H(m)\).</p>
<p>Verify: To verify a signature \(œÉ\), check if \(e(P, œÉ) = e(pk, H(m))\). Here \(e\) is a bilinear mapping. If equality holds, the signature is valid.</p>
<p>Why does this verification work? This relies on the <strong>pairing function</strong> we glossed over before, briefly introduced below:</p>
<p>There is a (or some) special function called \(e\) which takes as input two points \(P\) and \(Q\) on one (or two different) curves, and outputs a number: </p>
<p>$$e(P, Q) ‚Üí n$$</p>
<p>This function is considered special because it has some special properties. For example for a number \(x\) and two points \(P\) and \(Q\), no matter which point is multiplied, the function result is the same:</p>
<p>$$e(x‚àóP, Q) = e(P, x‚àóQ)$$</p>
<p>Furthermore: </p>
<p>$$e(a‚àóP, b‚àóQ) = e(P, ab‚àóQ) = e(ab‚àóP, Q) = e(P, Q)^{ab}$$</p>
<p>Of course there are other properties, but the above are most relevant for signature verification.</p>
<p>The security of BLS signatures relies on the hardness of the bilinear Diffie-Hellman problem. It only requires two group operations for signing and verification, so is very efficient. It also has short signatures and provides randomness.</p>
<p>BLS supports simple signature aggregation: multiple BLS signatures can be aggregated into a single short signature through group operations. Verification is done by pairing the aggregated signature. </p>
<p>Now given a single signature, let's look at aggregated signatures.</p>
<br>
<h2 id="threshold-bls-signatures-2"><a class="header" href="#threshold-bls-signatures-2">Threshold BLS Signatures</a></h2>
<p>In blockchain systems, signature verification is a very important and frequent operation to ensure security. Typically each transaction input requires a signature for verification. But for collaborative scenarios like multi-sig addresses, this can lead to rapidly growing transaction sizes and reduced processing efficiency.</p>
<p>To address this, researchers proposed the threshold BLS signature scheme. BLS signatures are a very efficient digital signature method, based on bilinear pairings, requiring just short signatures for security. The threshold BLS signature scheme builds on this, to aggregate multiple BLS signatures into one, greatly reducing storage and transmission costs.</p>
<br>
<p>How do threshold BLS signatures work? Let's briefly review the principles of BLS signatures themselves. It requires: a bilinear pairing function, two cyclic groups G1 and G0, a generator P of G1, and a hash function H. Key generation randomly chooses a number sk, and computes public key pk=sk*P. Signing is hashing the message H(m), then computing signature œÉ = sk * H(m). Verification checks if the pairing equation e(P, œÉ) = e(pk, H(m)) holds.</p>
<br>
<p>This verification equation also explains why signature aggregation is possible. If there are n signatures all signing the same message m, multiplying all the signatures together, the verification equation still holds. So the verifier only needs one aggregated short signature to verify n signatures simultaneously, greatly improving efficiency. </p>
<p>Multiple BLS signatures can be simply multiplied to get the aggregated signature. That is, for \((pk_1,m_1,œÉ_1),..., (pk_n,m_n,œÉ_n)\), compute:</p>
<p>$$œÉ = œÉ_1 * ... * œÉ_n$$</p>
<p>To verify the aggregated signature œÉ, check the signature verification equation for each signature separately.</p>
<p>When the signed messages m are the same, verification can be further simplified to: </p>
<p>$$e(g_1, œÉ) = e(pk_1 * ... * pk_n, H(m))$$</p>
<p>This requires only 2 pairing operations. This is the advantage of BLS signature aggregation.</p>
<br>
<p>However, direct signature aggregation is insecure, due to &quot;rogue key attack&quot; risks. To address this, threshold BLS signatures introduce a new hash function H1. This hash function takes all participating signers' public keys as input, and outputs a &quot;weight&quot; for each user. To compute the secure aggregated signature, each user's signature is raised to the power of their weight. The key idea is to introduce a random exponent for each public key, determined by the hash of all public keys.</p>
<p>Verification is similar, recomputing the weights for each user, aggregating public keys by the weights, and checking against standard BLS signature verification. So verifying multiple signatures has the same efficiency as a single signature. This mechanism effectively prevents rogue key attacks, as each user's signature contribution is precisely controlled.</p>
<ol>
<li>Generate key pair \((sk, pk=g1^sk)\).</li>
<li>Sign message \(m\), output \(œÉ = H(m)^sk\).</li>
<li>For aggregation, compute weights \((t_1,...,t_n) = H1(pk_1,...,pk_n)\) for all public keys. </li>
<li>Compute aggregated signature \(œÉ = œÉ_1^{t_1} * ... * œÉ_n^{t_n}\).</li>
<li>For verification, compute \((t_1,...,t_n) = H1(pk_1,...,pk_n)\), and aggregated public key \(apk = pk_1^{t_1} * ... * pk_n^{t_n}\).</li>
<li>Check \(e(g_1, œÉ) = e(apk, H(m))\), equal if valid.</li>
</ol>
<p>This scheme prevents public key substitution attacks, and is theoretically secure based on the co-CDH assumption. It retains the advantages of BLS signature aggregation, without requiring proof of secret key knowledge. Thus it is a good threshold BLS signature improvement. </p>
<br>
<p>The threshold BLS signature mechanism is very suitable for blockchain systems. It not only reduces transaction size and storage, but also enables batch transaction verification for further performance gains. Threshold BLS signatures enable non-interactive aggregation, providing more flexibility. In the future, combined with aggregate public key proofs (POP), it can completely hide users' public key information.</p>
<p>As blockchain enters a new phase of large-scale commercialization, various efficiency and privacy technologies will become increasingly important. Threshold BLS signatures provide a very practical tool.</p>
<br>
<p>The main works in BLS signature algorithms are curve pairing and signature aggregation.</p>
<p>Curve pairing requires a special function that maps two points on a curve to a number, satisfying the property that multiplying either point by an unknown x results in the same output. Such functions exist and do not leak any information about x (security). </p>
<p>For verification, we just check if the mapping of the public key and hash of message (two points on the curve) equals the mapping of the curve generator and signature (two other points). If so, the BLS signature is valid.</p>
<p>Of course, BLS signatures are not perfect. Their complexity is an order of magnitude higher than ECDSA. When verifying the aggregated signature of 1000 transactions in a block, 1000 pairings are still required, possibly slower than verifying 1000 separate ECDSA signatures. The only benefit is fitting more transactions per block, since aggregated signatures are just 32 bytes. There is also a MOV attack on elliptic curve cryptosystems using the pairing function to compromise security.</p>
<br>
<p>A comparison of ECDSA, Schnorr and BLS signature algorithms:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>ECDSA</th><th>Schnorr</th><th>BLS</th></tr></thead><tbody>
<tr><td>Verifying multiple signatures</td><td>Each signature and public key</td><td>Aggregated signature and public key per transaction [1]</td><td>Aggregated signature and public key per block</td></tr>
<tr><td>Random number generation</td><td>Specify random point</td><td>Relies on RNG</td><td>No RNG needed</td></tr>
<tr><td>Signer communication</td><td></td><td>Required</td><td>Not required</td></tr>
<tr><td>Signature length</td><td>320 bits</td><td>320 bits</td><td>160 bits</td></tr>
</tbody></table>
</div>
<p>[1] Schnorr signatures can aggregate all signatures and public keys in a transaction into a single signature and public key, indistinguishable from individual ones. Verifying the aggregated signature speeds up block verification.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><p>Hash algorithms, also commonly referred to as fingerprint or digest algorithms, are a fundamental and crucial type of algorithm.</p>
<p>The origin of hash algorithms can be traced back to the 1950s, designed to address the issue of ensuring information integrity verification.</p>
<p>In the transmission and storage of digital information, it is essential to guarantee that information has not been unlawfully altered. This process is known as data integrity verification. Initially, encryption algorithms were considered for achieving integrity verification, but encryption algorithms serve their own purposes and are not well-suited for integrity verification.</p>
<br>
<p>Therefore, in the 1950s, some cryptographers, such as Ralph Merkle, proposed the use of &quot;manipulation detection codes&quot; to verify information integrity. This method involves extracting a shorter fixed-length value, known as the hash value, from the original information using a function. If the information is modified during transmission, the extracted hash value will also change.</p>
<p>In this way, the receiving party only needs to run the hash function again on the received information and check if the extracted hash value matches the one provided by the sender to verify whether the information has been altered during transmission. This method is both simple and effective, and it does not require the transmission or storage of any keys.</p>
<br>
<p>Subsequently, researchers proposed improved hash function algorithms, such as MD5, SHA-1, etc., to counter intentional attacks. This made information integrity verification based on hash functions more reliable.</p>
<p>Over time, hash functions have been widely applied in various fields, including digital signatures, blockchain, data storage, etc., due to their unique &quot;avalanche effect.&quot; They have become an indispensable component of modern information security infrastructure.</p>
<p>In summary, hash algorithms were designed to address the challenge of quickly and effectively verifying integrity in information transmission. They have evolved into an essential tool in the digital world, resolving a crucial trust issue.</p>
<br>
<p>Hash algorithms can map arbitrary-length binary plaintext into a shorter (usually fixed-length) binary string, known as the hash value. Different binary plaintexts are challenging to map to the same binary string.</p>
<p>A message digest refers to using a one-way hash function to extract a fixed-length ciphertext from the data that needs to be digested. This ciphertext is also called a digital fingerprint. The digital fingerprint has a fixed length, and different plaintexts will always produce different results when extracting the digest. However, the digest for the same plaintext is consistent. Since there are no restrictions on the plaintext used for generating the digest, and the digest is of a fixed length, some plaintexts will inevitably produce the same digest. This phenomenon is called &quot;collision.&quot; To avoid collisions, hash functions must have good collision resistance, meaning it is impractical to find a collision within existing computational resources (including time, space, funds, etc.).</p>
<p>A notable feature of message digest algorithms is that during the input message process, even a slight change in the message, such as altering one bit in the input message binary data, will result in vastly different output results. Therefore, message digest algorithms are useful for detecting small changes in objects such as messages or keys. Three key characteristics of message digest algorithms can be inferred:</p>
<ol>
<li>The input length for message digest algorithms is arbitrary, while the output length is fixed.</li>
<li>Given the input for message digest algorithms, calculating the output is straightforward.</li>
<li>Common message digest algorithms include MD5, SHA, SHA256, SHA512, SM3, etc.</li>
</ol>
<br>
<p>Message digest algorithms are not encryption algorithms and cannot be used to protect information. However, they are commonly employed to store passwords securely. For example, when users log in to a website and need to be authenticated using a username and password, storing plaintext passwords directly in the website's backend poses significant risks in the event of a data breach. To mitigate this risk, websites can utilize the characteristics of hash algorithms. Instead of storing plaintext passwords, they store the hash values of user passwords. During login, the website compares the hash value of the entered password with the stored hash value. Even in the case of a data breach, it is challenging to deduce the original login password from the one-way hash value.</p>
<p>However, in some cases, if user passwords are weak, using simple strings like &quot;123456,&quot; attackers can precompute hash values for such passwords, creating a mapping between passwords and hash values to facilitate cracking. To enhance security, websites often calculate hash values with added random characters (salt), separating the hash values from the passwords. This significantly increases security.</p>
<br>
<p>Message digest algorithms can be used to verify data integrity, but only when the digest and data are transmitted separately. Otherwise, attackers can modify both data and digest simultaneously to evade detection. Message Authentication Code (MAC) or Keyed Hash is a cryptographic function that extends the digest function with authentication. Only with the digest key can a legitimate MAC be generated.</p>
<p>MAC is typically used alongside ciphertext. While encrypted communication ensures confidentiality, it does not guarantee the integrity of the communicated message. If an attacker has the ability to modify ciphertext in Alice and Bob's communication, they can induce Bob to receive and trust forged information. However, when MAC and ciphertext are sent together, Bob can confirm that the received message has not been tampered with.</p>
<p>Any message digest algorithm can serve as the foundation for MAC, and one fundamental approach is based on a digest-based Message Authentication Code (Hash-based Message Authentication Code, HMAC). HMAC essentially intertwines the digest key and message in a secure manner.</p>
<br>
<br><div style="break-before: page; page-break-before: always;"></div><h2 id="common-dfx-commands"><a class="header" href="#common-dfx-commands">Common DFX Commands</a></h2>
<h2 id="dfx-common-commands"><a class="header" href="#dfx-common-commands">dfx Common Commands</a></h2>
<p>DFINITY Command-Line Interface (dfx) is the primary tool for creating, deploying, and managing DApps on the Internet Computer (IC).</p>
<p>All dfx commands can be found in the <a href="https://internetcomputer.org/docs/current/references/cli-reference">official documentation</a>. Here, we list some commonly used commands in practice.</p>
<br>
<pre><code class="language-bash"># Check dfx version
dfx --version
# Upgrade dfx
dfx upgrade

# Get help for a specific command
dfx help
dfx help new # View help information for the new command

dfx new hello_ic # Create a new project named hello_ic
</code></pre>
<br>
<h3 id="identity-related"><a class="header" href="#identity-related">Identity-related:</a></h3>
<pre><code class="language-bash"># List all identities
dfx identity list
# Display the current principal-id
dfx identity get-principal
# Query the name of the developer identity
dfx identity whoami
# Display the account-id for receiving transfers
dfx ledger account-id
# Transfer from one account to another
dfx --identity xxxx ledger --network ic transfer --memo 0 --amount 0.5
# Create a new identity named neutronstarpro
dfx identity new neutronstarpro
# Use a specific identity
dfx identity use neutronstarpro
# Check the balance of the current account in ICP
dfx ledger --network ic balance
# Check the balance of the account for the identity named neutronstarpro
dfx --identity neutronstarpro ledger --network ic balance
</code></pre>
<br>
<h3 id="wallet-related"><a class="header" href="#wallet-related">Wallet-related:</a></h3>
<pre><code class="language-bash"># Display the id of the current cycles wallet
dfx identity --network ic get-wallet
# Check the current balance of cycles in the wallet
dfx wallet --network ic balance
# Recharge cycles to a specific canister
dfx canister --network ic deposit-cycles 1000000 your-canister-principal
# Convert 1 ICP in dfx to cycles and recharge the canister
dfx ledger top-up $(dfx canister id your-canister-name) --amount 1
===================================================================================================
# Create a canister and convert 10 ICP from the dfx account into cycles for the canister recharge; --amount means converting the specified ICP to cycles
dfx ledger --network ic create-canister $(dfx identity get-principal) --amount 10
# Install the cycles wallet in the canister; after installation, this canister becomes a wallet-specific canister
dfx identity --network ic deploy-wallet &lt;canister-id&gt;
# Recharge the cycles wallet under the default identity (adjust the amount according to the situation)
dfx wallet --network ic send $(dfx identity --network ic get-wallet) 80000590000
</code></pre>
<br>
<h3 id="deployment-related"><a class="header" href="#deployment-related">Deployment-related:</a></h3>
<pre><code class="language-bash"># Start the local environment
dfx start
# Clear the cache and start the local environment
dfx start --clean
# Start the local environment in the background, invisible
dfx start --background
# Start the local environment in emulator mode
dfx start --emulator
# Start the local environment in no-artificial-delay mode (the default local environment simulates the IC network with artificial delays and consensus time)
dfx start -no-artificial-delay
# Deploy to local
dfx deploy
# Stop the local container execution environment process running on the local computer
dfx stop
# ====================================================================================
# Check the current status of the IC network and whether it can be connected
dfx ping ic
# Deploy to the IC network
dfx deploy --network ic
# Deploy to the IC network, specifying 1T cycles for each canister
dfx deploy --network ic --with-cycles=1000000000000
# Deploy a single canister
dfx deploy --network ic &lt;dapp_name&gt;
</code></pre>
<br>
<h3 id="canister-related"><a class="header" href="#canister-related">Canister-related:</a></h3>
<pre><code class="language-bash"># Query the canister-id named hello_assets under your own identity
dfx canister --network ic id hello_assets
# =============================================================
# Get the status of all canisters; --all can be replaced with the id or name of the canister
dfx canister --network ic status --all
# Stop running canisters
dfx canister --network ic stop --all
# Uninstall code in canisters
dfx canister --network ic uninstall-code --all
# Delete canisters and reclaim cycles
dfx canister --network ic delete --all
# Redeploy canisters, clearing all data in canisters
dfx deploy --network ic &lt;canister_name&gt; --mode reinstall
# Or
dfx canister install &lt;canister_name&gt; --mode reinstall
</code></pre>
<br>
<pre><code class="language-bash"># Download DFX from Dfinity's Github repository, unzip it, and set the environment variable to use it directly
# If different versions of DFX are installed on the computer, use the environment variable to determine which version of DFX to use
# I set the DFX environment in the .profile file
export PATH=/home/neutronstarpro/.dfx:$PATH
</code></pre>
<br>
<pre><code class="language-shell">DFX_CONFIG_ROOT=~/ic-root
</code></pre>
<p>Use the DFX_CONFIG_ROOT environment variable to specify a different location to store the .cache and .config subdirectories of dfx.</p>
<p>By default, the .cache and .config directories are located in the main directory of the development environment. For example, on macOS, the default location is in <code>/Users/&lt;YOUR-USER-NAME&gt;</code>. Use the DFX_CONFIG_ROOT environment variable to specify a different location for these directories.</p>
<br>
<pre><code class="language-shell">DFX_INSTALLATION_ROOT
</code></pre>
<p>If you are not using the default location of the operating system, use the <code>DFX_INSTALLATION_ROOT</code> environment variable to specify a different location for the dfx binary.</p>
<p>The <code>.cache/dfinity/uninstall.sh</code> script uses this environment variable to identify the root directory of the DFINITY Canister SDK installation.</p>
<br>
<p><code>DFX_TELEMETRY_DISABLED</code> is an option to choose whether telemetry data about dfx usage is collected.</p>
<p>By default, dfx collects anonymous information‚Äîno IP address or user information, etc.‚Äîabout dfx command activities and errors. Anonymous data collection is enabled by default to improve the developer experience based on usage patterns and behavior.</p>
<p>To disable anonymous data collection, explicitly set the <code>DFX_TELEMETRY_DISABLED</code> environment variable to 1.</p>
<pre><code class="language-bash">DFX_TELEMETRY_DISABLED=1
</code></pre>
<br><div style="break-before: page; page-break-before: always;"></div><h2 id="install-development-environment"><a class="header" href="#install-development-environment">Install Development Environment</a></h2>
<h3 id="install-dfx"><a class="header" href="#install-dfx">Install dfx</a></h3>
<p>We need to install the DFINITY Canister SDK (dfx), which is the core tool for developing IC applications. You can download it from the <a href="https://internetcomputer.org/docs/current/developer-docs/setup/install/">official website</a> and follow the instructions for installation.</p>
<p>Execute the following command in the terminal on Mac/Linux:</p>
<pre><code class="language-shell">sh -ci &quot;$(curl -fsSL https://internetcomputer.org/install.sh)&quot;
</code></pre>
<p>For Windows systems, <code>dfx</code> itself does not support Windows. We need to install <a href="https://learn.microsoft.com/en-us/windows/wsl/install">WSL (Windows Subsystem for Linux)</a> first and then continue with the installation in the Linux subsystem.</p>
<p>If you want to write backend code in Rust, you also need to install <a href="https://github.com/dfinity/cdk-rs">CDK (Canister Development Kit)</a>. However, this tutorial only uses Motoko for backend code, so we won't go into detail about Rust.</p>
<p>Rust is more powerful, supports more libraries, but has a steeper learning curve. Motoko is simple and easy to learn, suitable for beginners.</p>
<br>
<p>After installing dfx, a pair of public and private keys will be generated locally, corresponding to the developer's principal id. The private key is crucial as it represents the developer's identity and controls the Canisters under the developer's identity. The private key files are stored in <code>\.config\dfx\identity</code>. If you need to switch computers, you can transfer these private key files to the <code>\.config\dfx\identity</code> directory on the new computer.</p>
<br>
<p>The principal id is the developer's identity, used for deploying DApps locally and on the mainnet. Both local deployment and mainnet deployment use the same principal id (developer's identity). The only difference is that local deployment uses a local wallet, while mainnet deployment requires installing a wallet on the mainnet. This wallet is also a Canister. When developers deploy DApps, they first check the balance of Cycles in the developer's identity wallet on the mainnet, and then use the wallet Canister to create a new Canister on the mainnet and install the compiled Wasm bytecode in the new Canister.</p>
<br>
<h3 id="install-nodejs"><a class="header" href="#install-nodejs">Install Nodejs</a></h3>
<p><a href="https://nodejs.org">https://nodejs.org</a></p>
<p>dfx uses Node.js to generate frontend code and dependencies. For DApps without a frontend interface, it is not mandatory, but for you following this developer journey series, it is necessary as you will explore frontend Canisters in later tutorials.</p>
<br>
<h3 id="install-vscode"><a class="header" href="#install-vscode">Install VSCode</a></h3>
<p>It is recommended to use <a href="https://code.visualstudio.com/download">Visual Studio Code</a>, a mainstream and user-friendly editor that is fast, free, and highly versatile. You can also install the Motoko plugin (<a href="https://github.com/dfinity/vscode-motoko">extension</a>) for Motoko development support.</p>
<br>
<h3 id="install-git"><a class="header" href="#install-git">Install Git</a></h3>
<p><a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
<p>Many open-source code repositories are hosted on GitHub. Git is essential for publishing, downloading, and managing open-source code, making it a necessary tool for developing DApps.</p>
<br>
<p>Return to <a href="9.DevelopingDApp/1.GettingStartedwithDApp.html#preparation">Getting Started with DApp</a> to continue reading.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="quick-start-guide-for-dapp-development"><a class="header" href="#quick-start-guide-for-dapp-development">Quick Start Guide for DApp Development</a></h2>
<p>The Internet Computer (IC), short for Internet Computer, is a public blockchain platform introduced by the DFINITY Foundation. It aims to expand the functionality of blockchain to host websites and backend software.</p>
<p>IC, through innovative protocols and advanced technology, offers unparalleled speed, storage efficiency, and the capability to deploy websites directly on the chain.</p>
<p>Its core features include:</p>
<ul>
<li><strong>Decentralization</strong>: IC is a decentralized cloud service system, reliable, with no single points of failure.</li>
<li><strong>Scalability</strong>: The structure of IC allows for infinite scalability while maintaining high performance.</li>
<li><strong>Interoperability</strong>: Different applications on IC can seamlessly interact, providing a smoother user experience.</li>
<li><strong>Cost Efficiency</strong>: IC offers low-cost computing resources, cheaper than other blockchains and traditional cloud services.</li>
</ul>
<br>
<h2 id="dapp"><a class="header" href="#dapp">DApp</a></h2>
<p>DApp (Decentralized Application) refers to decentralized applications running on a blockchain network. Unlike traditional centralized applications, DApp is not controlled by any individual, and its internal data is tamper-proof.</p>
<p>The decentralization of DApp is attributed to the application of blockchain technology. Blockchain is a distributed database composed of multiple nodes, each storing a complete copy of the data. Consensus algorithms in blockchain ensure data consistency.</p>
<p>Smart contracts act like automated vending machines, without the need to trust any third party: the deployer of the vending machine, machine provider, city management, etc. An automated vending machine not controlled by any single entity! </p>
<img src="9.DevelopingDApp/assets/1.GettingStartedwithDApp/image-20240206121640220.png" alt="img" style="zoom:39%;" />
<p>Developing a DApp on IC is straightforward: you need a front-end canister and several back-end canisters.</p>
<ol>
<li><strong>Smart Contract Development (Back-end):</strong> Contracts running on the blockchain, defining the core business logic of the DApp.</li>
<li><strong>User Interface (Front-end):</strong> The interface through which users interact with the DApp, which can be a webpage, mobile app, or other forms.</li>
</ol>
<p>Contracts are written in Motoko or Rust and deployed in canisters to run after being compiled into Wasm bytecode.</p>
<br>
<h2 id="developing-dapp-on-ic"><a class="header" href="#developing-dapp-on-ic">Developing DApp on IC</a></h2>
<h3 id="preparations"><a class="header" href="#preparations">Preparations</a></h3>
<p>Before getting started, you need some basic knowledge and tools:</p>
<ul>
<li><strong>Install Necessary Software:</strong> This includes the DFINITY Canister SDK (dfx), the command-line tool for IC. If not installed yet, check <a href="9.DevelopingDApp/%E5%AE%89%E8%A3%85%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">here</a> for installation.</li>
<li><strong>Choose Programming Language:</strong> Mainly use Motoko (specifically designed for IC) and Rust. Other supported languages include <a href="https://demergent-labs.github.io/kybra">Python</a>, <a href="https://demergent-labs.github.io/azle">TS</a>, <a href="https://docs.icpp.world">C++</a>.</li>
</ul>
<br>
<h3 id="considered-best-practices"><a class="header" href="#considered-best-practices">Considered Best Practices</a></h3>
<ul>
<li><strong>Code Security:</strong> Always ensure smart contract code is secure.</li>
<li><strong>User Experience:</strong> Design an intuitive and responsive user interface.</li>
<li><strong>Contract Upgrades:</strong> Plan how to update and upgrade smart contracts.</li>
<li><strong>Resource Optimization:</strong> Optimize contracts to reduce resource consumption and costs.</li>
</ul>
<br>
<h3 id="practical-analysis"><a class="header" href="#practical-analysis">Practical Analysis</a></h3>
<p>Let's start with a Web3 version of LinkedIn demo, analyze the code, and attempt to add new features.</p>
<p>LinkedUp's <a href="https://github.com/dfinity/linkedup">source code</a> is in the DFINITY official repository. Now, let's try to understand the code (ignoring the frontend for now).</p>
<p>Since we aim to build a social network, the main <strong>requirements</strong> are:</p>
<ul>
<li>Users can create their own profiles.</li>
<li>Users can modify their profile information.</li>
<li>Users can view information on others' profiles.</li>
<li>Users can follow each other to establish connections.</li>
</ul>
<br>
<p>Let's first look at the <code>dfx.json</code> file in the project's root directory.</p>
<p>The <code>dfx.json</code> file is the basic configuration file for the entire project. It provides information about which canisters are in the project, where these canisters are located, the dfx version, and more.</p>
<p>The project includes three canisters: Connectd, Linkedup, and Linkedup_assets.</p>
<pre><code class="language-json">{
  &quot;canisters&quot;: {
    &quot;connectd&quot;: {
      &quot;main&quot;: &quot;src/connectd/main.mo&quot;
    },
    &quot;linkedup&quot;: {
      &quot;main&quot;: &quot;src/linkedup/main.mo&quot;
    },
    &quot;linkedup_assets&quot;: {
      &quot;dependencies&quot;: [&quot;linkedup&quot;],
      &quot;frontend&quot;: {
        &quot;entrypoint&quot;: &quot;src/linkedup/public/main.js&quot;
      },
      &quot;type&quot;: &quot;assets&quot;,
      &quot;source&quot;: [
        &quot;src/linkedup/public&quot;,
        &quot;dist/linkedup_assets&quot;
      ]
    }
  },
  &quot;defaults&quot;: {
    &quot;build&quot;: {
      &quot;packtool&quot;: &quot;&quot;
    }
  },
  &quot;networks&quot;: {
    &quot;tungsten&quot;: {
      &quot;providers&quot;: [&quot;https://gw.dfinity.network&quot;],
      &quot;type&quot;: &quot;persistent&quot;
    },
    &quot;local&quot;: {
      &quot;bind&quot;: &quot;0.0.0.0:8000&quot;,
      &quot;type&quot;: &quot;ephemeral&quot;
    }
  },
  &quot;dfx&quot;: &quot;0.6.22&quot;
}
</code></pre>
<h4 id="project-backend-structure"><a class="header" href="#project-backend-structure">Project Backend Structure:</a></h4>
<ul>
<li>
<p>Linkedup Canister is responsible for business logic, such as creating personal profiles and modifying profile information. It also provides API interfaces for Linkedup to call Connectd Canister, allowing the frontend to interact only with Linkedup.</p>
</li>
<li>
<p>Connectd Canister primarily establishes relationships between users, providing APIs for Linkedup Canister to call.</p>
</li>
</ul>
<br>
<h3 id="connectd-canister"><a class="header" href="#connectd-canister">Connectd Canister</a></h3>
<p>Let's carefully analyze the code of the Connectd Canister:</p>
<pre><code class="language-json">‚îú‚îÄ‚îÄ connectd
‚îÇ   ‚îú‚îÄ‚îÄ digraph.mo
‚îÇ   ‚îú‚îÄ‚îÄ main.mo
‚îÇ   ‚îî‚îÄ‚îÄ types.mo
</code></pre>
<p>Under the Connectd Canister, there are three Motoko files:</p>
<ul>
<li><code>main.mo</code> is the main code file of the Connectd Canister, defining an <code>actor</code>.</li>
<li><code>types.mo</code> is the module file containing custom type definitions, imported and used in <code>main.mo</code>.</li>
<li><code>digraph.mo</code> is a module file defining a public class that <code>main.mo</code> can instantiate and use its API to handle relationship data.</li>
</ul>
<p>Now, let's delve into the code line by line.</p>
<br>
<p>In <code>types.mo</code>, some custom types are defined:</p>
<pre><code class="language-js">import Principal &quot;mo:base/Principal&quot;;

module {
  public type Vertex = Principal;
};
</code></pre>
<br>
<p><code>digraph.mo</code> is a module file that implements a simple directed graph data structure, providing basic functionalities such as adding vertices, adding edges, and querying adjacent vertices. This implementation allows easy construction and manipulation of a directed graph.</p>
<p>The code defines a class for a &quot;User Relationship Graph&quot; (Digraph) to represent relationships between users. This graph is a directed graph where users are considered vertices, and relationships between users are considered directed edges.</p>
<pre><code class="language-js">import Array &quot;mo:base/Array&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Types &quot;./types&quot;;

module {
  type Vertex = Types.Vertex;

  public class Digraph() {
    var vertexList: [Vertex] = [];
    var edgeList: [(Vertex, Vertex)] = [];

    public func addVertex(vertex: Vertex) {
      vertexList := Array.append&lt;Vertex&gt;(vertexList, [vertex]);
    };

    public func addEdge(fromVertex: Vertex, toVertex: Vertex) {
      edgeList := Array.append&lt;(Vertex, Vertex)&gt;(edgeList, [(fromVertex, toVertex)]);
    };

    public func getAdjacent(vertex: Vertex): [Vertex] {
      var adjacencyList: [Vertex] = [];
      for ((fromVertex, toVertex) in Iter.fromArray&lt;(Vertex, Vertex)&gt;(edgeList)) {
        if (fromVertex == vertex) {
          adjacencyList := Array.append&lt;Vertex&gt;(adjacencyList, [toVertex]);
        };
      };
      adjacencyList
    };
  };
};
</code></pre>
<br>
<p><code>main.mo</code> manages the connections between users. It defines APIs that can be called externally, and the graph-related operations are performed by instantiating the graph class.</p>
<p>This helps organize and query relationships between users, suitable for scenarios such as social networks and relationship graphs.</p>
<pre><code class="language-js">import Digraph &quot;./digraph&quot;;
import Types &quot;./types&quot;;

actor Connectd {
  type Vertex = Types.Vertex;
  var graph: Digraph.Digraph = Digraph.Digraph();

  public func healthcheck(): async Bool { true };

  public func connect(userA: Vertex, userB: Vertex): async () {
    graph.addEdge(userA, userB);
  };

  public func getConnections(user: Vertex): async [Vertex] {
    graph.getAdjacent(user)
  };
};
</code></pre>
<h3 id="linkedup-canister"><a class="header" href="#linkedup-canister">Linkedup Canister</a></h3>
<p>After understanding the Connectd Canister, let's look at the Linkedup Canister. Remember that the Connectd Canister serves the Linkedup Canister.</p>
<p>Similarly, let's check the directory structure of Linkedup Canister:</p>
<pre><code class="language-json">linkedup
    ‚îú‚îÄ‚îÄ database.mo
    ‚îú‚îÄ‚îÄ main.mo
    ‚îú‚îÄ‚îÄ types.mo
    ‚îî‚îÄ‚îÄ utils.mo
</code></pre>
<p>Linkedup Canister also has <code>main.mo</code> and <code>type.mo</code>. <code>main.mo</code> handles the main business logic, <code>types.mo</code> is responsible for defining new types, and the added <code>utils.mo</code> module contains commonly used utility functions.</p>
<p>The <code>database.mo</code> module, similar to the previous <code>digraph.mo</code>, defines a simple database module. It deals with data structures and corresponding processing functions related to business logic.</p>
<p>Now, let's dive into the code.</p>
<p>In <code>types.mo</code>, three types are defined: <code>UserId</code>, <code>NewProfile</code>, and <code>Profile</code>:</p>
<pre><code class="language-js">import Principal &quot;mo:base/Principal&quot;;

module {
  public type UserId = Principal;

  public type NewProfile = {
    firstName: Text;
    lastName: Text;
    title: Text;
    company: Text;
    experience: Text;
    education: Text;
    imgUrl: Text;
  };

  public type Profile = {
    id: UserId;
    firstName: Text;
    lastName: Text;
    title: Text;
    company: Text;
    experience: Text;
    education: Text;
    imgUrl: Text;
  };
};
</code></pre>
<p>The <code>database.mo</code> module implements a simple user directory system. It defines a public class named <code>Directory</code>, which internally contains a <code>hashMap</code>. This <code>hashMap</code> has keys of type <code>UserId</code> and values of type <code>Profile</code>, storing and querying user profiles.</p>
<pre><code class="language-js">import Array &quot;mo:base/Array&quot;;
import HashMap &quot;mo:base/HashMap&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Option &quot;mo:base/Option&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Types &quot;./types&quot;;

module {
  type NewProfile = Types.NewProfile;
  type Profile = Types.Profile;
  type UserId = Types.UserId;

  public class Directory() {
    let hashMap = HashMap.HashMap&lt;UserId, Profile&gt;(1, isEq, Principal.hash);

    public func createOne(userId: UserId, profile: NewProfile) {
      hashMap.put(userId, makeProfile(userId, profile));
    };

    public func updateOne(userId: UserId, profile: Profile) {
      hashMap.put(userId, profile);
    };
     
    public func findOne(userId: UserId): ?Profile {
      hashMap.get(userId)
    };

    public func findMany(userIds: [UserId]): [Profile] {
      func getProfile(userId: UserId): Profile {
        Option.unwrap&lt;Profile&gt;(hashMap.get(userId))
      };
      Array.map&lt;UserId, Profile&gt;(userIds, getProfile)
    };

    public func findBy(term: Text): [Profile] {
      var profiles: [Profile] = [];
      for ((id, profile) in hashMap.entries()) {
        let fullName = profile.firstName # &quot; &quot; # profile.lastName;
        if (includesText(fullName, term)) {
          profiles := Array.append&lt;Profile&gt;(profiles, [profile]);
        };
      };
      profiles
    };

    func makeProfile(userId: UserId, profile: NewProfile): Profile {
      {
        id = userId;
        firstName = profile.firstName;
        lastName = profile.lastName;
        title = profile.title;
        company = profile.company;
        experience = profile.experience;
        education = profile.education;
        imgUrl = profile.imgUrl;
      }
    };

    func includesText(string: Text, term: Text): Bool {
      let stringArray = Iter.toArray&lt;Char&gt;(string.chars());
      let termArray = Iter.toArray&lt;Char&gt;(term.chars());

      var i = 0;
      var j = 0;

      while (i &lt; stringArray.size() and j &lt; termArray.size()) {
        if (stringArray[i] == termArray[j]) {
          i += 1;
          j += 1;
          if (j == termArray.size()) { return true; }
        } else {
          i += 1;
          j := 0;
        }
      };
      false
      };
  };
  func isEq(x: UserId, y: UserId): Bool { x == y };
};
</code></pre>
<p><code>utils.mo</code> defines some utility functions:</p>
<pre><code class="language-js">import Array &quot;mo:base/Array&quot;;
import Option &quot;mo:base/Option&quot;;
import Database &quot;./database&quot;;
import Types &quot;./types&quot;;

module {
  type NewProfile = Types.NewProfile;
  type Profile = Types.Profile;
  type UserId = Types.UserId;

  // Profiles
  // Provides a &quot;directory&quot; class instance from the database module and userId to query Profile
  public func getProfile(directory: Database.Directory, userId: UserId): Profile {
    let existing = directory.findOne(userId);
    switch (existing) {
      case (?existing) { existing };
      case (null) {
        {
          id = userId;
          firstName = &quot;&quot;;
          lastName = &quot;&quot;;
          title = &quot;&quot;;
          company = &quot;&quot;;
          experience = &quot;&quot;;
          education = &quot;&quot;;
          imgUrl = &quot;&quot;;
        }
      };
    };
  };

  // Connections
  // Checks whether x is included in the xs array
  public func includes(x: UserId, xs: [UserId]): Bool {
    func isX(y: UserId): Bool { x == y };
    switch (Array.find&lt;UserId&gt;(xs, isX)) {
      case (null) { false };
      case (_) { true };
    };
  };

  // Authorization Management

  let adminIds: [UserId] = [];

  public func isAdmin(userId: UserId): Bool {
    func identity(x: UserId): Bool { x == userId };
    Option.isSome(Array.find&lt;UserId&gt;(adminIds, identity))
  };

  public func hasAccess(userId: UserId, profile: Profile): Bool {
    userId == profile.id or isAdmin(userId)
  };
};
</code></pre>
<p><code>main.mo</code> defines an <code>actor</code> responsible for business logic:</p>
<pre><code class="language-js">// Make the Connectd app's public methods available locally
import Connectd &quot;canister:connectd&quot;;
import Database &quot;./database&quot;;
import Types &quot;./types&quot;;
import Utils &quot;./utils&quot;;

actor LinkedUp {
  // Instantiate the directory class in the database module
  var directory: Database.Directory = Database.Directory();

  type NewProfile = Types.NewProfile;
  type Profile = Types.Profile;
  type UserId = Types.UserId;

  // Healthcheck
    
  public func healthcheck(): async Bool { true };

  // Profiles

  // User creates a homepage
  public shared(msg) func create(profile: NewProfile): async () {
    // Call the function of the directory class
    directory.createOne(msg.caller, profile);
  };

  // User updates information
  public shared(msg) func update(profile: Profile): async () {
    // Check if the user has permission
    if(Utils.hasAccess(msg.caller, profile)) {
      directory.updateOne(profile.id, profile);
    };
  };
  
  // Query user's homepage information
  public query func get(userId: UserId): async Profile {
    Utils.getProfile(directory, userId)
  };

  // Query user information by name
  public query func search(term: Text): async [Profile] {
    directory.findBy(term)
  };

  // Connections

  // Caller connects with another user
  public shared(msg) func connect(userId: UserId): async () {
    // Call Connectd's public functions API, await for the result
    await Connectd.connect(msg.caller, userId);
  };

  // Query the profiles of friends of a person
  public func getConnections(userId: UserId): async [Profile] {
    let userIds = await Connectd.getConnections(userId);
    directory.findMany(userIds)
  };

  // Query whether a person is a friend of the caller
  public shared(msg) func isConnected(userId: UserId): async Bool {
    let userIds = await Connectd.getConnections(msg.caller);
    Utils.includes(userId, userIds)
  };

  // User Authentication
  // Query the caller's Principal Id
  public shared query(msg) func getOwnId(): async UserId { msg.caller }

};
</code></pre>
<p>After understanding the code structure and details, we attempt to <a href="https://github.com/xiaoyuanxun/linkedup">compile and deploy the project</a>.</p>
<p>We enter the project's root directory and start the local IC network first:</p>
<pre><code class="language-shell">dfx start
</code></pre>
<p>Then you can see information similar to the following in the terminal:</p>
<pre><code class="language-shell">Running dfx start for version 0.14.3
Initialized replica.

Dashboard: http://localhost:55777/_/dashboard
</code></pre>
<p>This means that the IC local network has started successfully. We can open the dashboard link above to view the network status, etc.:</p>
<img src="9.DevelopingDApp/assets/1.GettingStartedwithDApp/image-1-1.png" style="zoom:37%;" />
<p>Then we compile and deploy canister:</p>
<pre><code class="language-shell">dfx deploy
</code></pre>
<p>The terminal will display the following information:</p>
<pre><code class="language-shell">Deploying all canisters.
Creating a wallet canister on the local network.
The wallet canister on the &quot;local&quot; network for user &quot;default&quot; is &quot;bnz7o-iuaaa-aaaaa-qaaaa-cai&quot;
Creating canisters...
Creating canister connectd...
connectd canister created with canister id: bkyz2-fmaaa-aaaaa-qaaaq-cai
Creating canister linkedup...
linkedup canister created with canister id: bd3sg-teaaa-aaaaa-qaaba-cai
Creating canister linkedup_assets...
linkedup_assets canister created with canister id: be2us-64aaa-aaaaa-qaabq-cai
Building canisters...

Building frontend...
Installing canisters...
Creating UI canister on the local network.
The UI canister on the &quot;local&quot; network is &quot;br5f7-7uaaa-aaaaa-qaaca-cai&quot;
Installing code for canister connectd, with canister ID bkyz2-fmaaa-aaaaa-qaaaq-cai
Installing code for canister linkedup, with canister ID bd3sg-teaaa-aaaaa-qaaba-cai
Installing code for canister linkedup_assets, with canister ID be2us-64aaa-aaaaa-qaabq-cai
Uploading assets to asset canister...
Fetching properties for all assets in the canister.
Starting batch.
Staging contents of new and changed assets in batch 1:
  /index.html 1/1 (7196 bytes) sha c7545fb06d97f8eede0a28524035f8c909e2ad456e26da2e29e4510bd87b8eb4 
  /templates.js 1/1 (3188 bytes) sha 9a29bc111afcbbf07194ee385d7c7c5dc084fc6a5c545f9f3a75e01aba19d4bd 
  /templates.js (gzip) 1/1 (772 bytes) sha 2b9db874caa4da5e3fa029c49c9f1970846d8f184dbbed38ada826b340525239 
  /index.js.LICENSE.txt 1/1 (494 bytes) sha bce8afa69662344f3076e34d586e8a319541e6220f7d33d24c638d2e41e8b3f5 
  /index.js.LICENSE.txt (gzip) 1/1 (303 bytes) sha 825daec9b568cb21931839f253a52c6568c67067f728b017d07e3e8e4ab9ad4b 
  /index.js.map (gzip) 1/1 (486875 bytes) sha 292293e601f5d89b74f738059ac3de6f0f8880de21e4b02900f5b3dde4b7f133 
  /index.js.map 2/2 (512088 bytes) sha d3bc05cedd9145e6e95ac69e617677e9362afab04be5c2aaec484e5ea18b6e91 
  /index.js 1/1 (1532332 bytes) sha 9a45f461b9eb3685fd69f74e51717a809a2781621308f32c78c36c44f9ac7b09 
  /utils.js 1/1 (267 bytes) sha d931b0c93683a02c41427208d424ad52239ae1f5ada1d8dbea5a3fd041969c13 
  /index.html (gzip) 1/1 (1448 bytes) sha 532c56fb849e459afdeee85fa91f59ac9990ad03b8db655bc3aa36acff1e65c6 
  /utils.js (gzip) 1/1 (199 bytes) sha 054727654de247397e5db169d1399ad9001a9a19cc8381e2a3a7d184ee87d32a 
  /index.js.map 1/2 (1900000 bytes) sha d3bc05cedd9145e6e95ac69e617677e9362afab04be5c2aaec484e5ea18b6e91 
  /index.js (gzip) 1/1 (256156 bytes) sha cf3ba66fe82622bb31d124a1c8daa3abbf387760a858e3a25f6a27b161230fbb 
  /main.js (gzip) 1/1 (2038 bytes) sha 1ebe40bb131aed3f67823a56b0536387c6a4820855f4e3db3f9879ff7ca9289f 
  /main.js 1/1 (7682 bytes) sha bea749dd6d5fe8dace9812606f02eb76754c31992ecf2e69801de5585cf3f87c 
  /index.css 1/1 (15386 bytes) sha 5488d6d439f6abdc3104b499e399ce2f588448ce81be46cbdb9a5e9ef2bedf2b 
  /index.css (gzip) 1/1 (3082 bytes) sha 166ed706f6011b8b95c3160cca68d47955421dd29d64d609e6e6d4cf6b3c47a6 
Committing batch.
Committing batch with 24 operations.
Deployed canisters.
URLs:
  Frontend canister via browser
    linkedup_assets: http://127.0.0.1:4943/?canisterId=be2us-64aaa-aaaaa-qaabq-cai
  Backend canister via Candid interface:
    connectd: http://127.0.0.1:4943/?canisterId=br5f7-7uaaa-aaaaa-qaaca-cai&amp;id=bkyz2-fmaaa-aaaaa-qaaaq-cai
    linkedup: http://127.0.0.1:4943/?canisterId=br5f7-7uaaa-aaaaa-qaaca-cai&amp;id=bd3sg-teaaa-aaaaa-qaaba-cai
</code></pre>
<p>We will understand what <code>dfx deploy</code> has done in sections:</p>
<p>Firstly, it created a wallet canister for the <code>default</code> user on the local network. This wallet canister comes with some default cycles, which will be used to create and manage other canisters:</p>
<pre><code class="language-shell">Creating a wallet canister on the local network.
The wallet canister on the &quot;local&quot; network for user &quot;default&quot; is &quot;bnz7o-iuaaa-aaaaa-qaaaa-cai&quot;
</code></pre>
<p>Then, it created two backend canisters and one frontend asset canister required for the business:</p>
<pre><code class="language-shell">Creating canisters...
Creating canister connectd...
connectd canister created with canister id: bkyz2-fmaaa-aaaaa-qaaaq-cai
Creating canister linkedup...
linkedup canister created with canister id: bd3sg-teaaa-aaaaa-qaaba-cai
Creating canister linkedup_assets...
linkedup_assets canister created with canister id: be2us-64aaa-aaaaa-qaabq-cai
</code></pre>
<p>Afterwards, it compiled the backend and frontend code into WebAssembly (Wasm) files that can be deployed within the canisters:</p>
<pre><code>Building canisters...
Building frontend...
</code></pre>
<p>Then, it installed the Wasm files into the canisters:</p>
<pre><code class="language-shell">Installing canisters...
Creating UI canister on the local network.
The UI canister on the &quot;local&quot; network is &quot;br5f7-7uaaa-aaaaa-qaaca-cai&quot;
Installing code for canister connectd, with canister ID bkyz2-fmaaa-aaaaa-qaaaq-cai
Installing code for canister linkedup, with canister ID bd3sg-teaaa-aaaaa-qaaba-cai
Installing code for canister linkedup_assets, with canister ID be2us-64aaa-aaaaa-qaabq-cai
Deployed canisters.
</code></pre>
<p>Upload frontend static resources to the Asset Canister:</p>
<pre><code class="language-shell">Uploading assets to asset canister...
Fetching properties for all assets in the canister.
Starting batch.
Staging contents of new and changed assets in batch 1:
  /index.html 1/1 (7196 bytes) sha c7545fb06d97f8eede0a28524035f8c909e2ad456e26da2e29e4510bd87b8eb4 
  /templates.js 1/1 (3188 bytes) sha 9a29bc111afcbbf07194ee385d7c7c5dc084fc6a5c545f9f3a75e01aba19d4bd 
  /templates.js (gzip) 1/1 (772 bytes) sha 2b9db874caa4da5e3fa029c49c9f1970846d8f184dbbed38ada826b340525239 
  /index.js.LICENSE.txt 1/1 (494 bytes) sha bce8afa69662344f3076e34d586e8a319541e6220f7d33d24c638d2e41e8b3f5 
  /index.js.LICENSE.txt (gzip) 1/1 (303 bytes) sha 825daec9b568cb21931839f253a52c6568c67067f728b017d07e3e8e4ab9ad4b 
  /index.js.map (gzip) 1/1 (486875 bytes) sha 292293e601f5d89b74f738059ac3de6f0f8880de21e4b02900f5b3dde4b7f133 
  /index.js.map 2/2 (512088 bytes) sha d3bc05cedd9145e6e95ac69e617677e9362afab04be5c2aaec484e5ea18b6e91 
  /index.js 1/1 (1532332 bytes) sha 9a45f461b9eb3685fd69f74e51717a809a2781621308f32c78c36c44f9ac7b09 
  /utils.js 1/1 (267 bytes) sha d931b0c93683a02c41427208d424ad52239ae1f5ada1d8dbea5a3fd041969c13 
  /index.html (gzip) 1/1 (1448 bytes) sha 532c56fb849e459afdeee85fa91f59ac9990ad03b8db655bc3aa36acff1e65c6 
  /utils.js (gzip) 1/1 (199 bytes) sha 054727654de247397e5db169d1399ad9001a9a19cc8381e2a3a7d184ee87d32a 
  /index.js.map 1/2 (1900000 bytes) sha d3bc05cedd9145e6e95ac69e617677e9362afab04be5c2aaec484e5ea18b6e91 
  /index.js (gzip) 1/1 (256156 bytes) sha cf3ba66fe82622bb31d124a1c8daa3abbf387760a858e3a25f6a27b161230fbb 
  /main.js (gzip) 1/1 (2038 bytes) sha 1ebe40bb131aed3f67823a56b0536387c6a4820855f4e3db3f9879ff7ca9289f 
  /main.js 1/1 (7682 bytes) sha bea749dd6d5fe8dace9812606f02eb76754c31992ecf2e69801de5585cf3f87c 
  /index.css 1/1 (15386 bytes) sha 5488d6d439f6abdc3104b499e399ce2f588448ce81be46cbdb9a5e9ef2bedf2b 
  /index.css (gzip) 1/1 (3082 bytes) sha 166ed706f6011b8b95c3160cca68d47955421dd29d64d609e6e6d4cf6b3c47a6 
Committing batch.
Committing batch with 24 operations.
</code></pre>
<p>Also, a UI Canister was created locally. It can be used to visually invoke and test the backend canister interfaces:</p>
<pre><code class="language-shell">Creating UI canister on the local network.
The UI canister on the &quot;local&quot; network is &quot;br5f7-7uaaa-aaaaa-qaaca-cai&quot;
</code></pre>
<p>Finally, display the link for successful deployment. You can click on the link for Linkedup_assets to view the frontend.</p>
<p>Clicking on Connectd and Linkedup allows you to debug the backend interfaces through CandidUI:</p>
<pre><code class="language-shell">Deployed canisters.
URLs:
  Frontend canister via browser
    linkedup_assets: http://127.0.0.1:4943/?canisterId=be2us-64aaa-aaaaa-qaabq-cai
  Backend canister via Candid interface:
    connectd: http://127.0.0.1:4943/?canisterId=br5f7-7uaaa-aaaaa-qaaca-cai&amp;id=bkyz2-fmaaa-aaaaa-qaaaq-cai
    linkedup: http://127.0.0.1:4943/?canisterId=br5f7-7uaaa-aaaaa-qaaca-cai&amp;id=bd3sg-teaaa-aaaaa-qaaba-cai
</code></pre>
<p>We open the Linkedup CandidUI window to test the backend business logic:</p>
<div class="center-image">
    <img src="9.DevelopingDApp/assets/1.GettingStartedwithDApp/image-1-2.png" alt="img" style="zoom:67%;" />
</div>
<p>We attempt to call the <code>create</code> function to create personal homepage information.</p>
<p>After entering the information, click CALL.</p>
<p>Successful return of <code>()</code> can be observed, taking 2.107 seconds, as the update function (defined as <code>public shared</code>) requires consensus from the underlying system, typically taking around 2 seconds.</p>
<div class="center-image">
    <img src="9.DevelopingDApp/assets/1.GettingStartedwithDApp/image-1-3.png" alt="img" style="zoom:67%;" />
</div>
<p>We can also use the <code>get</code> function to query someone's homepage information.</p>
<p>It returns a <code>record</code> structure, and this call only takes 0.015 seconds to return results because the query function does not go through consensus and is typically in the millisecond range.</p>
<div class="center-image">
    <img src="9.DevelopingDApp/assets/1.GettingStartedwithDApp/image-1-4.png" alt="img" style="zoom:70%;" />
</div>
<p>Feel free to try other function calls.</p>
<p>Candid UI is not all-powerful; its main drawback is its single identity. For example, we cannot test the business logic of Connect and establish connections between two identities.</p>
<p>Therefore, for production use, Rust Agent or JS Agent libraries are commonly employed for automated testing.</p>
<p>At this point, we have completed understanding this demo; you can stop the local IC network:</p>
<pre><code class="language-shell">dfx stop
</code></pre>
<br>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<p><a href="https://internetcomputer.org/docs/current/motoko/main/motoko">Motoko documentation</a>: Official documentation for the Motoko language.</p>
<p><a href="https://m7sm4-2iaaa-aaaab-qabra-cai.raw.ic0.app">Motoko playground</a>: A sandbox for quickly writing and testing Motoko code from the browser.</p>
<p><a href="https://github.com/dfinity/examples">examples</a>: Official code examples from DFINITY.</p>
<p><a href="https://github.com/orgs/DFINITY-Education/repositories">DFINITY education</a>: Educational resources on data structures, web development, blockchain, and more.</p>
<p><a href="https://github.com/MioQuispe/create-ic-app">create-ic-app</a>: Templates for popular frameworks (Vue, React, Vanilla JS, Svelte).</p>
<p><a href="https://juno.build/docs/intro">juno</a>: Build on-chain backend services through a UI interface.</p>
<p><a href="https://github.com/dfinity/invoice-canister">The invoice canister</a>: Code for handling payments on the IC.</p>
<p><a href="https://github.com/Web3NL/motoko-book">motoko-book</a>: A book about Motoko.</p>
<p><a href="https://github.com/motoko-bootcamp/motokobootcamp-2023">motokobootcamp-2023</a>: Motoko training camp in 2023, including various development tutorials.</p>
<p><a href="https://github.com/motoko-bootcamp/bootcamp-2022">bootcamp-2022</a>: Motoko training camp in 2022, including various development tutorials.</p>
<p><a href="https://kyle-peacock.com/blog">kyle's blog</a>: Kyle's blog about IC dev.</p>
<p><a href="https://kyle-peacock.com/blog/dfinity/integrating-internet-identity">Integrating Internet Identity</a>: Kyle demonstrates how to integrate Internet Identity.</p>
<p><a href="https://github.com/dfinity/awesome-icp">awesome-icp</a>: A list of excellent projects.</p>
<p><a href="https://github.com/motoko-unofficial/awesome-motoko">awesome-motoko</a>: A list of excellent projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="proton"><a class="header" href="#proton">Proton</a></h2>
<blockquote>
<p>Slow is fast.</p>
<p>Decentralized.</p>
</blockquote>
<p>Now, we are designing a decentralized social media within the Actor model.</p>
<p>I call it Proton. We design for the future.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/2.png" alt="2" style="zoom:35%;" />
</div>
<p>The Internet Computer (IC) is designed as a decentralized cloud service at its core. Decentralization at the core implies that the websites and services we deploy, including smart contracts,
<span class="hover-win0">
<span class="hover-win2">
but if it goes against the community's will and causes public outrage, it could be voted down by DAO.
</span>
<span class="hover-win1">
won't be arbitrarily shut down by certain individuals.
</span>
</span></p>
<p>Applications deployed on the upper layer can be controlled by us, storing our private data. Alternatively, we can choose to control them through DAO, making them fully decentralized DApps, subject to community governance.</p>
<p><a href="9.DevelopingDApp/4.%E5%AE%B9%E5%99%A8(Canister)/1.Canister.html">IC smart contracts</a> are WebAssembly (Wasm) containers called Canisters, similar to small servers for cloud services. They are powerful and can directly provide services such as computation, storage, hosting web pages, HTTP invocation (oracle), WebSocket, and more.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231220212333608.png" alt="img" style="zoom:37%;" />
</div>
<p>Canisters, implemented in Motoko or Rust, follow the Actor programming model. Understanding the basic principles of the Actor model is essential. The Actor model is a concurrency model that achieves parallel and distributed computing through message passing and asynchronous processing.</p>
<p>Therefore, when designing DApps, each Canister should be responsible for different functional modules. For example, some Canisters may handle user profiles, while others handle post storage.</p>
<p>Additionally, attention should be paid to the scalability of Canisters. We can dynamically create the same type of Canister to handle high loads.</p>
<br>
<h2 id="design-philosophy"><a class="header" href="#design-philosophy">Design Philosophy</a></h2>
<p>We aim to build a truly open Web3 DApp based on the modular data sovereignty of the Actor model.</p>
<p>We want each user to have their independent space (Feed Canister), fully controlled by themselves. <strong>Users only need to interact with their own Canister, and subsequent pushes are collaboratively and gradually automated by the Canisters.</strong></p>
<br>
<p>Users can even deploy their independent Feed Canister and interact with Proton directly through code. (This is cumbersome and suitable only for programmer users, who can develop advanced custom features for the container.) This allows the community to create custom advanced features.</p>
<p><strong>Feed is everyone's service terminal, where people can freely switch between their Feed and frontend pages. The community can develop various custom frontend pages and Feeds.</strong></p>
<p>Its appeal lies in the privacy and customization freedom of personal Canisters. The earlier it is deployed, the more content accumulates over time.</p>
<br>
<p>Essentially, it is a public posting space. The architecture is designed for anyone who wants to publish content on a decentralized network.</p>
<p><strong>There is no concept of &quot;borders&quot; here. It is no longer an isolated data island; people can freely publish and access content.</strong></p>
<p><strong>Its existence transcends any single application; it can represent all platforms on the decentralized internet.</strong></p>
<p><strong>If people want to publish content on the decentralized network, they can choose to do so in such public spaces instead of platforms like &quot;X&quot;, &quot;Reddit,&quot; or &quot;Quora.&quot;</strong></p>
<p>There is no entity control; content is paramount, and individual sovereignty is supreme.</p>
<br>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>Firstly, there is an extensible public area to receive all user posts, and a user area to record user registration, personal profiles, and follow relationships.</p>
<p>We create a Feed for each user to store their own information flow. Feed is also the user's private space, and no one except the user can delete posts in it.</p>
<br>
<p><strong>The interaction between users and the public area is automatically completed by the Feed Canister. Users only need to query their Feed to obtain the latest information flow from those they follow. Posting, commenting, liking, and other interactions are also automatically completed by the Feed Canister.</strong></p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/0bcc2cec4ca809863960105155fde056af3cd414.png" alt="img" style="zoom:50%;" />
</div>
<p>Users can also add several advanced custom features, deploying an independent Feed to interact with the public area. For example, only sending posts point-to-point to a few Feeds to create a private social circle, or connecting AI to automatically post, etc. Any feature is possible, and the community can develop and expand various functions at will. For example, adding a point-to-point messaging feature.</p>
<br>
<h2 id="message-transmission-process"><a class="header" href="#message-transmission-process">Message Transmission Process</a></h2>
<p>When a user posts, the Feed first stores the post in its own information flow, and then sends the post point-to-point to the followers' Feeds and the public area's Bucket according to the fan list. However, if there are ten thousand followers, it's not ideal because the exchange of messages between Canisters is limited by the max input/out queue size. It cannot send so many messages at once. The Feed needs to send them in batches, taking a long time to complete.</p>
<p>To increase throughput, we add a message relay station: Fetch. The Feed first sends the post to the public area and then sends the post ID and followers to Fetch. After recording, Fetch notifies these followers' Feeds one by one according to an algorithm, indicating which posts to fetch. Finally, the Feed goes to the public area to fetch the posts.</p>
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231121215915409.png" alt="img" style="zoom:50%;" />
<p>This way, even with many followers, they can sequentially fetch posts from the public area under Fetch's adjustment.</p>
<br>
<p>This is a fully open, decentralized application with slightly slower message delivery. This design sacrifices speed for decentralization, similar to Bitcoin.</p>
<p>The advantage is that the user's frontend only needs to query their Feed to get posts from people they follow. It's convenient and fast, with the backend entirely decentralized and decoupled. If a few Canisters go down, it doesn't affect the continued operation of the system. (If Fetch goes down, a few more can be created.)</p>
<p>If the system cannot recover temporarily, the Feed can send posts to followers in batches using ignore call point-to-point. In other words, the Feed has two built-in posting processes: posting through the Fetch relay station and point-to-point posting. It's just that point-to-point posting will be a bit slower.</p>
<br>
<p>Alright, after so much explanation, let's now detail this architecture.</p>
<br>
<h2 id="architecture-1"><a class="header" href="#architecture-1">Architecture</a></h2>
<p>Based on the Actor model, it's a point-to-point distributed push-fetch architecture.</p>
<br>
<p>Overall, you can divide Proton into four modules: User, Feed, Post, and Fetch.</p>
<ul>
<li><strong>User:</strong> The user area responsible for recording user information and relationships. It records user profiles and follow relationships.</li>
<li><strong>Post:</strong> The public area that stores all publicly posted posts. Root Post can create many Buckets to store posts.</li>
<li><strong>Feed:</strong> The information flow storing a user's personal information flow. Root Feed creates a Feed for each user.</li>
<li><strong>Fetch:</strong> The relay station responsible for pushing a user's latest information flow. It records the posts, comments, or likes in a user's Feed that haven't been fetched.</li>
</ul>
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231117210909667.png" alt="img" style="zoom:33%;" />
<p>Users can follow others (and unfollow), view the latest posts in the public area (posts from everyone), view their information flow (posts from those they follow and their own posts), post, repost, comment, like, and bookmark (and unbookmark).</p>
<h3 id="user"><a class="header" href="#user">User</a></h3>
<p>The user area records user information and relationships. It stores basic user information in the User canister, such as UserId, name, company, school, occupation, personal profile, follow relationships, and their own Feed Canister ID, etc.</p>
<p>Users can call functions here to follow someone, update their profile, or query who they are following and someone's follow relationships.</p>
<p>When a user follows someone new or has a new follower, the user's Feed needs to be notified to update the list.</p>
<h3 id="post"><a class="header" href="#post">Post</a></h3>
<p>The public area that stores all publicly posted posts. Root Post can create many Buckets to store posts.</p>
<h4 id="root-post"><a class="header" href="#root-post">Root Post</a></h4>
<p>The public area is responsible for storing all publicly posted threads.</p>
<p>Root Post can create many Bucket Canisters to store threads.</p>
<p>Root Post has the ability to create Buckets, query who owns available Buckets, query all Buckets, and query filled Buckets.</p>
<br>
<p>Root Post initially creates 5 Buckets. When one Bucket is filled, another Bucket is created, ensuring that there are always 5 available Buckets.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231120173647549.png" alt="img" style="zoom:37%;" />
</div>
<p>When a user opens the frontend interface, the backend Feed immediately queries Root Post for the available Bucket. Root Post randomly returns a Bucket, and the Feed stores a variable indicating the &quot;available Bucket,&quot; updating this variable after obtaining the Canister ID.</p>
<ul>
<li>Call the Bucket to query the latest 5 threads and retrieve the latest public threads.</li>
<li>When a user posts to the public area, call Bucket to store the thread.</li>
</ul>
<p>When a user's Feed fetches a batch of thread IDs from Fetch, it can use the thread IDs to query the Bucket for the threads.</p>
<br>
<h4 id="bucket"><a class="header" href="#bucket">Bucket</a></h4>
<p>Bucket can add and retrieve threads.</p>
<p>There are 3 query functions: querying the total number of threads in a Canister, querying specific threads based on IDs (up to 7 IDs can be passed at once), and querying the latest n threads (with parameters specifying the number of latest threads).</p>
<p>When querying specific or the latest threads, the thread content and current likes and comments need to be returned.</p>
<br>
<p>Bucket is responsible for receiving threads, comments, and likes.</p>
<p>When Bucket receives a new thread, it checks for ID conflicts before accepting it. It notifies Comment Fetch and Like Fetch of threads with updated comments and likes.</p>
<br>
<h3 id="feed"><a class="header" href="#feed">Feed</a></h3>
<p>Information flow, storing users' personal information flows. Root Feed creates a Feed for each user.</p>
<br>
<h4 id="root-feed"><a class="header" href="#root-feed">Root Feed</a></h4>
<p>Root Feed is responsible for creating a Canister for each user and recording the total number of created Canisters and their Canister IDs.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231120185518041.png" alt="img" style="zoom:39%;" />
</div>
<br>
<h4 id="feed-1"><a class="header" href="#feed-1">Feed</a></h4>
<p><strong>Users participate in Proton's interactions through their own Feed: viewing, posting, commenting, liking, etc. - all through Feed.</strong></p>
<br>
<p>User's Feed records followers (used for pushing threads, comments, and likes), following (detecting when receiving threads), information flow (only stores the latest 3000 threads), and saved threads (up to 500 threads).</p>
<br>
<p>Each thread has a publication time, the user ID of the publisher (<code>UserId</code>), thread ID (<code>PostId</code>), and the ID of the person who reposted it (<code>RepostId</code>, empty if not reposted).</p>
<br>
<p>The thread ID is the combination of Bucket Canister ID, UserId, and an incrementing number. For example, aaaaa-aaa-bbbbb-bbb-1, aaaaa-aaa-bbbbb-bbb-2, aaaaa-aaa-bbbbb-bbb-3, ...</p>
<br>
<p>Querying threads:</p>
<p>There are 3 functions to query threads in Feed: querying the total number of threads, querying a specific thread based on its ID, and querying the latest n threads (with parameters specifying the number of latest threads).</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231120172645581.png" alt="img" style="zoom:39%;" />
</div>
<br>
<p>Posting:</p>
<p>When user A posts a new thread, the frontend sends the thread to user A's Feed.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231116235638531-1700192647376-9.png" alt="img" style="zoom:50%;" />
</div>
<p>Feed receives the message, creates a new thread, and stores it. Then, it sends the thread content to the public area's Bucket for storage, visible to everyone. It also sends the thread poster, thread ID, and users C and D (followers) to Fetch.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231117004133644-1700192647376-8.png" alt="image-20231117004133644" style="zoom:50%;" />
</div>
<p>Fetch records and notifies users C and D's Feed to fetch content based on thread ID. After sending the notification, it deletes user C and thread ID; Fetch stores only &quot;to be notified&quot; records.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231117004213850-1700192647376-10.png" alt="image-20231117004213850" style="zoom:55%;" />
</div>
<p>Users C and D's Feed, upon receiving thread IDs to fetch, retrieves the corresponding threads from the public area and adds them to their own Feed thread flow. (In this example, user C will receive threads with ID 1, 6, 7, 15, and user C's Feed fetches threads 1, 6, 7, 15 from Bucket.)</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231117005218488-1700192647376-11.png" alt="image-20231117005218488" style="zoom:50%;" />
</div>
<p>When users C and D open the frontend to query their Feed, they can see the new threads posted by A, ensuring they get the latest threads immediately.</p>
<br>
<p>If later user E follows user A, their Feed will only receive new threads from user A.</p>
<br>
<p><strong>The frontend only needs to send one request; subsequent push operations (such as notifying the public area) are handled by the Canister.</strong></p>
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231120171812860.png" alt="img" style="zoom:50%;" />
<p>As the number of users increases, one Fetch may not handle a large number of posting requests. In this case, a new Fetch for message pushing can be created, and the relay station service can be horizontally scaled as needed.</p>
<br>
<p>Deletion:</p>
<p>Posts cannot be deleted; blockchain: once posted, it cannot be undone.</p>
<p>Ignore the posts in the followers' Feeds, keeping only the latest 3000 posts. (Additionally, Feed is someone's private space)</p>
<br>
<p>Repost:</p>
<p>User C reposts a post to H, I, J, K: <code>Reposter: C</code>, <code>Post ID: post15_id</code>, <code>Followers: Users H, I, J, K</code>, sent to Fetch.</p>
<p>Fetch records it and notifies the Feeds of H, I, J, K.</p>
<p>These Feeds go to the public area to fetch the post based on the ID.</p>
<blockquote>
<p>When user C reposts a post, the original poster remains user A, and the reposter is user C.</p>
</blockquote>
<br>
<p>Comment:</p>
<p>The comment process is similar to the posting process, using Comment Fetch for comments.</p>
<p>Anyone who sees a post (user X) can comment. The frontend calls Feed, providing post_id and the comment content.</p>
<p>Upon receiving the comment, Feed first checks its 3000-item information flow for the post. If found, it adds the comment to the post in its Feed.</p>
<p>Then, it notifies the public area's Bucket to update the comments.</p>
<p>After receiving a comment, Bucket notifies Comment Fetch of the post ID with new comments.</p>
<p>Comment Fetch first goes to the User user area to find out who the post author's followers are. If the author is not found, the request is rejected.</p>
<p>Then, it adds the post ID, the poster, and the followers to the &quot;to be notified&quot; list.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231129154312702.png" alt="image-20231129154312702" style="zoom:33%;" />
</div>
<p>After Comment Fetch sends out notifications one by one, followers fetch the post's comments based on the provided post ID and update them in their Feeds.</p>
<br>
<p>If follower D reposted this post, D's Feed, upon receiving a new comment notification, continues to notify Comment Fetch: post15_id, D's followers.</p>
<p>Comments cannot be deleted.</p>
<br>
<p>Like:</p>
<p>The like process is similar to the posting process, using Like Fetch for likes.</p>
<p>Anyone who sees a post (user X) can like it. After the public area's Bucket receives a like, it notifies Like Fetch of the post ID with new likes.</p>
<p>Like Fetch first goes to the User user area to find out who the post author's followers are. If the author is not found, the request is rejected.</p>
<p>Then, it adds the post ID, the poster, and the followers to the &quot;to be notified&quot; list.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231120161143485-1707368006258-45.png" alt="img" style="zoom:37%;" />
</div>
<p>After Like Fetch sends out notifications one by one, followers fetch the post's like count based on the provided post ID and update it in their Feeds.</p>
<br>
<p>If follower D reposted this post, D's Feed, upon receiving a new like notification, continues to notify Like Fetch: post15_id, D's followers.</p>
<p>Likes cannot be deleted.</p>
<br>
<h3 id="fetch"><a class="header" href="#fetch">Fetch</a></h3>
<p>Responsible for receiving posting, commenting, and liking messages from everyone and notifying relevant Feeds.</p>
<br>
<h4 id="root-fetch"><a class="header" href="#root-fetch">Root Fetch</a></h4>
<p>Root Fetch dynamically creates multiple Fetch based on the number of users. It can create 3 types of Fetch: Post Fetch, Like Fetch, Comment Fetch. It can also query Root Fetch for available Fetch.</p>
<br>
<h4 id="post-fetch"><a class="header" href="#post-fetch">Post Fetch</a></h4>
<p>Receives notifications from posters: post ID, poster, reposter, followers, Cycles.</p>
<p>Internally maintains a notification table: records which post IDs each user is waiting to be notified about.</p>
<p>Notifies followers' Feeds in batches using the ignore call algorithm.</p>
<br>
<h4 id="comment-fetch"><a class="header" href="#comment-fetch">Comment Fetch</a></h4>
<p>Receives new comment notifications from Bucket: post ID, poster (A), reposter (empty).</p>
<p>Goes to the User user area based on the poster (or reposter) to find out who the poster's followers are.</p>
<p>Internally maintains a notification table: records which post IDs each user is waiting to be notified about.</p>
<p>Notifies followers' Feeds in batches using the ignore call algorithm.</p>
<p>If follower C reposted this post, C's Feed, upon receiving new comment notifications, continues to notify Comment Fetch: post15_id, C's followers.</p>
<br>
<h4 id="like-fetch"><a class="header" href="#like-fetch">Like Fetch</a></h4>
<p>Receives new like notifications from Bucket: post ID, poster (A), reposter (empty).</p>
<p>Goes to the User user area based on the poster (or reposter) to find out who the poster's followers are.</p>
<p>Internally maintains a notification table: records which post IDs each user is waiting to be notified about.</p>
<p>Notifies followers' Feeds in batches using the ignore call algorithm.</p>
<p>If follower C reposted this post, C's Feed, upon receiving new like notifications, continues to notify Like Fetch: post15_id, C's followers.</p>
<br>
<p>The above User, Post, Fetch, Feed form the basic architecture of Proton.</p>
<br>
<p>On this architecture, we can imagine more advantages brought by modular Actor model...</p>
<br>
<h3 id="everything-is-up-to-the-users-choice"><a class="header" href="#everything-is-up-to-the-users-choice">Everything is up to the user's choice.</a></h3>
<p>Users can choose to send posts privately to a few followers' Feeds through Feed, without making them public.</p>
<p>Users can also establish their own &quot;community server,&quot; a community public area under their control. In this way, people's Feeds can subscribe to this community service area, and Feed requests updates from the community server every 2 hours. Feed retains the last updated post id, and when making a request, it provides the last post id; the community server will then retrieve and return the posts since the last update to Feed.</p>
<div class="center-image">
<img src="https://neutronstardao.github.io/constellationzh.github.io/9.Dapp%E5%BC%80%E5%8F%91/assets/2.%E8%AE%BE%E8%AE%A1DApp/image-20231220175917344.png" alt="img" style="zoom: 33%;" />
</div>
<p>The entire system is modular and can be spontaneously constructed by the community. For example, users can establish their own community servers, broadcast matrices, etc. (Broadcast matrix will be introduced later.)</p>
<br>
<h3 id="automatic-pressure-adjustment"><a class="header" href="#automatic-pressure-adjustment">Automatic Pressure Adjustment</a></h3>
<p>After Fetch accumulates a certain amount of messages, it adjusts the notification order and interval through an algorithm (which Feed to notify first and how many Feeds to notify at intervals, in milliseconds, before notifying other Feeds), ensuring that the query pressure on the public area is not too high. After receiving a notification, Feed should wait for 20 seconds before retrying if fetching fails.</p>
<br>
<p>If the public area faces too much query pressure, it will inform Root Fetch: &quot;Notify Feed more slowly,&quot; and Root Fetch will notify the several Fetch below it to reduce the notification frequency. If the pressure remains high after 10 minutes, Root Post can also create a new Bucket to have new posts sent to the new Bucket.</p>
<p>Additionally, as the number of users increases, Fetch itself can also be expanded as needed.</p>
<br>
<p>Since every time Feed sends a message, Fetch has to notify many other Feeds, this open environment can easily lead to DoS attacks. Therefore, when Feed sends information to Fetch, a Gas fee must be paid. Fetch will only put the information into the &quot;to be notified&quot; list after receiving the Gas fee.</p>
<br>
<h3 id="broadcast-matrix"><a class="header" href="#broadcast-matrix">Broadcast Matrix</a></h3>
<p>For example, if 1000 people like post 15 in 2 minutes, Fetch only needs to notify post 15's followers once. Then these followers can check the public area's Bucket themselves to see how many likes there are.</p>
<blockquote>
<p>Of course, Fetch can also record how many likes a post has, whom to notify, accumulate for a certain period, and then directly notify the followers' Feed: a post has 1000 likes. In this case, Feed does not need to check the number of likes in the Bucket; Fetch has recorded it all.</p>
<p>However, this is more centralized. All Feeds obey Fetch's commands and trust the like count given by Fetch. If Fetch is compromised, false like counts may occur. Therefore, letting Feed check the Bucket itself is the most authentic approach.</p>
</blockquote>
<br>
<p>Now, let's think about a high-concurrency scenario: If Fetch needs to notify 10,000 Feeds, but due to the Canister system's message queue limit, let's assume one Fetch can only send notifications to 500 Feeds at a time.</p>
<p>If only one Fetch is working, it needs 20 times to complete the notification. In this case, multiple Fetches need to collaborate.</p>
<p>One Fetch divides the list of users to be notified into 5 parts and then distributes them to 5 Fetches. This way, 2500 notifications can be sent at once, and it only takes 4 times to complete the push!</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231224001103346.png" alt="img" style="zoom:39%;" />
</div>
<p>Canister's message output queue is 500, so we can establish relays with different sending capacities: 500, 2500, 5000, 10000...</p>
<p>One Canister can send 500 messages at a time, five Canisters can send 2500 messages at once, ten Canisters can send 5000 messages at once, and twenty Canisters can send 10000 messages at once.</p>
<div class="center-image">
    <img src="https://neutronstardao.github.io/constellationzh.github.io/9.Dapp%E5%BC%80%E5%8F%91/assets/2.%E8%AE%BE%E8%AE%A1DApp/image-20231201010601827.png" alt="img" style="zoom:50%;" />
</div>
<p>For safety, in practical use, we should leave some message output to ensure other communications are normal and urgent situations can call for Root Fetch's message output. Therefore, we should set a limit that one Fetch can send a maximum of 430 notifications at a time.</p>
<p>To prevent DoS attacks, users should send some Cycles when posting, commenting, or liking. The charges for different types of broadcast matrices vary.</p>
<p>If someone has many followers, they can choose not to trust anyone and establish a private broadcast matrix for notifying their own followers.</p>
<br>
<p>However, these are plans for the future. For now, let's design the framework and continuously optimize the details after implementing the basic functionality.</p>
<br>
<h2 id="plan"><a class="header" href="#plan">Plan</a></h2>
<p><strong>Final Plan: Modular, Public Database, User Cloud Terminal.</strong></p>
<p>Modular: Classify Canisters by function, each performing its own duties.</p>
<p>Public Database: An open database where anyone can directly publish and retrieve content.</p>
<p>User Cloud Terminal: Each user has their own independent server (Canister) providing on-chain private services.</p>
<br>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>This is a complex, large-scale application.</p>
<p>In this tutorial, we will use Motoko to build the basic functionality of this DApp.</p>
<p>üÜó <a href="9.DevelopingDApp/">Let‚Äôs go!</a> üÜó</p>
<br>
<div class="center-image">
<img src="9.DevelopingDApp/assets/2.DesigningDApp/image-20231220222254067.png" alt="img" style="zoom:39%;" />
</div>
<div style="break-before: page; page-break-before: always;"></div><div class="center-image">
<img src="9.DevelopingDApp/assets/3.DevelopingProton/1.png" alt="img" style="zoom:30%;" />
</div>
<p>Following the design in the previous article, let's gradually complete the code for Proton.</p>
<p>We can divide Proton into 4 modules.üëá</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/3.DevelopingProton/image-20231121215915409.png" alt="img" style="zoom:53%;" />
</div>
<p>Each module corresponds to different functionalities, flexibly combined.</p>
<a href="9.DevelopingDApp/4.UserModule.html">
<div class="home-box">
    <div class="box">1Ô∏è‚É£
            <div>
                User Module
            </div>
            <div>
                Manage user relationships and user profiles
            </div>
    </div>
</div>
</a>
<div class="home-box">
    <div class="box">1Ô∏è‚É£
        <a href="9.DevelopingDApp/4.UserModule.html#define-user-profiles-typesmo">
            <div>
                typse.mo
            </div>
            <div>
                Define type aliases
            </div>
        </a>
    </div>
    <div class="box">2Ô∏è‚É£
        <a href="9.DevelopingDApp/4.UserModule.html#directed-graph-digraphmo">
            <div>
                digraph.mo
            </div>
            <div>
                Directed graph
            </div>
        </a>
    </div>
    <div class="box">3Ô∏è‚É£
        <a href="9.DevelopingDApp/4.UserModule.html#storing-user-information-databasemo">
            <div>
                database.mo
            </div>
            <div>
                Store user profiles
            </div>
        </a>
    </div>
    <div class="box">4Ô∏è‚É£
        <a href="9.DevelopingDApp/4.UserModule.html#integrating-all-functions-mainmo">
            <div>
                main.mo
            </div>
            <div>
                Manage users
            </div>
        </a>
    </div>
</div>
<br>
<hr>
<br>
<a href="9.DevelopingDApp/5.PostModule.html">
<div class="home-box">
    <div class="box">2Ô∏è‚É£
        <div>
            Post Module
        </div>
        <div>
            Store all posts
        </div>
    </div>
</div>
</a>
<div class="home-box">
    <div class="box">1Ô∏è‚É£
    <a href="9.DevelopingDApp/5.PostModule.html#managing-canisters-rootpostmo">
        <div>
            rootPost.mo
        </div>
        <div>
            Manage all Buckets
        </div>
    </a>
    </div>
    <div class="box">2Ô∏è‚É£
    <a href="9.DevelopingDApp/5.PostModule.html#post">
        <div>
           bucket.mo
        </div>
        <div>
            Store posts
        </div>
    </a>
    </div>
</div>
<br>
<hr>
<br>
<a href="9.DevelopingDApp/6.FeedModule.html">
<div class="home-box">
    <div class="box">3Ô∏è‚É£
        <div>
            Feed Module
        </div>
        <div>
            User's own cloud terminal
        </div>
    </div>
</div>
</a>
<div class="home-box">
    <div class="box">1Ô∏è‚É£
    <a href="9.DevelopingDApp/6.FeedModule.html#creating-feed-canister-rootfeedmo">
        <div>
            rootFeed.mo
        </div>
        <div>
            Create Feed
        </div>
    </a>
    </div>
    <div class="box">2Ô∏è‚É£
    <a href="9.DevelopingDApp/6.FeedModule.html#storing-data-databasemo">
        <div>
            database.mo
        </div>
        <div>
            Store modules
        </div>
    </a>
    </div>
    <div class="box">3Ô∏è‚É£
    <a href="9.DevelopingDApp/6.FeedModule.html#user-cloud-services-feedmo">
        <div>
            feed.mo
        </div>
        <div>
            User's cloud terminal
        </div>
    </a>
    </div>
</div>
<br>
<hr>
<br>
<a href="9.DevelopingDApp/7.FetchModule.html">
<div class="home-box">
    <div class="box">4Ô∏è‚É£
        <div>
            Fetch Module
        </div>
        <div>
            Manage user relationships and user profiles
        </div>
    </div>
</div>
</a>
<div class="home-box">
    <div class="box">1Ô∏è‚É£
    <a href="9.DevelopingDApp/7.FetchModule.html#rootfetchmo">
        <div>
            rootFetch.mo
        </div>
        <div>
            Manage Fetch Canister
        </div>
    </a>
    </div>
    <div class="box">2Ô∏è‚É£
    <a href="9.DevelopingDApp/7.FetchModule.html#postfetchmo">
        <div>
            postFetch.mo
        </div>
        <div>
            Notify posts
        </div>
    </a>
    </div>
    <div class="box">3Ô∏è‚É£
    <a href="9.DevelopingDApp/7.FetchModule.html#likefetchmo">
        <div>
            likeFetch.mo
        </div>
        <div>
            Notify likes
        </div>
    </a>
    </div>
    <div class="box">4Ô∏è‚É£
    <a href="9.DevelopingDApp/7.FetchModule.html#commentfetchmo">
        <div>
            commentFetch.mo
        </div>
        <div>
            Notify comments
        </div>
    </a>
    </div>
</div>
<br>
<div class="center-image">
<img src="9.DevelopingDApp/assets/3.DevelopingProton/image-20240206095751397.png" alt="img" style="zoom:39%;" />
</div>
<p>ü´°</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/3.DevelopingProton/image-20231222150455236.png" alt="img" style="zoom:50%;" />
</div>
<br>
<div style="break-before: page; page-break-before: always;"></div><p>Let's take a look at the User module.</p>
<h2 id="user-1"><a class="header" href="#user-1">User</a></h2>
<p>The User module is responsible for Proton's user-related functionalities.</p>
<p>The functionalities we need are: follow user, unfollow user, get following list, get followers list, create and update user profiles, as well as user search functionality.</p>
<br>
<p>To implement the functionality of users following each other, we first need to store the follow relationships between users. We can use a directed graph as the data structure.</p>
<p>For the user-following functionality, we can model it as a directed graph:</p>
<ul>
<li><div class="home-box">
      <div class="box">1Ô∏è‚É£
          <a href="9.DevelopingDApp/4.UserModule.html#Define user profiles: types.mo">
              <div>
                  typse.mo
              </div>
              <div>
                  Define type aliases
              </div>
          </a>
      </div>
      <div class="box">2Ô∏è‚É£
          <a href="9.DevelopingDApp/4.UserModule.html#ÊúâÂêëÂõædigraphmo">
              <div>
                  digraph.mo
              </div>
              <div>
                  Directed graph
              </div>
          </a>
      </div>
      <div class="box">3Ô∏è‚É£
          <a href="9.DevelopingDApp/4.UserModule.html#Â≠òÂÇ®Áî®Êà∑‰ø°ÊÅØdatabasemo">
              <div>
                  database.mo
              </div>
              <div>
                  Store user profiles
              </div>
          </a>
      </div>
      <div class="box">4Ô∏è‚É£
          <a href="9.DevelopingDApp/4.UserModule.html#ÈõÜÊàêÊâÄÊúâÂäüËÉΩmainmo">
              <div>
                  main.mo
              </div>
              <div>
                  Manage users
              </div>
          </a>
      </div>
  </div>
</li>
<li>If user A follows user B, a directed edge (arrow) is drawn from node A to node B.</li>
<li>This forms a directed graph representing the follow relationships between users.</li>
</ul>
<div class="center-image">
<img src="9.DevelopingDApp/assets/4.UserModule/image-20240121085153960.png" alt="img" style="zoom:35%;" />
</div>
<p>A directed graph can visually represent the follow relationships between users, making it easy to understand and implement related algorithms.</p>
<p>Graph algorithms can also be used to analyze social relationships, such as finding the shortest path between nodes or checking who among the users you follow is followed by them.</p>
<br>
<h3 id="define-user-profiles-typesmo"><a class="header" href="#define-user-profiles-typesmo">Define user profiles: types.mo</a></h3>
<p>Before the directed graph, we need to define some type aliases to list the information in user profiles. In Motoko, use the <code>type</code> keyword to create type aliases, giving a new name to a type to make the code more straightforward and understandable.</p>
<p>Referring to the previous <a href="9.DevelopingDApp/">LinkedUp</a>, define in a separate module and import it in the file using the module.</p>
<p>Now, let's define the vertices of the directed graph (users) and user profiles.</p>
<pre><code class="language-js">import Principal &quot;mo:base/Principal&quot;; // Import relevant content from the Motoko base library
import Time &quot;mo:base/Time&quot;;

module {

    public type Vertex = Principal;
    public type UserId = Principal;
    public type Time = Time.Time;

    public type NewProfile = {
        name: Text;
        biography: Text;
        company: Text;
        education: Text;
        imgUrl: Text;
        feedCanister: ?Principal;
    };

    public type Profile = {
        id: UserId;
        name: Text;
        biography: Text;
        company: Text;
        education: Text;
        imgUrl: Text;
        feedCanister: ?Principal;
    };

};
</code></pre>
<p>Import statement:</p>
<pre><code class="language-js">import Principal &quot;mo:base/Principal&quot;;
</code></pre>
<p>This line of code means importing a module from Motoko's standard library, specifically the <code>Principal</code> module, which is related to identity and can be considered as the ID of users or services on the IC.</p>
<h3 id="directed-graph-digraphmo"><a class="header" href="#directed-graph-digraphmo">Directed Graph: digraph.mo</a></h3>
<p>Now, let's create the digraph.mo file and define a class <code>Digraph</code> to represent the follow relationships between users.</p>
<p>Write down the types defined earlier:</p>
<pre><code class="language-js">module {
  type Vertex = Types.Vertex;
}Ôºõ
</code></pre>
<p><code>vertexList</code> stores all the vertices, and <code>edgeList</code> stores all the directed edges, representing the follow relationships:</p>
<pre><code class="language-js">type Vertex = Types.Vertex;

public class Digraph() {
    var vertexList: [Vertex] = []; // Vertices
    var edgeList: [(Vertex, Vertex)] = []; // Directed edges
}Ôºõ
</code></pre>
<p><code>addVertex</code> is used to add vertices (users), and <code>addEdge</code> is used to add edges (follow relationships), using <code>assert</code> to ensure the uniqueness of edges:</p>
<pre><code class="language-js">type Vertex = Types.Vertex;

public class Digraph() {
    var vertexList: [Vertex] = []; // Vertices
    var edgeList: [(Vertex, Vertex)] = []; // Directed edges

    // The public keyword indicates that this function is accessible to anyone
    // If private, it can only be called by code within the Canister, not publicly accessible
    public func addVertex(vertex: Vertex) {
      vertexList := Array.append&lt;Vertex&gt;(vertexList, [vertex]);
    };

    // Add a directed edge from fromVertex to toVertex
    public func addEdge(fromVertex: Vertex, toVertex: Vertex) {
      // Check if it already exists
      assert(Array.find&lt;(Vertex, Vertex)&gt;(edgeList, func((x, y): (Vertex, Vertex)): Bool {
        x == fromVertex and y == toVertex
      }) == null);
      edgeList := Array.append&lt;(Vertex, Vertex)&gt;(edgeList, [(fromVertex, toVertex)]);
    };

}Ôºõ
</code></pre>
<br>
<p><code>getForwardAdjacent</code> and <code>getReverseAdjacent</code> are used to get forward and reverse adjacent vertices, representing the user's following list and followers list, implemented by iterating through the edge list:</p>
<pre><code class="language-js">import Array &quot;mo:base/Array&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Types &quot;./types&quot;;

module {

  type Vertex = Types.Vertex;

  public class Digraph() {

    var vertexList: [Vertex] = []; // Vertices
    var edgeList: [(Vertex, Vertex)] = []; // Directed edges

    public func addVertex(vertex: Vertex) {
      vertexList := Array.append&lt;Vertex&gt;(vertexList, [vertex]);
    };

    // Add a directed edge from fromVertex to toVertex
    public func addEdge(fromVertex: Vertex, toVertex: Vertex) {
      // Check if it already exists
      assert(Array.find&lt;(Vertex, Vertex)&gt;(edgeList, func((x, y): (Vertex, Vertex)): Bool {
        x == fromVertex and y == toVertex
      }) == null);
      edgeList := Array.append&lt;(Vertex, Vertex)&gt;(edgeList, [(fromVertex, toVertex)]);
    };

    // Get vertices adjacent to the forward edge, i.e., get someone's following list
    public func getForwardAdjacent(vertex: Vertex): [Vertex] {
      var adjacencyList: [Vertex] = [];
      for ((fromVertex, toVertex) in Iter.fromArray&lt;(Vertex, Vertex)&gt;(edgeList)) {
        if (fromVertex == vertex) {
          adjacencyList := Array.append&lt;Vertex&gt;(adjacencyList, [toVertex]);
        };
      };
      adjacencyList
    };
    
    // Get vertices adjacent to the reverse edge, i.e., get someone's followers list
    public func getReverseAdjacent(vertex: Vertex): [Vertex] {
      var adjacencyList: [Vertex] = [];
      for ((fromVertex, toVertex) in Iter.fromArray&lt;(Vertex, Vertex)&gt;(edgeList)) {
        if (toVertex == vertex) {
          adjacencyList := Array.append&lt;Vertex&gt;(adjacencyList, [fromVertex]);
        };
      };
      adjacencyList
    };

  };
  
};
</code></pre>
<p>Now, with the directed graph storing user relationships, we also need a place to store user profiles.</p>
<br>
<h3 id="storing-user-information-databasemo"><a class="header" href="#storing-user-information-databasemo">Storing User Information: database.mo</a></h3>
<p>Let's create another file specifically for storing user profiles: database.mo.</p>
<p>Define a storage class <code>Directory</code> for user information, using <code>HashMap</code> to store user IDs and their corresponding profiles:</p>
<pre><code class="language-js">public class Directory() {
    let hashMap = HashMap.HashMap&lt;UserId, Profile&gt;(1, isEq, Principal.hash);
};
</code></pre>
<blockquote>
<p>A hash table, also known as a hash map, is a data structure that allows direct access to data based on key values. A hash table calculates a function (known as a hash function) for a key value, mapping the queried data to a position for access, thus speeding up the search for a specific key value.</p>
<p>The working principle of a hash table can be explained with an intuitive example:</p>
<p>Suppose there is a dictionary with a large amount of information about Chinese characters. To quickly find a specific character, a table is created initially arranged alphabetically by the pinyin letters of each character (similar to the &quot;Pinyin Check Character Table&quot; at the beginning of the dictionary). This establishes a kind of functional relationship between each character and its pinyin letters. When searching for a character, it is only necessary to locate the first letter, the second letter, the third letter, and so on, in this table. Most of the time, it's even possible to determine the accurate position of the character in the dictionary without searching through every letter of its pinyin. In this example, &quot;finding the nth letter of the pinyin&quot; is analogous to the hash function's rule, and the &quot;Pinyin Check Character Table&quot; can be understood as a kind of hash table.</p>
</blockquote>
<p>There are also some functions to implement the functionalities of creating user profiles, updating user profiles, retrieving individual user profiles, retrieving multiple user profiles, and searching for users based on keywords.</p>
<p>The <code>createOne</code> and <code>updateOne</code> functions are used to create and update user profiles by calling the <code>put</code> function to add user IDs and profiles to the HashMap.</p>
<pre><code class="language-js">public class Directory() {
  let hashMap = HashMap.HashMap&lt;UserId, Profile&gt;(1, isEq, Principal.hash);
  
  public func createOne(userId: UserId, profile: NewProfile) {
    hashMap.put(userId, makeProfile(userId, profile));
  };

  public func updateOne(userId: UserId, profile: NewProfile) {
    hashMap.put(userId, makeProfile(userId, profile));
  };
  
  // Other functions...
}
</code></pre>
<p>The <code>findOne</code> function is used to retrieve an individual user profile by calling the <code>get</code> function from the HashMap.</p>
<pre><code class="language-js">public func findOne(userId: UserId): ?Profile {
  hashMap.get(userId)
};
</code></pre>
<p>The <code>findMany</code> function is used to retrieve multiple user profiles by iterating through the list of user IDs and calling the <code>getProfile</code> function.</p>
<pre><code class="language-js">public func findMany(userIds: [UserId]): [Profile] {
  func getProfile(userId: UserId): Profile {
    Option.unwrap&lt;Profile&gt;(hashMap.get(userId))
  };
  Array.map&lt;UserId, Profile&gt;(userIds, getProfile)
};
</code></pre>
<p>The <code>findBy</code> function is used to search for users based on keywords, iterating through the user profiles in the HashMap and finding matching profiles.</p>
<pre><code class="language-js">public func findBy(term: Text): [Profile] {
  var profiles: [Profile] = [];
  for ((id, profile) in hashMap.entries()) {
    if (includesText(profile.name, term)) {
      profiles := Array.append&lt;Profile&gt;(profiles, [profile]);
    };
  };
  profiles
};
</code></pre>
<p>The auxiliary function <code>makeProfile</code> is used to create an instance of a user profile, and <code>includesText</code> is used to determine if one string contains another.</p>
<pre><code class="language-js">func makeProfile(userId: UserId, profile: NewProfile): Profile {
  {
    id = userId;
    name = profile.name;
    biography = profile.biography;
    company = profile.company;
    education = profile.education;
    imgUrl = profile.imgUrl;
    feedCanister = profile.feedCanister;
  }
};

func includesText(string: Text, term: Text): Bool {
  let stringArray = Iter.toArray&lt;Char&gt;(string.chars());
  let termArray = Iter.toArray&lt;Char&gt;(term.chars());

  var i = 0;
  var j = 0;

  while (i &lt; stringArray.size() and j &lt; termArray.size()) {
    if (stringArray[i] == termArray[j]) {
      i += 1;
      j += 1;
      if (j == termArray.size()) { return true; }
    } else {
      i += 1;
      j := 0;
    }
  };
  false
};
</code></pre>
<p>database.mo: </p>
<pre><code class="language-js">import Array &quot;mo:base/Array&quot;;
import Hash &quot;mo:base/Hash&quot;;
import HashMap &quot;mo:base/HashMap&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Option &quot;mo:base/Option&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Time &quot;mo:base/Time&quot;;
import Types &quot;./types&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import TrieSet &quot;mo:base/TrieSet&quot;;

module {
  
  type NewProfile = Types.NewProfile;
  type Profile = Types.Profile;
  type UserId = Types.UserId;
  type Time = Time.Time;

  public class Directory() {

    let hashMap = HashMap.HashMap&lt;UserId, Profile&gt;(1, isEq, Principal.hash);

    public func createOne(userId: UserId, profile: NewProfile) {
      hashMap.put(userId, makeProfile(userId, profile));
    };

    public func updateOne(userId: UserId, profile: NewProfile) {
      hashMap.put(userId, makeProfile(userId, profile));
    };

    public func findOne(userId: UserId): ?Profile {
      hashMap.get(userId)
    };

    public func findMany(userIds: [UserId]): [Profile] {
      func getProfile(userId: UserId): Profile {
        Option.unwrap&lt;Profile&gt;(hashMap.get(userId))
      };
      Array.map&lt;UserId, Profile&gt;(userIds, getProfile)
    };

    public func findBy(term: Text): [Profile] {
      var profiles: [Profile] = [];
      for ((id, profile) in hashMap.entries()) {
        if (includesText(profile.name, term)) {
          profiles := Array.append&lt;Profile&gt;(profiles, [profile]);
        };
      };
      profiles
    };

    // Helpers

    func makeProfile(userId: UserId, profile: NewProfile): Profile {
      {
        id = userId;
        name = profile.name;
        biography = profile.biography;
        company = profile.company;
        education = profile.education;
        imgUrl = profile.imgUrl;
        feedCanister = profile.feedCanister;
      }
    };

    func includesText(string: Text, term: Text): Bool {
      let stringArray = Iter.toArray&lt;Char&gt;(string.chars());
      let termArray = Iter.toArray&lt;Char&gt;(term.chars());

      var i = 0;
      var j = 0;

      while (i &lt; stringArray.size() and j &lt; termArray.size()) {
        if (stringArray[i] == termArray[j]) {
          i += 1;
          j += 1;
          if (j == termArray.size()) { return true; }
        } else {
          i += 1;
          j := 0;
        }
      };
      false
    };
  };

  func isEq(x: UserId, y: UserId): Bool { x == y };
};

</code></pre>
<br>
<h3 id="integrating-all-functions-mainmo"><a class="header" href="#integrating-all-functions-mainmo">Integrating All Functions: main.mo</a></h3>
<p>After completing types.mo, digraph.mo, and database.mo, the final step is to integrate the aforementioned modules using the actor and implement all functionalities.</p>
<div class="center-image">
    <img src="9.DevelopingDApp/assets/4.UserModule/image-20240117170030924.png" alt="img" style="zoom:33%;" />
</div>
<p>The Digraph class implements a directed graph data structure for storing relationships between users. The Database class implements a database for user profiles.</p>
<img src="9.DevelopingDApp/assets/4.UserModule/image-20240208211521682.png" alt="image-20240208211521682" style="zoom:50%;" />
<p>Now, we use the User actor class to implement the main functionalities of the user module. The User class represents a user in the social network, including functions such as following other users, retrieving the list of followers, obtaining the list of followers, creating and updating user profiles, and searching for users.</p>
<p>Relationships between modules:</p>
<img src="9.DevelopingDApp/assets/4.UserModule/image-20240121114437945.png" alt="image-20240121114437945" style="zoom:33%;" />
<p>The User actor relies on the Digraph and Database classes to implement the underlying data structures.</p>
<br>
<p>In Motoko, an <code>actor</code> is a special type that can be thought of as a small machine or service capable of executing code. Each actor has a unique Principal ID, and it can be considered an entry point for a microservice in a service-oriented architecture.</p>
<pre><code class="language-js">actor class Feed(...) = this { ... }
</code></pre>
<p>Here, we see an <code>actor class</code>, which is a special form of an <code>actor</code> that can accept parameters to create new <code>actor</code> instances. This is similar to classes in object-oriented programming.</p>
<p>According to the previous design, the functionalities we want to implement are summarized as follows:</p>
<ul>
<li>Allow one user to follow another user, updating the directed graph's edges and notifying the followed user's Feed Canister to update the followers' list.</li>
<li>Query the following list and followers list of a specific user through the directed graph.</li>
<li>Add and update a user's profile.</li>
<li>Query user profiles.</li>
</ul>
<img src="9.DevelopingDApp/assets/4.UserModule/image-20240208211810805.png" alt="image-20240208211810805" style="zoom:67%;" />
<p>Here is the English translation:</p>
<br>
<p>We create a <code>rootFeedCanister</code> to record the Root Feed Canister.</p>
<p>The <code>init</code> function is used to initialize the user's root Feed Canister.</p>
<p>The <code>getRootFeedCanister</code> function is used to retrieve the user's root Feed Canister.</p>
<pre><code class="language-js">// Define UserActor
actor class User() = this {
    
    // Use a variable to represent the Root Feed Canister (used to store user feed data)
    // Principal.fromText is used here, so import the module above: import Principal
    stable var rootFeedCanister = Principal.fromText(&quot;2vxsx-fae&quot;);

    // Initialization function, set Root Feed Canister
    public shared({caller}) func init(_rootFeedCanister: Principal) {
        rootFeedCanister := _rootFeedCanister;
    };

    // Query Root Feed Canister
    // The query keyword indicates a query function, used to query data
    // The response is very fast, does not go through consensus, and does not change the Canister state
    public query func getRootFeedCanister(): async Principal {
        rootFeedCanister
    };
}
</code></pre>
<p>Public, private, and shared functions:</p>
<p>Functions in Motoko can be <code>public</code> (public), <code>private</code> (private), similar to access control in other programming languages. <code>shared</code> functions are a special type of public function that can communicate between different actors.</p>
<pre><code class="language-js">public shared({caller}) func init(...) { ... }
</code></pre>
<p>This function can be called by an external actor, and <code>{caller}</code> is a pattern match used to obtain the identity of the caller.</p>
<br>
<p>The <code>follow</code> function is used for a user to follow another user, involving updating the follower's Feed Canister and updating the directed graph.</p>
<pre><code class="language-js">// Function for a user to follow another user
public shared({caller}) func follow(user: Vertex): async () {
    // Check if Root Feed Canister is anonymous
    assert(not Principal.isAnonymous(rootFeedCanister));
    
    // Create a RootFeedActor instance based on Root Feed Canister
    let rootFeedActor: RootFeedActor = actor(Principal.toText(rootFeedCanister));
    
    // Iterate through all user Feed Canisters in Root Feed Actor
    for((_, _feedCanister) in (await rootFeedActor.getAllUserFeedCanister()).vals()) {
        
        // Create a FeedActor instance based on Feed Canister
        let feedActor: FeedActor = actor(Principal.toText(_feedCanister));
        
        // Ignore the return value when calling followers, the list of followers is in the Feed Canister
        ignore feedActor.updateFollowers(Array.append(
            graph.getReverseAdjacent(user),
            [caller]
        ));
    };
    // Add an edge in the graph, indicating that the user is following another user
    graph.addEdge(caller, user);
};
</code></pre>
<p>The <code>shared</code> keyword is used to declare a function or type as shared. This means that they can be shared and used between different actors.</p>
<p>If you declare a <code>public shared</code> function in one actor, this function can be called by other actors and modify their state through asynchronous message passing.</p>
<p><a href="https://github.com/Web3NL/motoko-book/blob/main/src/internet-computer-programming-concepts/actors.md"><code>public shared func oneway() { };</code></a> is an example of a function with no return type that can modify the actor's state and returns <code>()</code> regardless of success.</p>
<p>Motoko also defines a series of shared types. Only shared types can be used as parameters and return values for public shared functions. These shared types include all primitive types (except the <code>Error</code> type), the <code>Option</code> type, tuple types, immutable array types, object types, etc. For example, <a href="https://github.com/Web3NL/motoko-book/blob/main/src/internet-computer-programming-concepts/async-data/shared-types.md"><code>Nat</code></a> and <a href="https://github.com/Web3NL/motoko-book/blob/main/src/internet-computer-programming-concepts/async-data/shared-types.md"><code>Text</code></a> are shared types.</p>
<br>
<p>The <code>getFollowingList</code> and <code>getFollowersList</code> functions retrieve the user's following list and followers list.</p>
<p>The <code>createProfile</code> and <code>updateProfile</code> functions create and update user profiles.</p>
<p>The <code>getProfile</code> function retrieves the user's profile.</p>
<p>The <code>searchProfile</code> function searches for users based on keywords.</p>
<p>Overall, this is how it looks:</p>
<img src="9.DevelopingDApp/assets/4.UserModule/image-20240208212802310.png" alt="image-20240208212802310" style="zoom:50%;" />
<p>The complete <code>main.mo</code> file is as follows:</p>
<pre><code class="language-js">import Array &quot;mo:base/Array&quot;;
import Digraph &quot;./digraph&quot;;
import Database &quot;./database&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Types &quot;./types&quot;;

// Define UserActor
actor class User() = this {
    
    // Use a variable to represent the Root Feed Canister (used to store user feed data)
    // Principal.fromText is used here, so import the module above: import Principal
    stable var rootFeedCanister = Principal.fromText(&quot;2vxsx-fae&quot;);

    // Initialization function, set Root Feed Canister
    public shared({caller}) func init(_rootFeedCanister: Principal) {
        rootFeedCanister := _rootFeedCanister;
    };

    // Query Root Feed Canister
    // The query keyword indicates a query function, used to query data
    // The response is very fast, does not go through consensus, and does not change the Canister state
    public query func getRootFeedCanister(): async Principal {
        rootFeedCanister
    };

// ==================== Follow Info ====================

    // Define type aliases
    type Vertex = Types.Vertex;
    type RootFeedActor = Types.RootFeedActor;
    type FeedActor = Types.FeedActor;

    // Create a directed graph instance
    var graph: Digraph.Digraph = Digraph.Digraph();

    // Function for a user to follow another user
    public shared({caller}) func follow(user: Vertex): async () {
        // Check if Root Feed Canister is anonymous
        assert(not Principal.isAnonymous(rootFeedCanister));
        
        // Create a RootFeedActor instance based on Root Feed Canister
        let rootFeedActor: RootFeedActor = actor(Principal.toText(rootFeedCanister));
        
        // Iterate through all user Feed Canisters in Root Feed Actor
        for((_, _feedCanister) in (await rootFeedActor.getAllUserFeedCanister()).vals()) {
            
            // Create a FeedActor instance based on Feed Canister
            let feedActor: FeedActor = actor(Principal.toText(_feedCanister));
            
            // Ignore the return value when calling followers, the list of followers is in the Feed Canister
            ignore feedActor.updateFollowers(Array.append(
                graph.getReverseAdjacent(user),
                [caller]
            ));
        };
        // Add an edge in the graph, indicating that the user is following another user
        graph.addEdge(caller, user);
    };

    // Get the user's following list
    public query({caller}) func getFollowingList(user: Vertex): async [Vertex] {
        graph.getForwardAdjacent(user)
    };

    // Get the followers list
    public query({caller}) func

 getFollowersList(user: Vertex): async [Vertex] {
        graph.getReverseAdjacent(user)
    };

// ==================== Profiles ====================

    // Define type aliases
    type NewProfile = Types.NewProfile;
    type Profile = Types.Profile;
    type UserId = Types.UserId;

    // Create a database instance to store user profiles
    var directory: Database.Directory = Database.Directory();

    // Create a user profile
    public shared({caller}) func createProfile(profile: NewProfile): async () {
        directory.createOne(caller, profile);
    };

    // Update a user's profile
    public shared({caller}) func updateProfile(profile: NewProfile): async () {
        directory.updateOne(caller, profile);
    };

    // Get a user's profile based on user ID
    public query func getProfile(userId: UserId): async ?Profile {
        directory.findOne(userId)
    };

    // Search for user profiles based on a search term
    public query func searchProfile(term: Text): async [Profile] {
        directory.findBy(term)
    };

}
</code></pre>
<p>Now, the User module is complete with basic social network functionalities. It maintains relationships between users using a directed graph, stores and queries user profiles using a database, and updates user activities through the Root Feed Canister.</p>
<p>Next, we'll move on to building <a href="9.DevelopingDApp/./5.PostModule.html">the Post module</a>. </p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="post-1"><a class="header" href="#post-1">Post</a></h2>
<p>Users publish and retrieve posts through the Feed, and all posts are stored in a Bucket. The notification fetching feature is handled through Fetch. </p>
<p>The next thing we have to implement is the Post module. However, we need types like Post, Like, Comment, and interactions with other Canisters. Moreover, these types are also needed in Feed and Fetch. </p>
<p>Therefore, for types that need to be globally shared, we can place them outside the module folder: </p>
<pre><code class="language-plaintext">src
  ‚îú‚îÄ‚îÄ feed
  ‚îú‚îÄ‚îÄ fetch
  ‚îú‚îÄ‚îÄ post
  ‚îú‚îÄ‚îÄ user
  ‚îú‚îÄ‚îÄ types.mo  üëà
  ‚îî‚îÄ‚îÄ utils.mo
</code></pre>
<p>When using them, reference the contents of types.mo into the types.mo inside the module folder and then import them into other files.</p>
<br>
<p>For example, define the Post type representing posts that users publish and place it in types.mo outside the module folder. You can see more details in <a href="9.DevelopingDApp/./8.%E5%85%B1%E4%BA%AB%E7%B1%BB%E5%9E%8B.html">8. Shared Types</a>. A post includes various information such as post ID, publisher, post index, publication time, content, likes, comments, and more.</p>
<pre><code class="language-motoko">public type Post = {
    postId: PostId;
    feedCanister: Principal;
    index: Nat;
    user: UserId;
    content: Text;
    var repost: [Repost];
    var like: [Like];
    var comment: [Comment];
    createdAt: Time;
};
</code></pre>
<img src="9.DevelopingDApp/assets/5.PostModule/image-20231120173647549-1707384149072-60.png" alt="img" style="zoom:39%;" />
<p>According to the previous design, the Post module has two Canisters: Root Post and Bucket.</p>
<p>Root Post is responsible for coordinating all Buckets:</p>
<ul>
<li>Create a sufficient number of Buckets (always keep 5 available).</li>
<li>Query all Buckets, available Buckets, and full Buckets.</li>
</ul>
<br>
<p>Bucket is the place directly storing post content:</p>
<ul>
<li>Store posts.</li>
<li>Query the total number of posts, query a single post by post ID, query multiple posts, and get the latest posts.</li>
<li>After receiving new comments, notify through CommentFetch.</li>
<li>Also maintain the addresses of two sub-modules, providing functions for updating and querying these two Canisters.</li>
<li>The Bucket uses the <code>checkBucketMemory</code> function to check the number of posts. When approaching the threshold, notify the Root Post module to recreate the Bucket.</li>
</ul>
<br>
<h3 id="managing-canisters-rootpostmo"><a class="header" href="#managing-canisters-rootpostmo">Managing Canisters: rootPost.mo</a></h3>
<p>Take a look at the Root Post Canister. Root Post needs to manage Buckets, and we can use a <code>TrieMap</code> to record three different states of Buckets: <code>buckets</code> stores all created Buckets, <code>availableBuckets</code> stores available Buckets, and <code>unavailableBuckets</code> stores Buckets that are already full.</p>
<p>Since 5 Canisters need to be created after deploying the Canister, we also need an initialization function and later functions to add new Buckets. When creating a Bucket, we also need to tell the Bucket the Canister ID of the Comment Fetch and Like Fetch in the system. Therefore, in Root Post, we need to record and save Comment Fetch and Like Fetch.</p>
<p>Finally, there are functions to query all Buckets, query available Buckets, and query full Buckets.</p>
<br>
<p>First, define some stable variables and mappings to save Buckets.</p>
<p>In Motoko, the <code>stable</code> keyword is used to define stable variables. The values of these variables should persist during the Canister upgrade process. This is a unique feature of Motoko, using the stable memory of the Internet Computer Protocol (ICP) to maintain data persistence during Canister upgrades. Stable memory can accommodate up to 400 GiB of data, regardless of the language used, whether it's Motoko, Rust, or any other language. Stable memory is a feature that allows IC to store data for an extended period.</p>
<p>With the definition of these stable variables and mappings, the state, total number, and other information of multiple Buckets can be persistently stored. They can continue to be used after Canister upgrades, achieving persistent management of Buckets.</p>
<pre><code class="language-js">stable let T_CYCLES = 1_000_000_000_000; // Predefine 1T Cycles for later use
stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // Record the maximum number of posts each Bucket can store
stable var bucketIndex: Nat = 0; // Record the number of Buckets already created

// Define an array to save information about all created Buckets
stable var bucketsEntries: [(Nat, Principal)] = [];
// buckets is a map created based on bucketsEntries, where the key is the index, and the value is the principal of the Bucket
let buckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(bucketsEntries.vals(), Nat.equal, Hash.hash);

// availableBucketsEntries and availableBuckets are used to record currently available Buckets
stable var availableBucketsEntries: [(Nat, Principal)] = [];
let availableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(availableBucketsEntries.vals(), Nat.equal, Hash.hash);

// unavailableBucketsEntries and unavailableBuckets are used to record currently unavailable Buckets
stable var unavailableBucketsEntries: [(Nat, Principal)] = [];
let unavailableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(unavailableBucketsEntries.vals(), Nat.equal, Hash.hash);
</code></pre>
<br>
<p>The <code>_createBucket()</code> function creates a Canister:</p>
<p>Using the <code>Bucket</code> function of the <code>Bucket.Bucket</code> object, it creates a new <code>Bucket</code> actor, passing the principal (ID) of the Root Post Canister, <code>commentFetchCanister</code>, and <code>likeFetchCanister</code> as parameters.</p>
<pre><code class="language-js">// Logic to create a Bucket
private func _createBucket(): async Principal {
    // Add 4T Cycles to each Bucket
    Cycles.add(4 * T_CYCLES);
    let newBucket = await Bucket.Bucket(
        Principal.fromActor(this),
        commentFetchCanister,
        likeFetchCanister
    );

    // Save the principal of the newly created Bucket to the 'buckets' mapping, with the key as the current 'bucketIndex'
    buckets.put(bucketIndex, Principal.fromActor(newBucket));
    // Also save it to the 'availableBuckets' mapping, indicating that this Bucket is currently available
    availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));

    // Increment 'bucketIndex' by 1, indicating an increase in the number of created Buckets
    bucketIndex += 1;
    
    // Return the principal of the newly created Bucket
    Principal.fromActor(newBucket)
};
</code></pre>
<p>This way, the <code>_createBucket()</code> function can create a new <code>Bucket</code> actor and save its principal to two mapping tables, indicating the created and available states.</p>
<p>It encapsulates the specific logic for creating a Bucket and is called by the <code>createBucket()</code> public function. It uses <code>bucketIndex</code> to identify each Bucket and increments this index after creation.</p>
<p>It provides an easy way to create Buckets in batches, specifying their states and facilitating the management of multiple Buckets.</p>
<br>
<p>Next, continue building functions to create and manage multiple Buckets.</p>
<pre><code class="language-js">// Start by creating 5 Buckets and adding them to the 'buckets' and 'availableBuckets' mapping tables
public shared({caller}) func init(): async {
    var i = 0;
    label l loop {
        if(i &gt;= 5) break l;

        Cycles.add(4 * T_CYCLES);
        let newBucket = await Bucket.Bucket(
            Principal.fromActor(this),
            commentFetchCanister,
            likeFetchCanister
        );

        buckets.put(bucketIndex, Principal.fromActor(newBucket));
        availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));
        bucketIndex += 1;

        i += 1;
    };
};

// Add previously created Buckets in bulk to 'buckets' and 'availableBuckets'
public shared({caller}) func addAvailBucket(bucketArray: [Principal]): async () {
    for(_bucket in bucketArray.vals()) {
        buckets.put(bucketIndex, _bucket);
        availableBuckets.put(bucketIndex, _bucket);
        bucketIndex += 1;
    };
};

// Return the current number of created Buckets
public query func getBucketIndex(): async Nat { bucketIndex };

// Public function to create a Bucket, internally calls _createBucket()
public shared({caller}) func createBucket(): async Principal {
    await _createBucket()
};
</code></pre>
<p>Now our Canister can manage the creation and addition of Buckets. The creation and lifecycle of all Buckets can be centrally managed.</p>
<br>
<p>Later, we need to write query functions:</p>
<pre><code class="language-js">// Query available Buckets
public query func getAvailableBucket(): async ?Principal {
    if(availableBuckets.size() == 0) return null;
    availableBuckets.get(Nat.rem(Option.unwrap(Nat.fromText(Int.toText(Time.now()))), availableBuckets.size()))
};

// Query all Buckets
public query func getAllBuckets(): async [Principal] {
    Iter.toArray(buckets.vals())
};

// Query all available Buckets
public query func getAllAvailableBuckets(): async [Principal] {
    Iter.toArray(availableBuckets.vals())
};

// Query all Buckets that are already full
public query func getAllUnavailableBuckets(): async [Principal] {
    Iter.toArray(unavailableBuckets.vals())
};
</code></pre>
<br>
<p>When creating a Bucket, we also need to tell the Bucket system the Canister IDs of the Comment Fetch and Like Fetch, so in the Root Post we also need to record and save the Comment Fetch and Like Fetch:</p>
<pre><code class="language-js">// Persistently save the principal id of the commentFetch canister
stable var commentFetchCanister = _commentFetchCanister;

// Externally query the currently saved commentFetch canister id  
public query func getCommentFetchCanister(): async Principal {
  commentFetchCanister
};

// Authorize specific caller to update the saved commentFetch canister id
public shared({caller}) func updateCommentFetchCanister**(
  newCommentFetchCanister: Principal  
): async () {
  commentFetchCanister := newCommentFetchCanister; 
};
</code></pre>
<p>Now the principal ID of the likeFetch canister can be persistently saved, flexibly updated via the update function, and externally queried.</p>
<pre><code class="language-js">// Persistently save the principal id of the likeFetch canister
stable var likeFetchCanister = _likeFetchCanister;

// Externally query the currently saved likeFetch canister id
public query func getLikeFetchCanister(): async Principal {
  likeFetchCanister
};

// Authorize specific caller to update the saved likeFetch canister id  
public shared({caller}) func updateLikeFetchCanister**(
  newLikeFetchCanister: Principal
): async () {
  likeFetchCanister := newLikeFetchCanister;
}; 
</code></pre>
<br>
<p>Finally there are two system functions <code>preupgrade()</code> and <code>postupgrade()</code>, used to save and reset the entries of buckets, availableBuckets and unavailableBuckets before and after the Canister upgrade.</p>
<pre><code class="language-js">system func preupgrade() {
  bucketsEntries := Iter.toArray(buckets.entries());
  availableBucketsEntries := Iter.toArray(availableBuckets.entries());
  unavailableBucketsEntries := Iter.toArray(unavailableBuckets.entries());
};

system func postupgrade() {
  bucketsEntries := [];
  availableBucketsEntries := []; 
  unavailableBucketsEntries := [];
};
</code></pre>
<p>The <code>preupgrade()</code> function is called before the Canister upgrade, it saves all the entries in buckets, availableBuckets and unavailableBuckets to the corresponding arrays bucketsEntries, availableBucketsEntries and unavailableBucketsEntries. </p>
<p>The <code>postupgrade()</code> function is called after the Canister upgrade, it clears the bucketsEntries, availableBucketsEntries and unavailableBucketsEntries arrays, effectively resetting the data in buckets, availableBuckets and unavailableBuckets.</p>
<p>Thus, by saving and resetting entries before and after the upgrade, the data in buckets, availableBuckets and unavailableBuckets is not lost after the Canister upgrade.</p>
<p><code>preupgrade</code> and <code>postupgrade</code> are defined as system functions, automatically called by the Runtime, developers don't need to call them.</p>
<p>This code implements data migration for Canister upgrades, by saving and resetting state before and after the upgrade, ensuring the transparency of the Canister upgrade.</p>
<br>
<div class="center-image">
<img src="9.DevelopingDApp/assets/5.PostÊ®°Âùó/image-20240130131002611.png" alt="image-20240130131002611" style="zoom:39%;" />
</div>
<p>The complete rootPost.mo file is as follows:</p>
<pre><code class="language-js">import Hash &quot;mo:base/Hash&quot;;
import Nat &quot;mo:base/Nat&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Types &quot;./types&quot;;
import Bucket &quot;./bucket&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Cycles &quot;mo:base/ExperimentalCycles&quot;;
import Time &quot;mo:base/Time&quot;;
import Int &quot;mo:base/Int&quot;;
import Option &quot;mo:base/Option&quot;;
import IC &quot;mo:ic&quot;;

actor class RootPost(
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {

    stable let T_CYCLES = 1_000_000_000_000;
    stable let BUCKET_MAX_POST_NUMBER: Nat = 5000;
    stable var bucketIndex: Nat = 0;

    stable var bucketsEntries: [(Nat, Principal)] = [];
    let buckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(bucketsEntries.vals(), Nat.equal, Hash.hash);

    stable var availableBucketsEntries: [(Nat, Principal)] = [];
    let availableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(availableBucketsEntries.vals(), Nat.equal, Hash.hash);

    stable var unavailableBucketsEntries: [(Nat, Principal)] = [];
    let unavailableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(unavailableBucketsEntries.vals(), Nat.equal, Hash.hash);

    // Start by creating 5 Buckets
    public shared({caller}) func init(): async () {
        var i = 0;
        label l loop {
            if(i &gt;= 5) break l;

            Cycles.add(4 * T_CYCLES);
            let newBucket = await Bucket.Bucket(
                Principal.fromActor(this),
                commentFetchCanister,
                likeFetchCanister
            );

            buckets.put(bucketIndex, Principal.fromActor(newBucket));
            availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));
            bucketIndex += 1;

            i += 1;
        };
    };

    public shared({caller}) func addAvailBucket(bucketArray: [Principal]): async () {
        for(_bucket in bucketArray.vals()) {
            buckets.put(bucketIndex, _bucket);
            availableBuckets.put(bucketIndex, _bucket);
            bucketIndex += 1;
        };
    };

    public query func getBucketIndex(): async Nat { bucketIndex };

    public shared({caller}) func createBucket(): async Principal {
        await _createBucket()
    };

    private func _createBucket(): async Principal {
        Cycles.add(4 * T_CYCLES);
        let newBucket = await Bucket.Bucket(
            Principal.fromActor(this),
            commentFetchCanister,
            likeFetchCanister
        );

        buckets.put(bucketIndex, Principal.fromActor(newBucket));
        availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));

        bucketIndex += 1;

        Principal.fromActor(newBucket)
    };

    public shared({caller}) func reCreateBucket(): async () {
        for((_key, _bucket) in availableBuckets.entries()) {
            if(_bucket == caller) {
                ignore await _createBucket();
                availableBuckets.delete(_key);
                unavailableBuckets.put(_key, _bucket);
            };
        };
    };

    // Query available buckets
    public query func getAvailableBucket(): async ?Principal {
        if(availableBuckets.size() == 0) return null;
        availableBuckets.get(Nat.rem(Option.unwrap(Nat.fromText(Int.toText(Time.now()))), availableBuckets.size()))
    };

    // Query all Buckets
    public query func getAllBuckets(): async [Principal] {
        Iter.toArray(buckets.vals())
    };

    public query func getAllAvailableBuckets(): async [Principal] {
        Iter.toArray(availableBuckets.vals())
    };

    // Query the full Bucket
    public query func getAllUnavailableBuckets(): async [Principal] {
        Iter.toArray(unavailableBuckets.vals())
    };

// ==================== CommentFetchCanister ====================

    stable var commentFetchCanister = _commentFetchCanister;
    
    public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

    public shared({caller}) func updateCommentFetchCanister(
        newCommentFetchCanister: Principal
    ): async () {
        commentFetchCanister := commentFetchCanister;
    };


// ==================== LikeFetchCanister ====================

    stable var likeFetchCanister = _likeFetchCanister;
    
    public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

    public shared({caller}) func updateLikeFetchCanister(
        newLikeFetchCanister: Principal
    ): async () {
        likeFetchCanister := newLikeFetchCanister;
    };

    system func preupgrade() {
        bucketsEntries := Iter.toArray(buckets.entries());
        availableBucketsEntries := Iter.toArray(availableBuckets.entries());
        unavailableBucketsEntries := Iter.toArray(unavailableBuckets.entries());
    };

    system func postupgrade() {
        bucketsEntries := [];
        availableBucketsEntries := [];
        unavailableBucketsEntries := [];
    };
}
</code></pre>
<pre><code class="language-js">### Storing Posts: bucket.mo

Bucket is a Canister for storing posts, and each Bucket can store a certain number of posts. It supports functions for storing, querying, updating posts, and notifying the Fetch Canister.

The Bucket needs to provide functions for querying the number of posts, querying a single post by post ID, querying multiple posts, and getting the latest posts.

After receiving new comments or likes, the Bucket also needs to communicate with the Comment Fetch Canister and Like Fetch Canister.

When the number of posts stored in the Bucket is approaching the threshold, Root Post will create a new Bucket.

This is the beginning of the `Bucket` module, where posts are actually stored. The `actor class` keyword indicates that this is an Actor class that can be called externally. The parameters `(rootPostCanister, _commentFetchCanister, _likeFetchCanister)` indicate that this Actor class needs to be initialized with the IDs of these three Canisters.

```js
actor class Bucket(
    rootPostCanister: Principal,
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {
    // ...
};
</code></pre>
<p>Overall, this Bucket is used to receive various operations (new comments, likes, etc.) to update posts. All data is stored in an immutable form, allowing for efficient querying and sharing.</p>
<p>First, define some types, variables, and data structures.</p>
<pre><code class="language-js">// Define several type aliases
type FeedActor = Types.FeedActor;
type PostImmutable = Types.PostImmutable;
type NewComment = Types.NewComment;
type NewLike = Types.NewLike;
type NewRepost = Types.NewRepost;
type CommentFetchActor = Types.CommentFetchActor;
type LikeFetchActor = Types.LikeFetchActor;
type RootPostActor = Types.RootPostActor;

stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // Maximum number of posts each Bucket can store
stable let FLOOR_BUCKET_MAX_POST_NUMBER: Nat = BUCKET_MAX_POST_NUMBER - 50; // A lower threshold
stable let installer = msg.caller;

// postId -&gt; PostImmutable
// The main data is stored in feedMap, which is a mapping from post ID to PostImmutable
stable var feedMapEntries: [(Text, PostImmutable)] = [];
// Stored in a TrieMap, using Text for hashing and comparison
let feedMap = TrieMap.fromEntries&lt;Text, PostImmutable&gt;(feedMapEntries.vals(), Text.equal, Text.hash);
</code></pre>
<p><code>TrieMap</code> is an efficient key-value storage structure. Using <code>TrieMap</code>, it maintains post information, providing functions for storing, batch storing, updating comments, updating likes, updating reposts, etc. The definitions of <code>feedMapEntries</code> and <code>feedMap</code> are used to store post data, one in array form and the other in TrieMap form.</p>
<br>
<p>Storing Posts:</p>
<p>The <code>storeFeed()</code> function is used to store a single post. It is <code>public shared</code>, so it can be called by external callers.</p>
<pre><code class="language-js">public shared({caller}) func storeFeed(post: PostImmutable): async Bool {
    ignore checkBucketMemory();
    _storeFeed(post);
};
</code></pre>
<p><code>batchStoreFeed()</code> is used to store multiple posts in batches, internally using a loop to call <code>_storeFeed()</code> for each post.</p>
<pre><code class="language-js">public shared({caller}) func batchStoreFeed(posts: [PostImmutable]): async () {
    for(post in posts.vals()) {
        ignore _storeFeed(post);
    };
};
</code></pre>
<p><code>updatePostRepost()</code> is used to update the repost information of a post. It calls <code>_updatePostRepost()</code> to perform the actual update and asserts to ensure the update is successful.</p>
<pre><code class="language-js">public shared({caller}) func updatePostRepost(postId: Text, newRepost: NewRepost): async Bool {
    assert(_updatePostRepost(postId, newRepost));
    true
};
</code></pre>
<p><code>_storeFeed()</code> and <code>_updatePostRepost()</code> are private functions, representing the internal logic for storing and updating.</p>
<br>
<p>Next are functionalities for updating post comments and likes:</p>
<p>The <code>updatePostComment</code> function is used to update the comment information of a post. It takes the post ID and new comment as parameters. Internally, it calls the <code>_updatePostComment</code> function to actually perform the comment update.</p>
<p>After a successful update, the updated post object is returned from <code>_updatePostComment</code>. Then, it notifies the <code>CommentFetchActor</code> to update the comment cache.</p>
<p>The <code>updatePostLike</code> function is used to update the like information of a post. It takes the post ID and new like as parameters. Internally, it calls <code>_updatePostLike</code> to perform the like update.</p>
<p>After a successful update, it similarly returns the updated post object and notifies the <code>LikeFetchActor</code> to update the like cache.</p>
<pre><code class="language-js">```js
// Update Post Comment Information
// The caller parameter indicates that only the requester with a valid identity in the request can call the function
public shared({caller}) func updatePostComment(postId: Text, newComment: NewComment): async Bool {
    switch(_updatePostComment(postId, newComment)) {
        case(null) { return false; };
        case(?_post) {
            // Notify commentFetch
            let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
            ignore commentFetchActor.receiveNotify(_post);
        };
    };
    // Return a Bool value indicating whether the update was successful
    true
};

public shared({caller}) func updatePostLike(postId: Text, newLike: NewLike): async Bool {
    switch(_updatePostLike(postId, newLike)) {
        case(null) { return false; };
        case(?_post) {
            // Notify likeFetch
            let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
            ignore likeFetchActor.receiveNotify(_post);
        };     
    };
    true
};
</code></pre>
<p>We encapsulate the functions for manipulating posts through private functions. External callers only need to call the public update functions and don't need to be concerned with the internal storage and update logic. Private functions can encapsulate state management, making the code more modular and maintainable.</p>
<br>
<p>The <code>_updatePostComment</code> function is used to update the comments of a post. It retrieves the original post from <code>feedMap</code>, updates the <code>comment</code> field with the new comment <code>newComment</code>, and puts it back into <code>feedMap</code>.</p>
<p><code>feedMap</code> is a hash table for storing posts, where the key is <code>postId</code> and the value is <code>PostImmutable</code> records.</p>
<pre><code class="language-js">private func _updatePostComment(postId: Text, newComment: NewComment): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = post.like;
                comment = newComment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost
        };
    };
};
</code></pre>
<br>
<p><code>_updatePostLike</code> similarly updates the <code>like</code> field of a post.</p>
<pre><code class="language-js">private func _updatePostLike(postId: Text, newLike: NewLike): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = newLike;
                comment = post.comment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost              
        };
    };
};
</code></pre>
<br>
<p><code>_updatePostRepost</code> updates the <code>repost</code> field of a post.</p>
<pre><code class="language-js">private func _updatePostRepost(postId: Text, newRepost: NewRepost): Bool {
    switch(feedMap.get(postId)) {
        case(null) { return false; };
        case(?post) {
            feedMap.put(postId, {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                content = post.content;
                repost = newRepost;
                like = post.like;
                comment = post.comment;
                createdAt = post.createdAt;
            });
            true
        };
    };
};
</code></pre>
<br>
<p>Using the <code>immutable</code> data structure <code>PostImmutable</code> ensures data consistency and avoids accidental modifications.</p>
<pre><code class="language-js">// Save the new post to feedMap
// Check if postId already exists, and save only if it doesn't to avoid duplication
private func _storeFeed(post: PostImmutable): Bool {
    ignore Utils.checkPostId(post.postId);
    switch(feedMap.get(post.postId)) {
        case(?_post) {
            // Debug.print(&quot;This post has been stored&quot;);
            return false;
        };
        case(null) {
            feedMap.put(post.postId, post);
            return true;
        };
    };
};
</code></pre>
<br>
<p>The <code>checkBucketMemory</code> function checks if the current Bucket is approaching its capacity limit, and if so, notifies the Root Post Actor to create a new Bucket.</p>
<pre><code class="language-js">func checkBucketMemory(): async () {
    if(feedMap.size() &gt; FLOOR_BUCKET_MAX_POST_NUMBER) {
        let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));
        ignore rootPostActor.reCreateBucket();
    }
};
</code></pre>
<br>
<pre><code class="language-js">// Update Post Comment Information
// The `caller` parameter indicates that only the requester with a valid identity in the request can call the function
public shared({caller}) func updatePostComment(postId: Text, newComment: NewComment): async Bool {
    switch(_updatePostComment(postId, newComment)) {
        case(null) { return false; };
        case(?_post) {
            // Notify Comment Fetch
            let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
            ignore commentFetchActor.receiveNotify(_post);
        };
    };
    // Return a Bool value indicating whether the update was successful
    true
};

public shared({caller}) func updatePostLike(postId: Text, newLike: NewLike): async Bool {
    switch(_updatePostLike(postId, newLike)) {
        case(null) { return false; };
        case(?_post) {
            // Notify Like Fetch
            let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
            ignore likeFetchActor.receiveNotify(_post);
        };     
    };
    true
};
</code></pre>
<p>We encapsulate the functions for manipulating posts through private functions. External callers only need to call the public update functions and don't need to be concerned with the internal storage and update logic. Private functions can encapsulate state management, making the code more modular and maintainable.</p>
<br>
<p>The <code>_updatePostComment</code> function is used to update the comments of a post. It retrieves the original post from <code>feedMap</code>, updates the <code>comment</code> field with the new comment <code>newComment</code>, and puts it back into <code>feedMap</code>.</p>
<p><code>feedMap</code> is a hash table for storing posts, where the key is <code>postId</code> and the value is <code>PostImmutable</code> records.</p>
<pre><code class="language-js">private func _updatePostComment(postId: Text, newComment: NewComment): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = post.like;
                comment = newComment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost
        };
    };
};
</code></pre>
<br>
<p><code>_updatePostLike</code> similarly updates the <code>like</code> field of a post.</p>
<pre><code class="language-js">private func _updatePostLike(postId: Text, newLike: NewLike): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = newLike;
                comment = post.comment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost              
        };
    };
};
</code></pre>
<br>
<p><code>_updatePostRepost</code> updates the <code>repost</code> field of a post.</p>
<pre><code class="language-js">private func _updatePostRepost(postId: Text, newRepost: NewRepost): Bool {
    switch(feedMap.get(postId)) {
        case(null) { return false; };
        case(?post) {
            feedMap.put(postId, {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                content = post.content;
                repost = newRepost;
                like = post.like;
                comment = post.comment;
                createdAt = post.createdAt;
            });
            true
        };
    };
};
</code></pre>
<br>
<p>Using the <code>immutable</code> data structure <code>PostImmutable</code> ensures data consistency and avoids accidental modifications.</p>
<pre><code class="language-js">// Save the new post to feedMap
// Check if postId already exists, and save only if it doesn't to avoid duplication
private func _storeFeed(post: PostImmutable): Bool {
    ignore Utils.checkPostId(post.postId);
    switch(feedMap.get(post.postId)) {
        case(?_post) {
            // Debug.print(&quot;This post has been stored&quot;);
            return false;
        };
        case(null) {
            feedMap.put(post.postId, post);
            return true;
        };
    };
};
</code></pre>
<br>
<p>The <code>checkBucketMemory</code> function checks if the current Bucket is approaching its capacity limit, and if so, notifies the Root Post Actor to create a new Bucket.</p>
<pre><code class="language-js">func checkBucketMemory(): async () {
    if(feedMap.size() &gt; FLOOR_BUCKET_MAX_POST_NUMBER) {
        let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));
        ignore rootPostActor.reCreateBucket();
    }
};
</code></pre>
<br>
<p>We need a function to query the total number of posts:</p>
<pre><code class="language-js">// Query how many posts there are in total
public query func getPostNumber(): async Nat {
    feedMap.size()
};
</code></pre>
<br>
<p>There is also a function to get the specific content of posts, implementing the ability to quickly retrieve several posts at once.</p>
<p>This functionality is used in the Feed Canister to fetch posts:</p>
<p>When several people that a user follows post new content, the IDs of these posts are sent to Fetch. Eventually, these IDs are sent to another Feed. At this point, Feed receives many post IDs at once and needs to send these IDs to the Bucket to get the content of these posts all at once.</p>
<pre><code class="language-js">// Query several posts by ID (can pass in 7 IDs to return the content of 7 posts at once)
public query func getPosts(postIdArray: [Text]): async [PostImmutable] { // Receives a Text array postIdArray as a parameter
    // Create a Buffer to store the query results, with a size equal to the size of postIdArray
    let result = Buffer.Buffer&lt;PostImmutable&gt;(postIdArray.size());
    // Iterate over each ID in postIdArray
    for(postId in postIdArray.vals()) {
        // For each ID, look it up in feedMap and add it to the result Buffer if found
        switch(feedMap.get(postId)) {
            case(null) {};
            case(?post) { result.add(post); };
        };
    };
    // After the iteration, convert the Buffer to an array using toArray() and return
    Buffer.toArray&lt;PostImmutable&gt;(result)
};
</code></pre>
<p>We use Buffer to avoid the overhead of concatenating arrays multiple times. The query function can be called externally, encapsulating the data query. It returns an array type, making it convenient for the caller to handle the query results.</p>
<p>This allows for batch querying of the content of multiple posts.</p>
<br>
<p>After batch precision querying posts by ID, two more functions related to querying are needed: a function to individually query a post by ID and a function to query the latest n posts.</p>
<pre><code class="language-js">public query func getPost(postId: Text): async ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) { return ?post; }; 
    };
};

// Query the latest n posts
public query func getLatestFeed(n: Nat): async [PostImmutable] {
    let feedArray = Iter.toArray(
        Iter.sort&lt;PostImmutable&gt;(
        feedMap.vals(),
        func (x: PostImmutable, y: PostImmutable): Order.Order {
            if(x.createdAt &gt; y.createdAt) return #less
            else if(x.createdAt &lt; y.createdAt) return #greater
            else return #equal
    }));
    if(n &lt;= feedArray.size()) {
        Array.subArray(feedArray, 0, n)
    } else {
        Array.subArray(feedArray, 0, feedArray.size())
    }
};
</code></pre>
<p>Finally, there are two system functions related to upgrades, managed by the <code>preupgrade</code> and <code>postupgrade</code> functions, to handle the state of the Bucket.</p>
<br>
<p>The complete file for <code>bucket.mo</code> is as follows: </p>
<pre><code class="language-js">import Types &quot;./types&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Array &quot;mo:base/Array&quot;;
import Order &quot;mo:base/Order&quot;;
import Text &quot;mo:base/Text&quot;;
import Hash &quot;mo:base/Hash&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;
import Option &quot;mo:base/Option&quot;;
import Buffer &quot;mo:base/Buffer&quot;;
import Utils &quot;../utils&quot;;

shared(msg) actor class Bucket(
    rootPostCanister: Principal,
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {
    
    type FeedActor = Types.FeedActor;
    type PostImmutable = Types.PostImmutable;
    type NewComment = Types.NewComment;
    type NewLike = Types.NewLike;
    type NewRepost = Types.NewRepost;
    type CommentFetchActor = Types.CommentFetchActor;
    type LikeFetchActor = Types.LikeFetchActor;
    type RootPostActor = Types.RootPostActor;

    stable let BUCKET_MAX_POST_NUMBER: Nat = 5000;
    stable let FLOOR_BUCKET_MAX_POST_NUMBER: Nat = BUCKET_MAX_POST_NUMBER - 50;

    stable let installer = msg.caller;

    // postId -&gt; PostImmutable
    stable var feedMapEntries: [(Text, PostImmutable)] = [];
    let feedMap = TrieMap.fromEntries&lt;Text, PostImmutable&gt;(feedMapEntries.vals(), Text.equal, Text.hash);

    // Store post
    public shared({caller}) func storeFeed(post: PostImmutable): async Bool {
        ignore checkBucketMemory();
        _storeFeed(post);
    };

    public shared({caller}) func batchStoreFeed(posts: [PostImmutable]): async () {
        for(post in posts.vals()) {
            ignore _storeFeed(post);
        };
    };

    public shared({caller}) func updatePostRepost(postId: Text, newRepost: NewRepost): async Bool {
        assert(_updatePostRepost(postId, newRepost));
        true
    };

    // Update post comment information
    public shared({caller}) func updatePostComment(postId: Text, newComment: NewComment): async Bool {
        switch(_updatePostComment(postId, newComment)) {
            case(null) { return false; };
            case(?_post) {
                // Notification commentFetch
                let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
                ignore commentFetchActor.receiveNotify(_post);
            };
        };
        true
    };

    public shared({caller}) func updatePostLike(postId: Text, newLike: NewLike): async Bool {
        switch(_updatePostLike(postId, newLike)) {
            case(null) { return false; };
            case(?_post) {
                // Notification likeFetch
                let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
                ignore likeFetchActor.receiveNotify(_post);
            };     
        };
        true
    };

    func checkBucketMemory(): async () {
        if(feedMap.size() &gt; FLOOR_BUCKET_MAX_POST_NUMBER) {
            let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));
            ignore rootPostActor.reCreateBucket();
        }
    };

    private func _updatePostComment(postId: Text, newComment: NewComment): ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) {
                let _newPost = {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    repost = post.repost;
                    content = post.content;
                    like = post.like;
                    comment = newComment;
                    createdAt = post.createdAt;
                };
                feedMap.put(postId, _newPost);
                ?_newPost
            };
        };
    };

    private func _updatePostLike(postId: Text, newLike: NewLike): ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) {
                let _newPost = {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    repost = post.repost;
                    content = post.content;
                    like = newLike;
                    comment = post.comment;
                    createdAt = post.createdAt;
                };
                feedMap.put(postId, _newPost);
                ?_newPost              
            };
        };
    };

    private func _updatePostRepost(postId: Text, newRepost: NewRepost): Bool {
        switch(feedMap.get(postId)) {
            case(null) { return false; };
            case(?post) {
                feedMap.put(postId, {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    content = post.content;
                    repost = newRepost;
                    like = post.like;
                    comment = post.comment;
                    createdAt = post.createdAt;
                });
                true              
            };
        };
    };

    private func _storeFeed(post: PostImmutable): Bool {
        ignore Utils.checkPostId(post.postId);
        switch(feedMap.get(post.postId)) {
            case(?_post) {
                // Debug.print(&quot;This post has been stored&quot;);
                return false;
            };
            case(null) {
                feedMap.put(post.postId, post);
                return true;
            };
        };
    };

// ==================== Query ====================

    public query func getPostNumber(): async Nat {
        feedMap.size()
    };

    public query func getPosts(postIdArray: [Text]): async [PostImmutable] {
       let result = Buffer.Buffer&lt;PostImmutable&gt;(postIdArray.size());
       for(postId in postIdArray.vals()) {
        switch(feedMap.get(postId)) {
            case(null) {};
            case(?post) { result.add(post); };
        };
       };
       Buffer.toArray&lt;PostImmutable&gt;(result)
    };

    public query func getPost(postId: Text): async ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) { return ?post; }; 
        };
    };

    public query func getLatestFeed(n: Nat): async [PostImmutable] {
        let feedArray = Iter.toArray(
            Iter.sort&lt;PostImmutable&gt;(
            feedMap.vals(),
            func (x: PostImmutable, y: PostImmutable): Order.Order {
                if(x.createdAt &gt; y.createdAt) return #less
                else if(x.createdAt &lt; y.createdAt) return #greater
                else return #equal
        }));
        if(n &lt;= feedArray.size()) {
            Array.subArray(feedArray, 0, n)
        } else {
            Array.subArray(feedArray, 0, feedArray.size())
        }
    };

// ==================== CommentFetchCanister ====================

    stable var commentFetchCanister = _commentFetchCanister;
    
    public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

    public shared({caller}) func updateCommentFetchCanister(
        newCommentFetchCanister: Principal
    ): async () {
        commentFetchCanister := commentFetchCanister;
    };


// ==================== LikeFetchCanister ====================

    stable var likeFetchCanister = _likeFetchCanister;
    
    public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

    public shared({caller}) func updateLikeFetchCanister(
        newLikeFetchCanister: Principal
    ): async () {
        likeFetchCanister := newLikeFetchCanister;
    };

    system func preupgrade() {
        feedMapEntries := Iter.toArray(feedMap.entries());
    };

    system func postupgrade() {
        feedMapEntries := [];
    };
}
</code></pre>
<p>The next module is <a href="9.DevelopingDApp/./6.FeedModule.html">the Feed module</a>. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="feed-2"><a class="header" href="#feed-2">Feed</a></h2>
<p>In the Feed module, we have the following files:</p>
<p><strong>types.mo File</strong></p>
<p>Defines primary data type aliases used throughout the system. It imports a module named <code>Types</code> and re-exports the types defined in that module, such as Post, Comment, Like, etc.</p>
<p><strong>rootFeed.mo File</strong></p>
<p>Responsible for aggregating and creating users' feeds.</p>
<ul>
<li>The <code>createFeedCanister</code> function allows users to create their own feed canister, which is the place where users store posts and feeds on the platform.</li>
<li>The <code>updateFetchUserToFeed</code> function is responsible for updating other system components, such as post, comment, and like fetching services when a user creates a new feed canister.</li>
<li>The <code>getUserFeedCanister</code> and <code>getAllUserFeedCanister</code> functions provide ways to retrieve user feed canisters.</li>
</ul>
<p><strong>database.mo File</strong></p>
<p>Implements a post directory (<code>PostDirectory</code>) and a feed directory (<code>FeedDirectory</code>) used for storing and managing posts and related actions (such as comments, likes, and reposts) in the database.</p>
<ul>
<li>The <code>PostDirectory</code> class has a <code>postMap</code>, which is a key-value collection implemented using <code>TrieMap</code> to store posts and their indices.</li>
<li>The <code>createPost</code> function implements the posting feature. It creates a new post and adds it to the <code>postMap</code> while incrementing the post index.</li>
<li>The <code>getPost</code> function allows retrieving posts by post ID.</li>
<li>The <code>createComment</code>, <code>createLike</code>, and <code>createRepost</code> functions are used for creating comments, likes, and reposts, respectively.</li>
<li>The <code>getAllPost</code> function retrieves all posts and sorts them by creation time.</li>
</ul>
<p>The <code>FeedDirectory</code> class is responsible for managing users' feeds. It uses <code>TrieMap</code> to store and retrieve posts in the user's feed.</p>
<p><strong>feed.mo File</strong></p>
<p>Feed represents the user feed in a social media platform. It manages posts and feeds using the <code>PostDirectory</code> and <code>FeedDirectory</code> defined in the previous database files.</p>
<ul>
<li>The <code>Feed</code> class has several functions, such as <code>createPost</code>, <code>createRepost</code>, <code>createComment</code>, and <code>createLike</code>, which implement basic user interactions on social media.</li>
<li>Functions like <code>receiveFeed</code>, <code>batchReceiveFeed</code>, <code>receiveComment</code>, <code>batchReceiveComment</code>, <code>receiveLike</code>, and <code>batchReceiveLike</code> are used to receive posts, comments, and likes from other users and add these activities to the current user's feed.</li>
<li>The <code>getLatestFeed</code> function allows users to retrieve the latest posts in their feed.</li>
</ul>
<br>
<h3 id="creating-feed-canister-rootfeedmo"><a class="header" href="#creating-feed-canister-rootfeedmo">Creating Feed Canister: rootFeed.mo</a></h3>
<p>Managing user feed canisters:</p>
<ul>
<li>Defines a TrieMap (<code>userFeedCanisterMap</code>) that stores the mapping between users and their corresponding feed canisters.</li>
<li>Provides a method (<code>createFeedCanister()</code>) for users to create their personal feed canisters.</li>
<li>Provides methods (<code>getUserFeedCanister()</code>, <code>getAllUserFeedCanister()</code>) for retrieving user feed canisters.</li>
<li>Provides a method (<code>getTotalUserFeedCanisterNumber()</code>) for getting the total number of created feed canisters.</li>
</ul>
<p>Managing other canisters in the feed system:</p>
<ul>
<li>Stores and provides interfaces for querying/updating the Fetch Canisters of Post, Comment, and Like.</li>
<li>Synchronously updates the mapping in these Fetch Canisters when a user creates a new feed canister.</li>
</ul>
<br>
<p>First, defining some basic types and data structures needed for the Feed system, including an Actor for fetching feed data and a TrieMap for storing mappings.</p>
<pre><code class="language-js">// Custom Actor types for fetching different parts of the Feed
type RootFetchActor = Types.RootFetchActor;
type PostFetchActor = Types.PostFetchActor;
type CommentFetchActor = Types.CommentFetchActor;
type LikeFetchActor = Types.LikeFetchActor;

stable let T_CYCLES = 1_000_000_000_000; // 1 trillion cycles for later operations

// An array storing key-value pairs, where keys are user Principals and values are corresponding feed canister Principals
stable var userFeedCanisterMapEntries: [(Principal, Principal)] = [];
// A TrieMap from user Principals to feed canister Principals, constructed using fromEntries with userFeedCanisterMapEntries
let userFeedCanisterMap = TrieMap.fromEntries&lt;Principal, Principal&gt;(userFeedCanisterMapEntries.vals(), Principal.equal, Principal.hash);
let ic: IC.Service = actor(&quot;aaaaa-aa&quot;);
</code></pre>
<p><code>TrieMap</code> is a key-value storage structure that efficiently inserts and looks up data.</p>
<pre><code class="language-js">let postMap = TrieMap.fromEntries&lt;Nat, Post&gt;(postMapEntries.vals(), Nat.equal, Hash.hash);
</code></pre>
<p>Here, a <code>TrieMap</code> is created to store post data, where <code>Nat</code> is the key type, and <code>Post</code> is the value type.</p>
<br>
<p>Logic for creating a user's own feed canister: Create a feed canister for the user, perform identity verification, authorization settings, data mapping synchronization, etc.</p>
<pre><code class="language-js">// Create a feed canister for the user
public shared({caller}) func createFeedCanister(): async ?Principal {
    // Check the caller's identity
    assert(_getUserFeedCanister(caller) == null);
    // Allocate 2 trillion cycles for each new canister
    Cycles.add(2 * T_CYCLES);
    // Call the `Feed.Feed` method to create the user's feed canister
    let feedCanister = await Feed.Feed(
        caller, rootPostCanister, userCanister, 
        postFetchCanister,
        commentFetchCanister,
        likeFetchCanister
    );
    // Get the ID of the canister and store it in the mapping TrieMap
    let feedCanisterId = Principal.fromActor(feedCanister);
    userFeedCanisterMap.put(caller, feedCanisterId);
    // Call the ic method to update the settings of the canister, authorizing the Root Canister and the user as controllers
    await ic.update_settings({
        canister_id = feedCanisterId;
        settings = {
            freezing_threshold = null;
            controllers = ?[Principal.fromActor(this), feedCanisterId];
            memory_allocation = null;
            compute_allocation = null;
        }
    });
    
    // Update the information in fetch; also update the mapping in Post/Comment/Like Fetch Canisters for this user
    ignore updateFetchUserToFeed((caller, feedCanisterId));
    
    // Return the ID of the newly created feed canister
    ?feedCanisterId
};
</code></pre>
<br>
<p>When a user's feed canister is created, synchronize it with other canisters that depend on this mapping to ensure data consistency in the Feed system.</p>
<p>This is done in three steps:</p>
<ol>
<li>Retrieve the IDs of all Post, Comment, and Like Fetch Canisters from the Root Fetch Canister.</li>
<li>Iterate over each Fetch Canister, create an actor reference.</li>
<li>Call the <code>addUserToFeedEntry</code> method of each Fetch Canister, providing the mapping between the user and their corresponding feed canister.</li>
</ol>
<pre><code class="language-js">func updateFetchUserToFeed(entry: (Principal, Principal)): async () {
    let rootFetchActor: RootFetchActor = actor(Principal.toText(rootFetchCanister));

    // Update information in postFetch
    let postFetchCanisterArray = await rootFetchActor.getAllPostFetchCanister();
    for(_canister in postFetchCanisterArray.vals()) {
        let postFetchActor: PostFetchActor = actor(Principal.toText(_canister));
        ignore postFetchActor.addUserToFeedEntry(entry);
    };

    // Update commentFetch
    let commentFetchCanisterArray = await rootFetchActor.getAllCommentFetchCanister();
    for(_canister in commentFetchCanisterArray.vals()) {
        let commentFetchActor: CommentFetchActor = actor(Principal.toText(_canister));
        ignore commentFetchActor.addUserToFeedEntry(entry);
    };
    
    // Update likeFetch
    let likeFetchCanisterArray = await rootFetchActor.getAllLikeFetchCanister();
    for(_canister in likeFetchCanisterArray.vals()) {
        let likeFetchActor: LikeFetchActor = actor(Principal.toText(_canister));
        ignore likeFetchActor.addUserToFeedEntry(entry);
    };
};
</code></pre>
<br>
<p>These several functions are used to query the mapping relationships of user Feed Canisters:</p>
<p>Different interfaces for user queries, getting all mappings, getting totals, etc., can be used to query the mapping relationships of user Feed Canisters for reading the current internal state of the Feed system.</p>
<pre><code class="language-js">// Receives a user Principal as a parameter
public query func getUserFeedCanister(user: Principal): async ?Principal {
    // Calls a private function, returns the Feed Canister Principal corresponding to the user
    _getUserFeedCanister(user)
};

// return [(user, feedCanister)]
public query func getAllUserFeedCanister(): async [(Principal, Principal)] {
    // Converts the internal userFeedCanisterMap to an array
    // Returns an array of all user-to-Feed Canister mapping relationships
    Iter.toArray(userFeedCanisterMap.entries())
};

// Total number of Canisters created
public query func getTotalUserFeedCanisterNumber(): async Nat {
    // Returns the size of userFeedCanisterMap, i.e., the total number of Feed Canisters
    userFeedCanisterMap.size()
};

// Internal private method, queries the user's Feed
private func _getUserFeedCanister(user: Principal): ?Principal {
    // Queries userFeedCanisterMap
    switch(userFeedCanisterMap.get(user)) {
        case(null) { return null;};
        // Returns the corresponding Feed Canister Id based on the given user Principal
        case(?canister) { return ?canister;};
    };
};
</code></pre>
<br>
<p>When creating a Bucket, we also need to specify the Canister IDs for Post Fetch, Comment Fetch, and Like Fetch in the Bucket system. Therefore, in the Root Post, we also need to record and save Post Fetch, Comment Fetch, and Like Fetch:</p>
<pre><code class="language-js">stable var postFetchCanister = _postFetchCanister;

public query func getPostFetchCanister(): async Principal { postFetchCanister };

public shared({caller}) func updatePostFetchCanister(
    newPostFetchCanister: Principal
): async () {
    postFetchCanister := newPostFetchCanister;
};

// CommentFetchCanister

stable var commentFetchCanister = _commentFetchCanister;
    
public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

public shared({caller}) func updateCommentFetchCanister(
    newCommentFetchCanister: Principal
): async () {
    commentFetchCanister := commentFetchCanister;
};

// LikeFetchCanister

stable var likeFetchCanister = _likeFetchCanister;
    
public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

public shared({caller}) func updateLikeFetchCanister(
    newLikeFetchCanister: Principal
): async () {
    likeFetchCanister := newLikeFetchCanister;
};

system func preupgrade() {
    userFeedCanisterMapEntries := Iter.toArray(userFeedCanisterMap.entries());
};

system func postupgrade() {
    userFeedCanisterMapEntries := [];
};
</code></pre>
<p>Finally, there are two system functions <code>preupgrade()</code> and <code>postupgrade()</code>, used to save data before and after Canister upgrades.</p>
<br>
<h3 id="storing-data-databasemo"><a class="header" href="#storing-data-databasemo">Storing Data: database.mo</a></h3>
<p>The database.mo file is responsible for storing data inside the user's Feed Canister.</p>
<p>First, define the storage structure for post indexes and mapping relationships, as well as related query interfaces.</p>
<p>postIndex is used to generate a unique ID for posts; postMap stores post data. getPostIndexEntries and getPostMapEntries are used to query the index range and mapping relationships of posts.</p>
<pre><code class="language-js">// Define some type aliases related to posts
type Post = Types.Post;
type PostImmutable = Types.PostImmutable;
type Comment = Types.Comment;
type NewComment = Types.NewComment;
type UserId = Types.UserId;
type Time = Types.Time;
type Like = Types.Like;
type NewLike = Types.NewLike;
type Repost = Types.Repost;
type NewRepost = Types.NewRepost;

// An incrementing post index value
var postIndex: Nat = postIndexEntries;
// A mapping table from post index to post, implemented using TrieMap
let postMap = TrieMap.fromEntries&lt;Nat, Post&gt;(postMapEntries.vals(), Nat.equal, Hash.hash); // postIndex -&gt; Post

// Returns the current maximum post index value
public func getPostIndexEntries(): Nat { postIndex };

// Returns an array of all mapping relationships in postMap
public func getPostMapEntries(): [(Nat, Post)] { Iter.toArray(postMap.entries()) };

// Generates a unique ID for posts, in the format: bucket#user#index
private func _getPostId(bucket: Principal, user: Principal, index: Nat): Text {
    Principal.toText(bucket) # &quot;#&quot; # Principal.toText(user) # &quot;#&quot; # Nat.toText(index)
};
</code></pre>
<br>
<h4 id="posting"><a class="header" href="#posting">Posting</a></h4>
<p>The logic of posting in the Feed Canister:</p>
<p>Implement the construction of post information and store it in the post mapping table.</p>
<p>Also returns an immutable post object to prevent posts from being modified.</p>
<p>The incrementing postIndex ensures that each post has a globally unique ID.</p>
<p>Post data is stored in TrieMap for efficient querying.</p>
<pre><code class="language-js">// Posting
public func createPost(user: UserId, feedCanister: Principal, content: Text, time: Time, bucket: Principal): PostImmutable {
    let post: Post = {
        // Generate a unique ID for the post
        postId = _getPostId(bucket, user, postIndex);
        // Construct a Post record, including post content, user information, time, etc.
        feedCanister = feedCanister;
        index = postIndex;
        user = user;
        content = content;
        var repost = [];
        var like = [];
        var comment = [];
        createdAt = time;
    };
    
    // Put this Post record into postMap
    postMap.put(postIndex, post);
    // Increment postIndex
    postIndex += 1;

    // Return PostImmutable
    Utils._convertPostToImmutable(post)
};
</code></pre>
<br>
<p>Provides basic interfaces for external post queries.</p>
<p>Implements functionality to get the total number of posts and retrieve individual posts based on ID.</p>
<pre><code class="language-js">// Get the total number of posts
public func getPostNumber(): Nat {
    // Directly call postMap's size()
    postMap.size()
};

// Get a single post based on ID
public func getPost(postId: Text): ?PostImmutable {
    // Receive the post ID as a parameter, first call checkPostId() to validate the ID format
    let (bucket, user, index) = utils.checkPostId(postId);
    // Retrieve the post record post from postMap based on the index
    switch(postMap.get(index)) {
        // If it doesn't exist, return null
        case(null) { return null; };
        // If it exists, return the post
        case(?post) {
            return ?{
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = post.like;
                comment = post.comment;
                createdAt = post.createdAt;
            }
        };
    };
};
</code></pre>
<br>
<h4 id="commenting"><a class="header" href="#commenting">Commenting</a></h4>
<p>Returns a tuple containing the Bucket and the updated array of post comments.</p>
<p>Therefore, this function checks if the post exists, adds a new comment if it does, and returns a tuple containing the bucket where the post is located and the updated post information.</p>
<p>The main logic is to check parameters, retrieve the original post information, update the post comments, and return the updated post comments.</p>
<pre><code class="language-js">// Commenting
public func createComment(commentUser: UserId, postId: Text, content: Text, createdAt: Time): ?(Principal, NewComment) {
    // Check if the post ID is valid and return the bucket, user, and index in the array where the post is located
    let (bucket, user, index) = utils.checkPostId(postId);
    // Get the post post to be commented on, return null if it does not exist
    switch(postMap.get(index)) {
        case(null) { return null;};
        case(?post) {
            // If the post exists, add the new comment to the post's comment array
            // The comment content includes user ID, comment content, and time
            post.comment := Array.append(post.comment, [{
            user = commentUser; // User ID of the commenter
            content = content; // Comment content
            createdAt = createdAt; // Comment time
        }]);
            ?(bucket, post.comment)
        };
    };
};
</code></pre>
<br>
<h4 id="liking"><a class="header" href="#liking">Liking</a></h4>
<p>Actually, it's similar to the comment function mentioned earlier. It also uses <code>postMap.get(index)</code>.</p>
<pre><code class="language-js">// Liking
public func createLike(likeUser: UserId, postId: Text, createdAt: Time): ?(Principal, NewLike) {
    let (bucket, user, index) = utils.checkPostId(postId);
    switch(postMap.get(index)) {
        case(null) { return null; };
        case(?post) {
            for(like in post.like.vals()) {
                // Already liked
                if(like.user == likeUser) { return null;};
        };
        post.like := Array.append&lt;Like&gt;(post.like, [{
            user = likeUser;
            createdAt = createdAt;
        }]);
            ?(bucket, post.like)
        };
    }
};
</code></pre>
<br>
<h4 id="reposting"><a class="header" href="#reposting">Reposting</a></h4>
<p>Similar to the above.</p>
<pre><code class="language-js">// Reposting
public func createRepost(repostUser: UserId, postId: Text, createdAt: Time): ?(Principal, NewRepost) {
    let (bucket, user, index) = utils.checkPostId(postId);
    switch(postMap.get(index)) {
        case(null) { return null; };
        case(?post) {
            for(repost in post.repost.vals()) {
                // Already reposted
                if(repost.user == repostUser) { return null;};
            };
        post.repost := Array.append&lt;Repost&gt;(post.repost, [{
            user = repostUser;
            createdAt = createdAt;
        }]);
            ?(bucket, post.repost)
        };
    }
};
</code></pre>
<br>
<h4 id="querying-all-posts"><a class="header" href="#querying-all-posts">Querying All Posts</a></h4>
<p>The function <code>getAllPost</code> retrieves all posts (<code>Post</code>) from a mapping (<code>postMap</code>), converts them into an immutable form (<code>PostImmutable</code>), and sorts them by creation time. Finally, it returns the sorted array of posts.</p>
<ul>
<li>
<p><strong><code>TrieMap.map</code>:</strong></p>
<p>Uses <code>TrieMap.map</code> to map each key-value pair in <code>postMap</code>, converting it to an immutable type <code>PostImmutable</code>. This mapping is done using the <code>Nat</code> type for keys, handling key equality and hashing with <code>Nat.equal</code> and <code>Hash.hash</code>.</p>
<pre><code class="language-motoko">TrieMap.map&lt;Nat, Post, PostImmutable&gt;(
    postMap, Nat.equal, Hash.hash,
    func (k: Nat, v1: Post): PostImmutable {
        Utils._convertPostToImmutable(v1)
    }
)
</code></pre>
</li>
<li>
<p><strong><code>.vals()</code>:</strong></p>
<p>Retrieves all values of the mapping, returning an array containing all converted <code>PostImmutable</code> values.</p>
<pre><code class="language-motoko">TrieMap.map&lt;Nat, Post, PostImmutable&gt;(...).vals()
</code></pre>
</li>
<li>
<p><strong><code>Iter.sort</code>:</strong></p>
<p>Sorts the array of values by comparing posts based on their creation time (<code>createdAt</code>). Uses <code>Order.Order</code> to specify the sorting order, where <code>#less</code> indicates ascending, <code>#greater</code> indicates descending, and <code>#equal</code> indicates equality.</p>
<pre><code class="language-motoko">Iter.sort&lt;PostImmutable&gt;(
    TrieMap.map&lt;Nat, Post, PostImmutable&gt;(...).vals(),
    func (x: PostImmutable, y: PostImmutable): Order.Order {
        if(x.createdAt &gt; y.createdAt) return #less
        else if(x.createdAt &lt; y.createdAt) return #greater
        else return #equal
    }
)
</code></pre>
</li>
<li>
<p><strong><code>Iter.toArray</code>:</strong></p>
<p>Converts the sorted array of posts into a Motoko array, ultimately serving as the return value of the function.</p>
<pre><code class="language-motoko">Iter.toArray(...)
</code></pre>
</li>
</ul>
<p>The purpose of the entire function is to retrieve all posts from the mapping, convert them into an immutable form, and sort them by creation time before returning the sorted array of posts.</p>
<pre><code class="language-js">public func getAllPost(): [PostImmutable] {
    Iter.toArray(
        Iter.sort&lt;PostImmutable&gt;(
            TrieMap.map&lt;Nat, Post, PostImmutable&gt;(
                postMap, Nat.equal, Hash.hash,
                func (k: Nat, v1: Post): PostImmutable {
                Utils._convertPostToImmutable(v1)
            }
        ).vals(),
        func (x: PostImmutable, y: PostImmutable): Order.Order {
              if(x.createdAt &gt; y.createdAt) return #less
              else if(x.createdAt &lt; y.createdAt) return #greater
              else return #equal
        }))
    };

};
</code></pre>
<br>
<h4 id="feeddirectory-class"><a class="header" href="#feeddirectory-class">FeedDirectory Class</a></h4>
<p>Without further ado, let's dive into the code:</p>
<pre><code class="language-js">public class FeedDirectory(
    feedMapEntries: [(Text, PostImmutable)]
) {
    
    type PostImmutable = Types.PostImmutable;

    // Using the TrieMap type to create a mapping, where the key is of type Text and the value is of type PostImmutable
    // Used for storing post data
    let feedMap = TrieMap.fromEntries&lt;Text, PostImmutable&gt;(feedMapEntries.vals(), Text.equal, Text.hash);

    // Returns an array containing all mapping entries
    public func getFeedMapEntries(): [(Text, PostImmutable)] { Iter.toArray(feedMap.entries()) };

    // Adds a post to the mapping, with the key being the postId of the post
    public func storeFeed(post: PostImmutable) {
        feedMap.put(post.postId, post);
    };

    // Bulk adds all posts in the post array to the mapping
    public func batchStoreFeed(postArray: [PostImmutable]) {
        for(_post in postArray.vals()) {
            feedMap.put(_post.postId, _post);
        };
    };

    // Returns the number of posts stored in the mapping
    public func getFeedNumber(): Nat {
        feedMap.size()
    };

    // Returns the post corresponding to the given postId
    // Returns null if the post does not exist
    public func getFeed(postId: Text): ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?_feed) { return ?_feed; };
        };
    };

    // Returns the latest n posts, sorted by creation time
    public func getLatestFeed(n: Nat): [PostImmutable] {
        let feedArray = Iter.toArray(
            Iter.sort&lt;PostImmutable&gt;(
            feedMap.vals(),
            func (x: PostImmutable, y: PostImmutable): Order.Order {
                if(x.createdAt &gt; y.createdAt) return #less
                else if(x.createdAt &lt; y.createdAt) return #greater
                else return #equal
        }));
        // If the requested quantity exceeds the actual number of posts, return all posts
        if(n &lt;= feedArray.size()) {
            Array.subArray(feedArray, 0, n)
        } else {
            Array.subArray(feedArray, 0, feedArray.size())
        }
    };

};
</code></pre>
<br>
<p>database.mo complete file:</p>
<pre><code class="language-js">import Array &quot;mo:base/Array&quot;;
import HashMap &quot;mo:base/HashMap&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Option &quot;mo:base/Option&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Types &quot;./types&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import TrieSet &quot;mo:base/TrieSet&quot;;
import Hash &quot;mo:base/Hash&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Time &quot;mo:base/Time&quot;;
import utils &quot;../utils&quot;;
import Text &quot;mo:base/Text&quot;;
import Order &quot;mo:base/Order&quot;;
import Utils &quot;../utils&quot;;

module {
  type Post = Types.Post;
  public class PostDirectory(
    postIndexEntries: Nat,
    postMapEntries: [(Nat, Post)]
  ) {

    type Post = Types.Post;
    type PostImmutable = Types.PostImmutable;
    type Comment = Types.Comment;
    type NewComment = Types.NewComment;
    type UserId = Types.UserId;
    type Time = Types.Time;
    type Like = Types.Like;
    type NewLike = Types.NewLike;
    type Repost = Types.Repost;
    type NewRepost = Types.NewRepost;

    var postIndex: Nat = postIndexEntries;
    let postMap = TrieMap.fromEntries&lt;Nat, Post&gt;(postMapEntries.vals(), Nat.equal, Hash.hash); // postIndex -&gt; Post

    public func getPostIndexEntries(): Nat { postIndex };

    public func getPostMapEntries(): [(Nat, Post)] { Iter.toArray(postMap.entries()) };

    private func _getPostId(bucket: Principal, user: Principal, index: Nat): Text {
      Principal.toText(bucket) # &quot;#&quot; # Principal.toText(user) # &quot;#&quot; # Nat.toText(index)
    };

    public func createPost(user: UserId, feedCanister: Principal, content: Text, time: Time, bucket: Principal): PostImmutable {
      let post: Post = {
        postId = _getPostId(bucket, user, postIndex);
        feedCanister = feedCanister;
        index = postIndex;
        user = user;
        content = content;
        var repost = [];
        var like = [];
        var comment = [];
        createdAt = time;
      };

      postMap.put(postIndex, post);
      postIndex += 1;

      Utils._convertPostToImmutable(post)
    };

    public func getPostNumber(): Nat {
      postMap.size()
    };

    public func getPost(postId: Text): ?PostImmutable {
      let (bucket, user, index) = utils.checkPostId(postId);
      switch(postMap.get(index)) {
        case(null) { return null; };
        case(?post) {
          return ?{
            postId = post.postId;
            feedCanister = post.feedCanister;
            index = post.index;
            user = post.user;
            repost = post.repost;
            content = post.content;
            like = post.like;
            comment = post.comment;
            createdAt = post.createdAt;
          }
        };
      };
    };


    public func createComment(commentUser: UserId, postId: Text, content: Text, createdAt: Time): ?(Principal, NewComment) {
      let (bucket, user, index) = utils.checkPostId(postId);
      switch(postMap.get(index)) {
        case(null) { return null;};
        case(?post) {
          post.comment := Array.append(post.comment, [{
            user = commentUser;
            content = content;
            createdAt = createdAt;
          }]);
          ?(bucket, post.comment)
        };
      };
    };


    public func createLike(likeUser: UserId, postId: Text, createdAt: Time): ?(Principal, NewLike) {
      let (bucket, user, index) = utils.checkPostId(postId);
      switch(postMap.get(index)) {
        case(null) { return null; };
        case(?post) {
          for(like in post.like.vals()) {
            if(like.user == likeUser) { return null;};
          };
          post.like := Array.append&lt;Like&gt;(post.like, [{
            user = likeUser;
            createdAt = createdAt;
          }]);
          ?(bucket, post.like)
        };
      }
    };


    public func createRepost(repostUser: UserId, postId: Text, createdAt: Time): ?(Principal, NewRepost) {
      let (bucket, user, index) = utils.checkPostId(postId);
      switch(postMap.get(index)) {
        case(null) { return null; };
        case(?post) {
          for(repost in post.repost.vals()) {
            if(repost.user == repostUser) { return null;};
          };
          post.repost := Array.append&lt;Repost&gt;(post.repost, [{
            user = repostUser;
            createdAt = createdAt;
          }]);
          ?(bucket, post.repost)
        };
      }
    };

    public func getAllPost(): [PostImmutable] {
      Iter.toArray(
        Iter.sort&lt;PostImmutable&gt;(
          TrieMap.map&lt;Nat, Post, PostImmutable&gt;(
            postMap, Nat.equal, Hash.hash,
            func (k: Nat, v1: Post): PostImmutable {
              Utils._convertPostToImmutable(v1)
            }
          ).vals(),
          func (x: PostImmutable, y: PostImmutable): Order.Order {
              if(x.createdAt &gt; y.createdAt) return #less
              else if(x.createdAt &lt; y.createdAt) return #greater
              else return #equal
          }))
    };

  };
  
  type PostImmutable = Types.PostImmutable;

  public class FeedDirectory(
    feedMapEntries: [(Text, PostImmutable)]
  ) {
    
    type PostImmutable = Types.PostImmutable;

    let feedMap = TrieMap.fromEntries&lt;Text, PostImmutable&gt;(feedMapEntries.vals(), Text.equal, Text.hash);

    public func getFeedMapEntries(): [(Text, PostImmutable)] { Iter.toArray(feedMap.entries()) };

    public func storeFeed(post: PostImmutable) {
      feedMap.put(post.postId, post);
    };

    public func batchStoreFeed(postArray: [PostImmutable]) {
      for(_post in postArray.vals()) {
        feedMap.put(_post.postId, _post);
      };
    };

    public func getFeedNumber(): Nat {
      feedMap.size()
    };

    public func getFeed(postId: Text): ?PostImmutable {
      switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?_feed) { return ?_feed; };
      };
    };

    public func getLatestFeed(n: Nat): [PostImmutable] {
      let feedArray = Iter.toArray(
        Iter.sort&lt;PostImmutable&gt;(
        feedMap.vals(),
        func (x: PostImmutable, y: PostImmutable): Order.Order {
            if(x.createdAt &gt; y.createdAt) return #less
            else if(x.createdAt &lt; y.createdAt) return #greater
            else return #equal
      }));
      if(n &lt;= feedArray.size()) {
        Array.subArray(feedArray, 0, n)
      } else {
        Array.subArray(feedArray, 0, feedArray.size())
      }
    };

  };
};

</code></pre>
<br>
<h3 id="user-cloud-services-feedmo"><a class="header" href="#user-cloud-services-feedmo">User Cloud Services: feed.mo</a></h3>
<br>
<h4 id="owner"><a class="header" href="#owner">Owner</a></h4>
<p>In the Feed Canister, it is necessary to store information about who the owner is and allow the owner to transfer their control later.</p>
<pre><code class="language-js">stable var owner = _owner;

// Query owner, allowing contract users to asynchronously retrieve the current owner
// Since it is a query function, it does not modify the contract state, so it can be called by any user without consensus
public query func getOwner(): async Principal { owner };

// Update owner
public shared({caller}) func updateOwner(newOwner: Principal): async () {
    assert(caller == owner);
    owner := newOwner;
};

public query({caller}) func whoami(): async Principal { caller };
</code></pre>
<br>
<h4 id="fetch-canister"><a class="header" href="#fetch-canister">Fetch Canister</a></h4>
<p>Similarly, the Feed Canister needs to keep records of various Fetch Canisters.</p>
<pre><code class="language-js">stable var postFetchCanister = _postFetchCanister;

public query func getPostFetchCanister(): async Principal { postFetchCanister };

public shared({caller}) func updatePostFetchCanister(
    newPostFetchCanister: Principal
): async () {
    postFetchCanister := newPostFetchCanister;
};
</code></pre>
<p>CommentFetchCanister:</p>
<pre><code class="language-js">stable var commentFetchCanister = _commentFetchCanister;

public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

public shared({caller}) func updateCommentFetchCanister(
    newCommentFetchCanister: Principal
): async () {
    commentFetchCanister := commentFetchCanister;
};
</code></pre>
<p>LikeFetchCanister:</p>
<pre><code class="language-js">stable var likeFetchCanister = _likeFetchCanister;

public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

public shared({caller}) func updateLikeFetchCanister(
    newLikeFetchCanister: Principal
): async () {
    likeFetchCanister := newLikeFetchCanister;
};
</code></pre>
<br>
<h4 id="followers"><a class="header" href="#followers">Followers</a></h4>
<p>The Feed Canister also maintains a list of followers. When a user posts, the Feed Canister sends the post ID and followers to the Fetch Canister, indicating which followers should be notified.</p>
<p>In urgent situations, posts can be sent directly to followers in a peer-to-peer manner, also useful for peer-to-peer messaging.</p>
<pre><code class="language-js">stable var followers: [Principal] = [];

// Receive updates from the user canister
public shared({caller}) func updateFollowers(newFollowers: [Principal]): async () {
    followers := newFollowers;
};

public query func getFollowers(): async [Principal] {
    followers
};
</code></pre>
<br>
<h4 id="bucket-1"><a class="header" href="#bucket-1">Bucket</a></h4>
<pre><code class="language-js">type RootPostActor = Types.RootPostActor;
stable var bucket: ?Principal = null;
stable let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));

// Update the current bucket canister to be used for storing the feed
public shared func checkAvailableBucket(): async Bool {
    switch((await rootPostActor.getAvailableBucket())) {
        case(null) { return false; };
        case(?_bucket) {
            bucket := ?_bucket;
            return true;
        };
    };
};

public query func getBucket(): async ?Principal { bucket };
</code></pre>
<br>
<h4 id="post-2"><a class="header" href="#post-2">Post</a></h4>
<p>Next are the functionalities related to posts.</p>
<pre><code class="language-js">type Time = Types.Time;
type UserId = Types.UserId;
type BucketActor = Types.BucketActor;
type PostFetchActor = Types.PostFetchActor;
type Post = Types.Post;

stable var postIndexEntries: Nat = 0;
stable var postMapEntries: [(Nat, Post)] = [];
let postDirectory: Database.PostDirectory = Database.PostDirectory(postIndexEntries, postMapEntries);

// Query the number of posts a user has made (total count)
public query func getPostNumber(): async Nat {
    postDirectory.getPostNumber()
};

// Query a specific post made by the user based on the post ID
public query func getPost(postId: Text): async  ?PostImmutable {
    postDirectory.getPost(postId)
};

// Query all posts
public query func getAllPost(): async [PostImmutable] {
    postDirectory.getAllPost()
};
</code></pre>
<br>
<p>Core logic for users to create posts.</p>
<pre><code class="language-js">public shared({caller}) func createPost(title: Text, content: Text): async Text {
    // Check if it is called by the owner of the feed to ensure the existence of the bucket (where posts are stored)
    assert(caller == owner and bucket != null);
    let _bucket = Option.unwrap(bucket);
    // Create a new post
    let post: PostImmutable = postDirectory.createPost(caller, Principal.fromActor(this), content, Time.now(), _bucket);

    // Send the post content to the public area of the Bucket 
    let bucketActor: BucketActor = actor(Principal.toText(_bucket));
    assert(await bucketActor.storeFeed(post));

    // Notify PostFetch that there is a new post
    let postFetchActor: PostFetchActor = actor(Principal.toText(postFetchCanister));
    await postFetchActor.receiveNotify(followers, post.postId);

    post.postId
};
</code></pre>
<br>
<p>Creating reposts.</p>
<pre><code class="language-js">public shared({caller}) func createRepost(postId: Text): async Bool {
    switch(postDirectory.createRepost(caller, postId, Time.now())) {
        case(null) { return false; };
        case(?(_bucket, _newRepost)) {
            // Notify the bucket to update repost information
            let bucketActor: BucketActor = actor(Principal.toText(_bucket));
            assert(await bucketActor.updatePostRepost(postId, _newRepost));

            // Get the followers of the one who reposted
            let userActor: UserActor = actor(Principal.toText(userCanister));
            let _repostUserFollowers = await userActor.getFollowersList(caller);

            // Notify PostFetch
            let postFetchActor: PostFetchActor = actor(Principal.toText(postFetchCanister));
            await postFetchActor.receiveNotify(_repostUserFollowers, postId);
            return true;
        };
    };
};
</code></pre>
<br>
<p>Comments and likes.</p>
<p>We use the <code>postDirectory</code> object to create comments or likes.</p>
<pre><code class="language-js">// Shared function, caller information needs to be provided
public shared({caller}) func createComment(postId: Text, content: Text): async Bool {
    // Match the return value of postDirectory.createComment
    switch(postDirectory.createComment(caller, postId, content, Time.now())) {
        // Creation failed
        case(null) { return false; };
        // If it returns a tuple containing _bucket and _newComment, it means the comment was created successfully, and the following actions are performed
        case(?(_bucket, _newComment)) {
            // Notify the corresponding bucket to update comments
            let bucketActor: BucketActor = actor(Principal.toText(_bucket));
            // The assert keyword is used to ensure the success of the update operation
            assert(await bucketActor.updatePostComment(postId, _newComment));
            return true;
        };
    };
};

public shared({caller}) func createLike(postId: Text): async Bool {
    switch(postDirectory.createLike(caller, postId, Time.now())) {
        case(null) { return false; };
        case(?(_bucket, _newLike)) {
            // Notify the bucket to update like information
            let bucketActor: BucketActor = actor(Principal.toText(_bucket));
            assert(await bucketActor.updatePostLike(postId, _newLike));
            return true;
        };
    };
};
</code></pre>
<br>
<h4 id="feed-3"><a class="header" href="#feed-3">Feed</a></h4>
<p>Define some type aliases and variables.</p>
<pre><code class="language-js">type PostImmutable = Types.PostImmutable;
type FeedActor = Types.FeedActor;
type UserActor = Types.UserActor;
type CommentFetchActor = Types.CommentFetchActor;
type LikeFetchActor = Types.LikeFetchActor;

stable var feedMapEntries: [(Text, PostImmutable)] = [];
let feedDirectory = Database.FeedDirectory(feedMapEntries);
</code></pre>
<br>
<p>In addition to publishing posts, comments, and likes, the Feed also needs to receive notifications from other Fetch Canisters to update the internal feed.</p>
<pre><code class="language-js">public shared({caller}) func receiveFeed(postId: Text): async Bool {
    let (_bucket, _, _) = Utils.checkPostId(postId);
    let bucketActor: BucketActor = actor(Principal.toText(_bucket));
    switch((await bucketActor.getPost(postId))) {
        case(null) { return false; };
        case(?_post) {
            feedDirectory.storeFeed(_post);
            return true;
        };
    };
};
</code></pre>
<br>
<p>Sometimes the Feed needs to receive a lot of posts at once, so we also need a function for batch receiving posts.</p>
<p>It receives an array containing multiple post IDs, retrieves post information from the corresponding Bucket for each post ID, and stores it in the <code>feedDirectory</code> if the post exists.</p>
<pre><code class="language-js">public shared({caller}) func batchReceiveFeed(postIdArray: [Text]): async () {
    for(_postId in postIdArray.vals()) {
        let (_bucket, _, _) = Utils.checkPostId(_postId);
        let bucketActor: BucketActor = actor(Principal.toText(_bucket));
        switch((await bucketActor.getPost(_postId))) {
            case(null) { };
            case(?_post) {
                feedDirectory.storeFeed(_post);
            };
        };
    };
};
</code></pre>
<br>
<p>Receive comments and notify the followers of the user based on the repost information of the post. If the post does not exist, the function returns <code>false</code>.</p>
<pre><code class="language-js">public shared({caller}) func receiveComment(postId: Text): async Bool {
    let (_bucket, _, _) = Utils.checkPostId(postId);
    let bucketActor: BucketActor = actor(Principal.toText(_bucket));
    switch((await bucketActor.getPost(postId))) {
        case(null) { return false; };
        case(?_post) {

            feedDirectory.storeFeed(_post);

            if(Utils._isRepostUser(_post, owner)) {
                // If the user is the repost user of this post, continue pushing to their followers                    
                let userActor: UserActor = actor(Principal.toText(userCanister));
                let repostUserFollowers = await userActor.getFollowersList(owner);

                let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
                await commentFetchActor.receiveRepostUserNotify(repostUserFollowers, postId);
            };

            return true;
        };
    };
};
</code></pre>
<br>
<p>Batch receive comments.</p>
<pre><code class="language-js">public shared({caller}) func batchReceiveComment(postIdArray: [Text]): async () {
    for(_postId in postIdArray.vals()) {
        let (_bucket, _, _) = Utils.checkPostId(_postId);
        let bucketActor: BucketActor = actor(Principal.toText(_bucket));
        switch((await bucketActor.getPost(_postId))) {
            case(null) { };
            case(?_post) {
                feedDirectory.storeFeed(_post);

                if(Utils._isRepostUser(_post, owner)) {
                    // If the user is the repost user of this post, continue pushing to their followers                
                    let userActor: UserActor = actor(Principal.toText(userCanister));
                    let repostUserFollowers = await userActor.getFollowersList(owner);

                    let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
                    await commentFetchActor.receiveRepostUserNotify(repostUserFollowers, _postId);
                };
            };
        };
    };
};
</code></pre>
<br>
<p>Receive likes.</p>
<pre><code class="language-js">public shared({caller}) func receiveLike(postId: Text): async Bool {
    let (_bucket, _, _) = Utils.checkPostId(postId);
    let bucketActor: BucketActor = actor(Principal.toText(_bucket));
    switch((await bucketActor.getPost(postId))) {
        case(null) { return false; };
        case(?_post) {

            feedDirectory.storeFeed(_post);

            if(Utils._isRepostUser(_post, owner)) {
                // If the user is the repost user of this post, continue pushing to their followers                    
                let userActor: UserActor = actor(Principal.toText(userCanister));
                let repostUserFollowers = await userActor.getFollowersList(owner);

                let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
                await likeFetchActor.receiveRepostUserNotify(repostUserFollowers, postId);
            };

            return true;
        };
    };
};
</code></pre>
<br>
<p>Batch receive likes.</p>
<pre><code class="language-js">public shared({caller}) func batchReceiveLike(postIdArray: [Text]): async () {
    for(_postId in postIdArray.vals()) {
        let (_bucket,

 _, _) = Utils.checkPostId(_postId);
        let bucketActor: BucketActor = actor(Principal.toText(_bucket));
        switch((await bucketActor.getPost(_postId))) {
            case(null) {};
            case(?_post) {

                feedDirectory.storeFeed(_post);

                if(Utils._isRepostUser(_post, owner)) {
                    // If the user is the repost user of this post, continue pushing to their followers                    
                    let userActor: UserActor = actor(Principal.toText(userCanister));
                    let repostUserFollowers = await userActor.getFollowersList(owner);

                    let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
                    await likeFetchActor.receiveRepostUserNotify(repostUserFollowers, _postId);
                };
            };
        };
    };
};
</code></pre>
<br>
<p>Finally, there are some query functions.</p>
<pre><code class="language-js">public query func getFeedNumber(): async Nat {
    feedDirectory.getFeedNumber()
};

public query func getFeed(postId: Text): async ?PostImmutable {
    feedDirectory.getFeed(postId)
};

public query func getLatestFeed(n: Nat): async [PostImmutable] {
    feedDirectory.getLatestFeed(n)
};
</code></pre>
<br>
<p>You can view the complete <a href="https://github.com/NeutronStarDAO/Proton/blob/rust/src/feed/feed.mo">feed.mo file here</a>.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h2 id="fetch-1"><a class="header" href="#fetch-1">Fetch</a></h2>
<p>The Fetch module is responsible for notifying relevant users. There are a total of 4 Canisters:</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/7.FetchModule/image-20240128104854006.png" alt="img" style="zoom:50%;" />
</div>
<p>The functionality of the Root Fetch Canister is relatively simple; it is responsible for creating and managing all types of Fetch Canisters. The Post Fetch Canister is responsible for notifying followers about post updates. Comment Fetch Canister and Like Fetch Canister handle the notification of comments and likes.</p>
<p>Since the code in this module has high redundancy, we will only detail the code for Root Fetch Canister, Post Fetch Canister, and Like Fetch Canister.</p>
<br>
<h3 id="rootfetchmo"><a class="header" href="#rootfetchmo">rootFetch.mo</a></h3>
<div class="center-image">
<img src="9.DevelopingDApp/assets/7.FetchModule/image-20240128223418061.png" alt="image-20240128223418061" style="zoom:50%;" />
</div>
<p>First, define types and variables.</p>
<pre><code class="language-js">actor class RootFetch(
    userCanister: Principal,
) = this {

    type RootFeedActor = Types.RootFeedActor;
    type PostFetchActor = Types.PostFetchActor;
    type CommentFetchActor = Types.CommentFetchActor;
    type LikeFetchActor = Types.LikeFetchActor;

    stable let T_CYCLES = 1_000_000_000_000;
    stable var rootFeedCanister = Principal.fromText(&quot;2vxsx-fae&quot;);
    stable var postFetchCanisterIndex: Nat = 0;
    stable var commentFetchCanisterIndex: Nat = 0;
    stable var likeFetchCanisterIndex: Nat = 0;

    // Create three TrieMaps to store posts, comments, and likes.
    // This makes it easy to manage and retrieve relevant data, such as finding comments or likes for a post.

    // Its type is an array of tuples, each tuple containing a natural number (Nat) and a Principal.
    stable var postFetchMapEntries: [(Nat, Principal)] = [];
    // Build a Map from the values of the postFetchMapEntries array, using Nat.equal for key equality and Hash.hash for hashing.
    let postFetchMap = TrieMap.fromEntries&lt;Nat, Principal&gt;(postFetchMapEntries.vals(), Nat.equal, Hash.hash);

    stable var commentFetchMapEntries: [(Nat, Principal)] = [];
    let commentFetchMap = TrieMap.fromEntries&lt;Nat, Principal&gt;(commentFetchMapEntries.vals(), Nat.equal, Hash.hash);
    
    stable var likeFetchMapEntries: [(Nat, Principal)] = [];
    let likeFetchMap = TrieMap.fromEntries&lt;Nat, Principal&gt;(likeFetchMapEntries.vals(), Nat.equal, Hash.hash);    
};
</code></pre>
<br>
<p>After creating the Root Fetch Canister, we establish relationships between user feeds, posts, comments, and likes by creating child Canisters in the initialization function.</p>
<pre><code class="language-js">public shared({caller}) func init(
    _rootFeedCanister: Principal,
    _initPostFetchCanister: Principal,
    _initCommentFetchCanister: Principal,
    _initLikeFetchCanister: Principal
): async () {
    rootFeedCanister := _rootFeedCanister;

    // Define three maps to store different types of fetch canisters.
    postFetchMap.put(postFetchCanisterIndex, _initPostFetchCanister);
    commentFetchMap.put(commentFetchCanisterIndex, _initCommentFetchCanister);
    likeFetchMap.put(likeFetchCanisterIndex, _initLikeFetchCanister);

    // Also define three index variables for generating a unique index for each fetch canister.
    postFetchCanisterIndex += 1;
    commentFetchCanisterIndex += 1;
    likeFetchCanisterIndex += 1;

    // Create four actor objects using the actor function.
    let rootFeedActor: RootFeedActor = actor(Principal.toText(_rootFeedCanister));
    let _postFetchActor: PostFetchActor = actor(Principal.toText(_initPostFetchCanister));
    let _commentFetchActor: CommentFetchActor = actor(Principal.toText(_initCommentFetchCanister));
    let _likeFetchActor: LikeFetchActor = actor(Principal.toText(_initLikeFetchCanister));
    let _allUserFeedCanister = await rootFeedActor.getAllUserFeedCanister();

    // Call the initUserToFeed method for the three Fetch Canisters, passing in the list of user feed canisters to initialize the relationship between users and feeds in these Fetch Canisters.
    // Use assert to confirm that all three initUserToFeed calls are executed successfully.
    assert(await _postFetchActor.initUserToFeed(_allUserFeedCanister));
    assert(await _commentFetchActor.initUserToFeed(_allUserFeedCanister));
    assert(await _likeFetchActor.initUserToFeed(_allUserFeedCanister));
};
</code></pre>
<p>Next is the function to create the Post Fetch Canister:</p>
<p>Create a new Post Fetch Canister and store the newly created Canister ID in the Map.
It also interacts with the Root Feed Canister.</p>
<pre><code class="language-js">public shared({caller}) func createPostFetchCanister(): async Principal {
    // Add 4T Cycles to each Canister
    Cycles.add(4 * T_CYCLES);
    // Call the constructor of the PostFetch module to create a new PostFetch Canister
    let _canister = await PostFetch.PostFetch();
    // Get the Canister ID of the newly created Canister
    let _canisterId = Principal.fromActor(_canister);
    // Put the Principal of the new Canister into the postFetchMap
    postFetchMap.put(postFetchCanisterIndex, _canisterId);
    // Increment the index
    postFetchCanisterIndex += 1;

    // postFetch: initUserToFeed
    // Use assert to check if rootFeedCanister is not anonymous
    assert(not Principal.isAnonymous(rootFeedCanister));
    // Convert rootFeedCanister to text using Principal.toText, then create a RootFeedActor using the actor keyword
    let rootFeedActor: RootFeedActor = actor(Principal.toText(rootFeedCanister));
    // Use assert to check and ensure calling the initUserToFeed method of _canister, passing the Principal list of all user Feed Canisters
    assert(await _canister.initUserToFeed((await rootFeedActor.getAllUserFeedCanister())));

    // Return the Canister ID of the newly created Canister
    _canisterId
};

// Create Fetch Canisters responsible for notifying comments and likes, similar to creating Post Fetch Canister:

public shared({caller}) func createCommentFetchCanister(): async Principal {
    Cycles.add(4 * T_CYCLES);
    let _canister = await CommentFetch.CommentFetch(
        userCanister
    );
    let _canisterId = Principal.fromActor(_canister);
    commentFetchMap.put(commentFetchCanisterIndex, _canisterId);
    commentFetchCanisterIndex += 1;

    // initUserToFeed
    assert(not Principal.isAnonymous(rootFeedCanister));
    let rootFeedActor: RootFeedActor = actor(Principal.toText(rootFeedCanister));
    assert(await _canister.initUserToFeed((await rootFeedActor.getAllUserFeedCanister())));

    _canisterId
};

public shared({caller}) func createLikeFetchCanister(): async Principal {
    Cycles.add(4 * T_CYCLES);
    let _canister = await LikeFetch.LikeFetch(
        userCanister
    );
    let _canisterId = Principal.fromActor(_canister);
    likeFetchMap.put(likeFetchCanisterIndex, _canisterId);
    likeFetchCanisterIndex += 1;

    // initUserToFeed
    assert(not Principal.isAnonymous(rootFeedCanister));
    let rootFeedActor: RootFeedActor = actor(Principal.toText(rootFeedCanister));
    assert(await _canister.initUserToFeed((await rootFeedActor.getAllUserFeedCanister())));

    _canisterId
};

// Finally, we write query functions to query various Fetch Canisters.

public query func getAllPostFetchCanister(): async [Principal] {
    // Get all Canister IDs from the Map
    Iter.toArray(postFetchMap.vals())
    // Iter.toArray is a function that converts an iterator to an array, turning all Canister IDs in the Map into an array
};

public query func getAllCommentFetchCanister(): async [Principal] {
    Iter.toArray(commentFetchMap.vals())
};

public query func getAllLikeFetchCanister(): async [Principal] {
    Iter.toArray(likeFetchMap.vals())
};
</code></pre>
<h3 id="postfetchmo"><a class="header" href="#postfetchmo">postFetch.mo</a></h3>
<p>Post Fetch is responsible for notifying a user's posts to their followers.</p>
<div class="center-image">
<img src="9.DevelopingDApp/assets/7.FetchModule/image-20240128232529601.png" alt="img" style="zoom:50%;" />
</div>
<p>The content in postFetch.mo will be translated in the next response.</p>
<pre><code class="language-js">import Types &quot;./types&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Array &quot;mo:base/Array&quot;;
import Timer &quot;mo:base/Timer&quot;;
import Debug &quot;mo:base/Debug&quot;;
import Iter &quot;mo:base/Iter&quot;;

actor class PostFetch() = this {

    // Internal maintenance of a notification table: records the post IDs to be notified for each user.
    // Define notifyMapEntries as an array of tuples, each tuple containing a Principal and an array of Text [Text].
    // The stable keyword ensures that the data of this variable will be saved even in the case of contract upgrades.
    stable var notifyMapEntries: [(Principal, [Text])] = [];
    let notifyMap = TrieMap.fromEntries&lt;Principal, [Text]&gt;(notifyMapEntries.vals(), Principal.equal, Principal.hash);

    // Notification function: post ID, poster, forwarder, followers, Cycles
    // When receiveNotify is called, it takes an array of Principals and a post ID.
    public shared({caller}) func receiveNotify(to: [Principal], postId: Text): async () {
        for(_user in to.vals()) {
            Debug.print(
                &quot;Canister PostFetch, Func receiveNotify, &quot;
                # &quot;to : &quot; # Principal.toText(_user) # &quot; ,&quot;
                # &quot;postId : &quot; # postId
            );
        };
        // Each Principal represents a user. The function iterates through each user in the array and checks if there is a record for the user in notifyMap.
        for(_follower in to.vals()) {
            switch(notifyMap.get(_follower)) {
                case(null) {
                    // If not, create a new one containing only the current post ID.
                    notifyMap.put(_follower, [postId]);
                };
                // If yes, append the current post ID to the array of post IDs for this user.
                case(?_postIdArray) {
                    notifyMap.put(_follower, Array.append(_postIdArray, [postId]));
                };
            };
        };
    };

    // Provide a way to query the current state of notifyMap by converting TrieMap entries to an array and returning it.
    public query func getNotifyMapEntries(): async [(Principal, [Text])] {
        Iter.toArray(notifyMap.entries())
    };

    // userToFeed

    // User relationship management
    // Define a new TrieMap that saves the relationship between each user's principal id and their Feed Canister id.
    stable var userToFeedEntries: [(Principal, Principal)] = [];
    var userToFeed = TrieMap.fromEntries&lt;Principal, Principal&gt;(userToFeedEntries.vals(), Principal.equal, Principal.hash);
    
    // Initialize userToFeed
    public shared({caller}) func initUserToFeed(_userToFeedArray: [(Principal, Principal)]): async Bool {
        userToFeed := TrieMap.fromEntries(
            _userToFeedArray.vals(),
            Principal.equal,
            Principal.hash
        );
        true
    };

    // Add new relationships
    public shared({caller}) func addUserToFeedEntry(entry: (Principal, Principal)): async Bool {
        switch(userToFeed.get(entry.0)) {
            case(?_feedCanister) { return false; };
            case(null) {
                userToFeed.put(entry.0, entry.1);
                true
            } 
        }
    };

    // Query the existing hash table
    public query func getUserToFeedEntries(): async [(Principal, Principal)] {
        Iter.toArray(userToFeed.entries())
    };

    public query({caller}) func whoami(): async Principal { caller };

    // Timer

    type FeedActor = Types.FeedActor;

    // Notify followers' Feed in batches using the ignore call based on the algorithm.
    // Callback function triggered by the timer
    func notify(): async () {
        // Debug.print(&quot;postFetch notify !&quot;);
        let _notifyMap = notifyMap;
        // Check each entry in notifyMap, for each user
        for((_user, _postIdArray) in _notifyMap.entries()) {
            // Try to get the corresponding Feed canister from userToFeed
            switch(userToFeed.get(_user)) {
                case(null) { };
                // If the Feed canister is found, create a notification
                // and call the batchReceiveFeed function to pass all pending post IDs
                case(?_feedId) {
                    // Debug.print(&quot;Notify feed canister &quot; # Principal.toText(_feedId));
                    let feedActor: FeedActor = actor(Principal.toText(_feedId));
                    ignore feedActor.batchReceiveFeed(_postIdArray);
                    // Remove the entry for this user from notifyMap to avoid duplicate notifications
                    notifyMap.delete(_user);
                };
            };
        };
    };

    // Define a recurring timer cycleTimer that calls the notify function periodically (every 2 seconds).
    // The purpose of the notify function is to notify users that their Feed has been updated.
    let cycleTimer = Timer.recurringTimer(
        #seconds(2),
        notify
    );

    // System functions, as mentioned earlier, won't go into details here.
    system func preupgrade() {
        notifyMapEntries := Iter.toArray(notifyMap.entries());
        userToFeedEntries := Iter.toArray(userToFeed.entries());
    };

    system func postupgrade() {
        notifyMapEntries := [];
        userToFeedEntries := [];
    };
};
</code></pre>
<br>
<h3 id="likefetchmo"><a class="header" href="#likefetchmo">likeFetch.mo</a></h3>
<p>Like Fetch Canister is similar to the Post Fetch Canister, with only one procedural difference. Like Fetch Canister queries followers based on the owner of the post and then notifies the followers. In contrast, Post Fetch Canister only notifies based on the direct list of followers provided by the post author.</p>
<pre><code class="language-js">import Principal &quot;mo:base/Principal&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import Types &quot;./types&quot;;
import Array &quot;mo:base/Array&quot;;
import Timer &quot;mo:base/Timer&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor class LikeFetch(
    userCanister: Principal
) = this {

    // Define type aliases
    type UserActor = Types.UserActor;
    type PostImmutable = Types.PostImmutable;
    type Repost = Types.Repost;

    // Use a stable variable notifyMapEntries to store notifications (tuples of Principal and an array of Text).
    // Initialize a TrieMap as the actual notification Map.
    stable var notifyMapEntries: [(Principal, [Text])] = [];
    let notifyMap = TrieMap.fromEntries&lt;Principal, [Text]&gt;(notifyMapEntries.vals(), Principal.equal, Principal.hash);
    
    // Receive notification for a post
    // First, obtain the followers list of the owner of the post from the user's actor,
    // and then call the _storeNotify function to store notifications for followers and reposters.
    public shared({caller}) func receiveNotify(post: PostImmutable): async () {
        // Retrieve followers of the user who posted this post
        let userActor: UserActor = actor(Principal.toText(userCanister));
        let postUserFollowers = await userActor.getFollowersList(post.user);

        // Notify followers
        _storeNotify(postUserFollowers, post.postId);

        // Notify users who reposted the post
        _storeNotify(
            Array.map&lt;Repost, Principal&gt;(
                post.repost,
                func (x: Repost): Principal {
                    x.user
                }
            ), 
            post.postId
        );
    };

    public shared({caller}) func receiveRepostUserNotify(to: [Principal], postId: Text): async () {
        _storeNotify(to, postId);
    };

    public query func getNotifyMapEntries(): async [(Principal, [Text])] {
        Iter.toArray(notifyMap.entries())
    };

    // Store notifications
    // It checks if the specified Principal already has a notification list.
    // If not, it creates a new list and adds the post ID; if yes, it appends the post ID to the existing list.
    private func _storeNotify(to: [Principal], postId: Text) {
        for(_follower in to.vals()) {
            switch(notifyMap.get(_follower)) {
                case(null) {
                    notifyMap.put(_follower, [postId]);
                };
                case(?_postIdArray) {
                    let _newPostIdArray = Array.append(_postIdArray, [postId]);
                    notifyMap.put(_follower, _newPostIdArray);
                };
            };
        };
    };
// userToFeed

    stable var userToFeedEntries: [(Principal, Principal)] = [];
    var userToFeed = TrieMap.fromEntries&lt;Principal, Principal&gt;(userToFeedEntries.vals(), Principal.equal, Principal.hash);

    public shared({caller}) func initUserToFeed(_userToFeedArray: [(Principal, Principal)]): async Bool {
        userToFeed := TrieMap.fromEntries(
            _userToFeedArray.vals(),
            Principal.equal,
            Principal.hash
        );
        true
    };

    public shared({caller}) func addUserToFeedEntry(entry: (Principal, Principal)): async Bool {
        switch(userToFeed.get(entry.0)) {
            case(?_feedCanister) { return false; };
            case(null) {
                userToFeed.put(entry.0, entry.1);
                true
            } 
        }
    };

    public query func getUserToFeedEntries(): async [(Principal, Principal)] {
        Iter.toArray(userToFeed.entries())
    };
    
    public query({caller}) func whoami(): async Principal { caller };

// Timer

    type FeedActor = Types.FeedActor;

    func notify(): async () {
        // Debug.print(&quot;likeFetch notify !&quot;);
        let _notifyMap = notifyMap; 
        for((_user, _postIdArray) in _notifyMap.entries()) {
            switch(userToFeed.get(_user)) {
                case(null) { };
                case(?_feedId) {
                    let feedActor: FeedActor = actor(Principal.toText(_feedId));
                    ignore feedActor.batchReceiveLike(_postIdArray);
                    notifyMap.delete(_user);
                };
            };
        };
    };

    let cycleTimer = Timer.recurringTimer(
        #seconds(2),
        notify
    );

    system func preupgrade() {
        notifyMapEntries := Iter.toArray(notifyMap.entries());
        userToFeedEntries := Iter.toArray(userToFeed.entries());
    };

    system func postupgrade() {
        notifyMapEntries := [];
        userToFeedEntries := [];
    };

};
</code></pre>
<br>
<h3 id="commentfetchmo"><a class="header" href="#commentfetchmo">commentFetch.mo</a></h3>
<p>Comment Fetch Canister is the same as the Like Fetch Canister, so there's no need to repeat the explanation.</p>
<p>Here is the commentFetch.mo source file:</p>
<pre><code class="language-js">import Principal &quot;mo:base/Principal&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import Types &quot;./types&quot;;
import Array &quot;mo:base/Array&quot;;
import Timer &quot;mo:base/Timer&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;

actor class CommentFetch(
    userCanister: Principal
) = this {
    
    type UserActor = Types.UserActor;
    type PostImmutable = Types.PostImmutable;
    type Repost = Types.Repost;

    // A list where each element is a tuple containing a Principal and an array of Text strings.
    // This list is used to initialize notifyMap, which is a TrieMap structure for efficiently storing and retrieving key-value pairs.
    stable var notifyMapEntries: [(Principal, [Text])] = [];
    let notifyMap = TrieMap.fromEntries&lt;Principal, [Text]&gt;(notifyMapEntries.vals(), Principal.equal, Principal.hash);
    
    public shared({caller}) func receiveNotify(post: PostImmutable): async () {
        // Retrieve followers of the user who posted this post
        let userActor: UserActor = actor(Principal.toText(userCanister));
        let postUserFollowers = await userActor.getFollowersList(post.user);

        // Notify followers
        _storeNotify(postUserFollowers, post.postId);

        // Notify users who reposted the post
        _storeNotify(
            Array.map&lt;Repost, Principal&gt;(
                post.repost,
                func (x: Repost): Principal {
                    x.user
                }
            ), 
            post.postId
        );
    };

    public shared({caller}) func receiveRepostUserNotify(to: [Principal], postId: Text): async () {
        _storeNotify(to, postId);
    };

    private func _storeNotify(to: [Principal], postId: Text) {
        for(_follower in to.vals()) {
            switch(notifyMap.get(_follower)) {
                case(null) {
                    notifyMap.put(_follower, [postId]);
                };
                case(?_postIdArray) {
                    notifyMap.put(_follower, Array.append(_postIdArray, [postId]));
                };
            };
        };
    };

    public query func getNotifyMapEntries(): async [(Principal, [Text])] {
        Iter.toArray(notifyMap.entries())
    };

// userToFeed

    stable var userToFeedEntries: [(Principal, Principal)] = [];
    var userToFeed = TrieMap.fromEntries&lt;Principal, Principal&gt;(userToFeedEntries.vals(), Principal.equal, Principal.hash);

    public shared({caller}) func initUserToFeed(_userToFeedArray: [(Principal, Principal)]): async Bool {
        userToFeed := TrieMap.fromEntries(
            _userToFeedArray.vals(),
            Principal.equal,
            Principal.hash
        );
        true
    };

    public shared({caller}) func addUserToFeedEntry(entry: (Principal, Principal)): async Bool {
        switch(userToFeed.get(entry.0)) {
            case(?_feedCanister) { return false; };
            case(null) {
                userToFeed.put(entry.0, entry.1);
                true
            } 
        }
    };

    public query func getUserToFeedEntries(): async [(Principal, Principal)] {
        Iter.toArray(userToFeed.entries())
    };
    
    public query({caller}) func whoami(): async Principal { caller };

// Timer

    type FeedActor = Types.FeedActor;

    func notify(): async () {
        // Debug.print(&quot;commentFetch notify !&quot;);
        let _notifyMap = notifyMap; 
        for((_user, _postIdArray) in _notifyMap.entries()) {
            switch(userToFeed.get(_user)) {
                case(null) { };
                case(?_feedId) {
                    // Debug.print(&quot;commentFetch Notify feed canister &quot; # Principal.toText(_feedId));
                    let feedActor: FeedActor = actor(Principal.toText(_feedId));
                    ignore feedActor.batchReceiveComment(_postIdArray);
                    notifyMap.delete(_user);
                };
            };
        };
    };

    let cycleTimer = Timer.recurringTimer(
        #seconds(2),
        notify
    );

    system func preupgrade() {
        notifyMapEntries := Iter.toArray(notifyMap.entries());
        userToFeedEntries := Iter.toArray(userToFeed.entries());
    };

    system func postupgrade() {
        notifyMapEntries := [];
        userToFeedEntries := [];
    };
};
</code></pre>
<br>
<div style="break-before: page; page-break-before: always;"></div><p>The types needed in the entire system are defined here.</p>
<p>The complete types.mo file:</p>
<pre><code class="language-js">import Principal &quot;mo:base/Principal&quot;;
import Time &quot;mo:base/Time&quot;;

module {

// ==================== Feed ====================

    public type UserId = Principal;
    public type Time = Time.Time;
    public type PostId = Text; // Post ID = BucketCanisterID + UserId + Incremental

    public type Post = {
        postId: PostId; // Post ID
        feedCanister: Principal;
        index: Nat; // Post Index
        user: UserId; // Publisher
        content: Text;
        var repost: [Repost]; // Reposters
        var like: [Like];
        var comment: [Comment];
        createdAt: Time; // Publication time
    };

    public type PostImmutable = {
        postId: PostId; // Post ID
        feedCanister: Principal;
        index: Nat; // Post Index
        user: UserId; // Publisher
        content: Text;
        repost: [Repost]; // Reposters
        like: [Like];
        comment: [Comment];
        createdAt: Time; // Publication time
    };

    public type Comment = {
        user: UserId;
        content: Text;
        createdAt: Time;
    };

    public type NewComment = [Comment];

    public type Like = {
        user: UserId;
        createdAt: Time;
    };

    public type Repost = {
        user: UserId;
        createdAt: Time;
    };

    public type NewRepost = [Repost];

    public type NewLike = [Like];

    public type RootFeedActor = actor {
        getAllUserFeedCanister: shared query () -&gt; async [(Principal, Principal)];
    };

    public type FeedActor = actor {
        getPosts: shared query () -&gt; async [PostImmutable];
        receiveFeed: shared (Text) -&gt; async Bool;
        batchReceiveFeed: shared ([Text]) -&gt; async ();
        batchReceiveComment: shared ([Text]) -&gt; async ();
        batchReceiveLike: shared ([Text]) -&gt; async ();
        createComment: shared (Principal, Nat, Text) -&gt; async ();
        deleteComment: shared (Principal, Nat, Nat) -&gt; async ();
        createLike: shared (Principal, Nat) -&gt; async ();
        deleteLike: shared (Principal, Nat) -&gt; async ();
        updateFollowers: shared ([Principal]) -&gt; async ();
    };

// ==================== Post ====================

    public type RootPostActor = actor {
        getAvailableBucket: shared query () -&gt; async ?Principal;
        getAllBuckets: shared query () -&gt; async [Principal];
        getAllAvailableBuckets: shared query () -&gt; async [Principal];
        getAllUnavailableBuckets: shared query () -&gt; async [Principal];
        reCreateBucket: shared () -&gt; async ();
    };

// ==================== Bucket ====================

    public type BucketActor = actor {
        storeFeed: shared (PostImmutable) -&gt; async Bool;
        updatePostComment: shared (Text, NewComment) -&gt; async Bool;
        updatePostLike: shared (Text, NewLike) -&gt; async Bool;
        updatePostRepost: shared (Text, NewRepost) -&gt; async Bool;
        getPosts: shared query ([Text]) -&gt; async [PostImmutable];
        getPost: shared query (Text) -&gt; async ?PostImmutable;
    };

// ==================== Fetch ====================

    public type RootFetchActor = actor {
        createPostFetchCanister: shared () -&gt; async Principal;
        createCommentFetchCanister: shared () -&gt; async Principal;
        createLikeFetchCanister: shared () -&gt; async Principal;
        getAllPostFetchCanister: shared query () -&gt; async [Principal];
        getAllCommentFetchCanister: shared query () -&gt; async [Principal];
        getAllLikeFetchCanister: shared query () -&gt; async [Principal];
    };

    public type PostFetchActor = actor {
        receiveNotify: shared ([Principal], Text) -&gt; async ();
        addUserToFeedEntry: shared ((Principal, Principal)) -&gt; async Bool;
        initUserToFeed: shared ([(Principal, Principal)]) -&gt; async Bool;
    };

    public type CommentFetchActor = actor {
        receiveNotify: shared (PostImmutable) -&gt; async ();
        receiveRepostUserNotify: shared ([Principal], Text) -&gt; async ();
        addUserToFeedEntry: shared ((Principal, Principal)) -&gt; async Bool;
        initUserToFeed: shared ([(Principal, Principal)]) -&gt; async Bool;
    };

    public type LikeFetchActor = actor {
        receiveNotify: shared (PostImmutable) -&gt; async ();
        receiveRepostUserNotify: shared ([Principal], Text) -&gt; async ();
        addUserToFeedEntry: shared ((Principal, Principal)) -&gt; async Bool;
        initUserToFeed: shared ([(Principal, Principal)]) -&gt; async Bool;
    };

// ==================== User ====================

    public type Vertex = Principal;

    public type UserActor = actor {
        getFollowersList: shared query (Vertex) -&gt; async [Vertex];
    };

}
</code></pre>
<p>utils.mo file provides some helper functions for handling posts.</p>
<p>The <code>checkPostId</code> function extracts the bucket ID, user ID, and post index from the post ID.</p>
<ul>
<li>Parameters: <code>postId</code> - The unique identifier of the post (composed of <code>BucketCanisterID + UserId + Incremental</code>).</li>
<li>Return value: A tuple containing the extracted <code>bucket</code> (bucket ID), <code>user</code> (user ID), and <code>postIndex</code> (post index) from the post ID.</li>
</ul>
<p>The <code>_convertPostToImmutable</code> function is used to convert a mutable post to an immutable post.</p>
<ul>
<li>Parameters: <code>post</code> - Mutable post (Post).</li>
<li>Return value: A function that converts a mutable post to an immutable post (PostImmutable).</li>
</ul>
<p>The <code>_isRepostUser</code> function checks if a specified user is one of the repost users for a given post.</p>
<ul>
<li>Parameters: <code>post</code> - Immutable post (PostImmutable), <code>user</code> - User ID to check if it is a repost user.</li>
<li>Return value: Returns true if the specified user is one of the repost users for the post; otherwise, returns false.</li>
</ul>
<pre><code class="language-js">import Iter &quot;mo:base/Iter&quot;;
import Text &quot;mo:base/Text&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Option &quot;mo:base/Option&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Debug &quot;mo:base/Debug&quot;;
import Types &quot;./types&quot;;

module {
    type Post = Types.Post;
    type PostImmutable = Types.PostImmutable;

    public func checkPostId(postId: Text): (Principal, Principal, Nat) {
        let words = Iter.toArray(Text.split(postId, #char '#'));
        let bucket = Principal.fromText(words[0]);
        let user = Principal.fromText(words[1]);
        let postIndex = Option.unwrap(Nat.fromText(words[2]));
        // Debug.print(&quot;(bucket, user, index): (&quot; # words[0] # &quot;,&quot; # words[1] # &quot;,&quot; # words[2] # &quot;)&quot;);
        (bucket, user, postIndex)
    };

    public func _convertPostToImmutable(post: Post): PostImmutable {
      {
        postId = post.postId;
        index = post.index;
        feedCanister = post.feedCanister;
        user = post.user;
        repost = post.repost;
        content = post.content;
        like =

 post.like;
        comment = post.comment;
        createdAt = post.createdAt;
      }
    };

    public func _isRepostUser(post: PostImmutable, user: Principal): Bool {
        for (_repostUser in post.repost.vals()) {
            if (_repostUser.user == user) {
                return true;
            };
        };
        false
    };

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="-congratulations-"><a class="header" href="#-congratulations-">üéâ Congratulations! üéâ</a></h2>
<p>By completing this tutorial, you have mastered how to develop decentralized applications on the <a href="https://internetcomputer.org">Internet Computer</a> using the <a href="https://internetcomputer.org/docs/current/motoko/main/motoko">Motoko language</a>. Together, we built a decentralized social network, implementing features such as user registration, posting, commenting, and reposting.</p>
<p>The tutorial covers core concepts like defining users, posts, comments, likes, and utilizing Motoko's Actor model for concurrent programming. It also explores methods for data storage, retrieval, and handling user activities. This knowledge forms a solid foundation for future development of more complex and powerful DApps.</p>
<br>
<p>Developing decentralized applications is a promising and challenging field. Compared to centralized applications, it offers higher fault tolerance, greater user control, and enhanced privacy protection. However, it's essential to note that decentralized networks are still in their early stages, with challenges such as performance, scalability, and governance mechanisms yet to be fully addressed.</p>
<p><strong><a href="https://github.com/NeutronStarDAO/Proton">Proton</a> is a starting point that continues to evolve and innovate. You can continue to enhance it, add new features to adapt to future needs.</strong></p>
<p>Throughout the development process, you may encounter challenges, but remember, each challenge is an opportunity to learn. You can seek assistance in the <a href="https://forum.dfinity.org">community</a>, share experiences with other developers, and collaboratively solve problems. Additionally, contributing your experiences and knowledge to the community is welcome, fostering mutual learning and progress.</p>
<br>
<p>Finally, thank you for reading! I hope this tutorial has been helpful and inspiring. May it serve as a solid starting point for your journey into decentralized application development.</p>
<p>Feel free to share your questions and insights in the comments section, as we explore the limitless possibilities of the decentralized world together.</p>
<br><div style="break-before: page; page-break-before: always;"></div><h2 id="web3"><a class="header" href="#web3">Web3</a></h2>
<p>Web3 is the next generation version of the internet that aims to bring more decentralization, security and transparency to our online world. Imagine that the current internet (what we call Web2) is mainly controlled by a few big companies, while Web3 tries to distribute power and control to users. This means that in the Web3 world, users have more control over their own data and identities, rather than handing them entirely over to companies like Google, Facebook, etc.</p>
<p>The core technology behind Web3 is blockchain, which is a decentralized, secure distributed database. You can think of blockchain as a public ledger that can record transactions and activities for everyone, and once recorded, cannot be tampered with. Blockchain-based applications such as smart contracts, decentralized finance (DeFi), and decentralized apps (Dapps) are all important components of Web3.</p>
<p>Let's use an example to illustrate how Web3 is changing the existing internet. In Web2, if an artist wants to sell their work online, they usually have to rely on some centralized platforms (like eBay, Amazon, etc). These platforms often charge high fees and control the transaction process for users. But in the Web3 world, artists can sell their work on decentralized marketplaces (like OpenSea). Here, artists can turn their work into non-fungible tokens (NFTs) and sell directly to buyers without third party intervention. This way, artists can earn more profits and have more control over the transactions.</p>
<p>Web3 also provides better protection for online privacy. On today's internet, users' data and privacy are often easily compromised. With Web3, users can ensure their data security through encryption and self-sovereign identity. This makes the entire network more secure and reliable.</p>
<p>Web3 represents a new era of the internet built on blockchain technology that redistributes power and control back to users, increasing security and transparency. Through decentralized apps and services, Web3 has the potential to transform how we interact with the internet, creating a more fair and open online world.</p>
<h2 id="smart-contract"><a class="header" href="#smart-contract">Smart contract</a></h2>
<p>A smart contract is like a self-executing digital contract that defines a set of pre-programmed rules. Once these rules are met, the smart contract automatically executes the corresponding actions. It is based on blockchain technology, meaning it is decentralized, secure, and cannot be modified once deployed. Simply put, a smart contract is a piece of self-executing computer code that ensures transactions, agreements, etc. can be carried out between parties without the need for a third party. </p>
<p>It's like a vending machine - you put in $5, it spits out a $5 drink for you.</p>
<p>Imagine you and a friend bet on which football team would win a match. In real life, you may need a trusted third party to hold the stakes. But with a smart contract, you can create a program to replace this third party. This program would receive your stakes, and automatically pay out the winner based on the match result after the game ends. This way, no real person needs to be involved, and you don't need to worry about the other party not keeping their word.</p>
<p>Smart contracts have a wide range of applications in areas like finance, real estate, insurance, etc. For example, imagine an insurance company. If you purchase flight delay insurance, normally you would need to submit paperwork and wait for the insurance company's approval when your flight is delayed. But with a smart contract-based insurance system, as soon as your flight info is confirmed as delayed, the smart contract would automatically execute and instantly pay you the compensation. This makes the whole process much simpler, more efficient and transparent.</p>
<p>Smart contracts are self-executing, blockchain-based digital contracts. They can streamline processes, improve efficiency and ensure transaction security in many different scenarios.</p>
<h2 id="dapp-1"><a class="header" href="#dapp-1">DApp</a></h2>
<p>A DApp (Decentralized Application) is an application that runs on a blockchain network and is not controlled by any centralized entity. This means that no single company or individual can fully control it. The design of DApps makes them more secure, transparent and reliable because their data and operations are based on blockchain technology, which is a decentralized, tamper-proof distributed database.</p>
<p>Imagine you are using a centralized social media platform (such as Facebook or Twitter). These platforms control your data and privacy, and they can arbitrarily change rules, censor content or even sell your information. DApps, on the other hand, provide you with a decentralized social media platform that is not controlled by any centralized entity, allowing you to manage your own data and privacy.</p>
<p>A great example of a DApp is a cryptocurrency exchange. In traditional centralized exchanges (such as Coinbase or Binance), users' funds and transaction information are stored on the exchange's servers. However, decentralized exchanges (DEXs, such as Uniswap) are DApps based on blockchain technology that allow users to directly trade digital currencies without involving a third party. In this way, users can enjoy higher privacy and autonomy while keeping their funds secure.</p>
<p>In addition to exchanges, DApps have many other use cases such as decentralized finance (DeFi) platforms, games, markets, etc. These decentralized applications provide users with a freer, more secure and transparent Internet environment.</p>
<p>DApps are decentralized applications based on blockchain technology that are free from the control of centralized entities. By using DApps, users can better protect their data and privacy while enjoying higher security and transparency. DApps are a key part of the Web3 era, and together they help build a fairer, more secure Internet future.</p>
<h2 id="all-in--show-hand"><a class="header" href="#all-in--show-hand">All in / Show hand</a></h2>
<p>Going all in on something or betting everything you have. In poker, &quot;all in&quot; or &quot;show hand&quot; refers to a player betting all of their chips. It's a high-risk, high-reward strategy because a player can either win all of their opponents' chips at once or lose all of their chips.</p>
<p>Imagine you're participating in a game of Texas Hold'em. Players sit around a table with chips in their hands. In each round of the game, you need to determine your chances of winning based on the cards in your hand and the public cards on the table. If you think your hand is very good and you have a high chance of winning, you may choose to go &quot;all in&quot; and bet all your chips. This way, you may win the pot for that round or scare other players into not following suit.</p>
<p>However, going &quot;all in&quot; also carries a lot of risk. If your opponent has a better hand, you could lose all your chips and be eliminated. Therefore, going &quot;all in&quot; is a strategy that requires careful consideration by the player. Before deciding to go &quot;all in&quot;, you need to weigh factors such as the odds of winning, the size of the pot, the behaviour patterns of your opponents, etc.</p>
<p>In addition, the concept of &quot;all in&quot; is often used in real life to describe an attitude of taking risks and putting all your effort into something. When a person puts all their savings and energy into their own business venture at a crucial moment to pursue success or achieve their dreams, we can also say that they have gone &quot;all in&quot;. For example, an entrepreneur who decides to invest all of their savings and efforts into their own business project demonstrates an &quot;all in&quot; spirit.</p>
<p>&quot;All in&quot; or &quot;show hand&quot; is a term originating from poker that refers to a player betting all their chips. It is both a high-risk, high-reward strategy and an attitude of daring to take risks and forge ahead. In real life, the &quot;all in&quot; spirit encourages us to courageously pursue our goals at critical moments, overcome difficulties and give it our all.</p>
<h2 id="ecdsa"><a class="header" href="#ecdsa">ECDSA</a></h2>
<p>ECDSA (Elliptic Curve Digital Signature Algorithm) is an encryption technology used to ensure data security and integrity. Its principle is to generate a pair of keys: a public key and a private key, through elliptic curve cryptography. The public key is open and can be shared with others, while the private key is kept secret and known only to the key owner. This encryption method can help us securely send information over the network and verify the source of data.</p>
<p>Imagine you are sending a letter to a friend. To ensure the security of the letter, you need to put it in a locked box. In this example, ECDSA is like a special lock: lock the box with your private key, and this lock can only be opened with your public key. This way, when your friend receives the letter, they can use your public key to open the box, verify that the letter was sent from you and has not been tampered with.</p>
<p>ECDSA has a wide range of applications in cryptocurrencies and blockchain technology. Cryptocurrencies such as Bitcoin and Ethereum use ECDSA as their encryption and digital signature standard. In these systems, a user's private key is used to sign transactions, while the public key is used to verify transactions. This ensures the security and integrity of transactions and prevents others from forging or tampering with transactions.</p>
<p>An important feature of ECDSA is that it provides a high level of security while requiring relatively low computing resources and storage space. This makes it very useful in cryptocurrencies and other security-sensitive applications. However, ECDSA also has some limitations, such as its inability to resist quantum computing attacks. Therefore, as technology progresses, new encryption methods may be needed in the future to protect our data security.</p>
<p>ECDSA is an encryption technology based on elliptic curve cryptography to ensure data security and integrity. It plays an important role in network communication and cryptocurrencies, helping us protect information and verify the source of data. Although it has certain limitations, ECDSA remains a key encryption technology for many current applications.</p>
<h2 id="bls"><a class="header" href="#bls">BLS</a></h2>
<p>BLS (Boneh-Lynn-Shacham) signature is an encryption technology whose main advantage is the ability to achieve highly efficient aggregate signatures. This means that multiple signatures can be aggregated into a single signature, greatly reducing storage and transmission overhead. BLS signatures have been widely used in blockchain, distributed systems and cryptography research.</p>
<p>Suppose a group of people work together to complete a project, and each person needs to sign the project report. In traditional signature methods, each person needs to sign the report separately, which takes up a lot of space. However, using BLS signatures, this group of people can aggregate their signatures into a compact signature, greatly reducing the volume of the report. This way, the verifier only needs to check this aggregate signature to ensure that all participants have signed.</p>
<p>BLS signatures have important applications in the blockchain field, especially in some decentralized consensus algorithms, such as Ethereum 2.0's consensus protocol. In these systems, nodes need to sign transactions or blocks to express their consensus. By using BLS signatures, the signatures of multiple nodes can be aggregated into one signature, thereby reducing network transmission and storage overhead. This helps to improve the scalability and performance of the blockchain.</p>
<p>BLS signature is an efficient encryption technology that can aggregate multiple signatures into a compact signature. This method saves storage space and transmission bandwidth and improves system performance. In the fields of blockchain and distributed systems, BLS signatures play an important role in enabling more efficient and scalable consensus mechanisms.</p>
<h2 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle Tree</a></h2>
<p>A Merkle tree is a tree data structure used to store and verify data integrity. You can think of it as a tree where each node has a hash value calculated from the hash values of its child nodes. The bottom layer (leaf nodes) of the tree stores the hash values of the actual data.</p>
<p>For example, suppose we have four files: A, B, C and D. We first calculate the hash values of these four files, resulting in hash values HA, HB, HC and HD. Then we combine these hash values in pairs and calculate their hash values, e.g. combine HA and HB to calculate the new hash value HAB; similarly, combine HC and HD to get the hash value HCD. Finally, we combine HAB and HCD to get the root node hash value HABCD. In this way, the entire Merkle tree is constructed.</p>
<p>So what are the advantages of Merkle trees? First, it can quickly verify data integrity. To check if file A has been tampered with, we only need to calculate the hash value of A and then verify that the root node hash value is correct through the other nodes of the tree (such as HB and HCD). In this way, we can check the integrity of the data without obtaining the complete data. This is very useful for distributed systems and blockchain technologies.</p>
<p>Second, Merkle trees can also efficiently improve data storage efficiency. Because each node stores the hash values of its child nodes, we can calculate the hash values layer by layer to find a piece of data. This avoids the time consumption of traversing the entire dataset.</p>
<p>In summary, the Merkle tree is a very practical data structure that can efficiently verify and store data, especially suitable for distributed systems and blockchain technologies. Like a tree, the root node contains the information of the whole tree, and by simply calculating hash values, we can easily ensure data integrity.</p>
<h2 id="gas-fee"><a class="header" href="#gas-fee">Gas fee</a></h2>
<p>When you want to complete a transaction or call a smart contract on the blockchain network, you need to pay a certain fee. This fee is called the gas fee.</p>
<p>Why is this fee required? This is to provide some incentives for the &quot;miners&quot; who provide computing power to the blockchain network. Miners are responsible for verifying transactions, ensuring the legality of transactions, and bundling transactions into blocks. To incentivize them to work, users need to pay gas fees to them.</p>
<p>The price of gas fees on Ethereum fluctuates depending on the volume of transactions on the network. When many people are using the blockchain network, gas fees will rise, just like taxi fares become more expensive during rush hour traffic. You can set the price of gas fees yourself, but note that if you set the price too low, miners may be unwilling to prioritize your transaction, leading to transaction delays or even failures.</p>
<p>On IC, gas fees are fixed and do not fluctuate arbitrarily with the network. Ordinary users can generally ignore gas fees. Learn more about gas fees here.</p>
<h2 id="decentralized-finance-defi"><a class="header" href="#decentralized-finance-defi">Decentralized Finance (DeFi)</a></h2>
<p>DeFi (Decentralized Finance) is a financial service model based on blockchain technology. It aims to eliminate centralized institutions such as banks, exchanges and insurance companies in the traditional financial system. By utilizing smart contracts and cryptocurrencies, DeFi provides users with a more transparent, open and reliable financial service model.</p>
<p>For example, if you need a loan to purchase a new car. In the traditional financial system, you need to apply to a bank, and the bank will decide whether to approve your loan based on your credit score and income. This process can be both time-consuming and complicated. It can be even more difficult for those without a credit history or unable to provide sufficient collateral.</p>
<p>However, in the DeFi system, you can apply for a loan through a decentralized lending platform. This platform is not operated by a centralized institution but based on blockchain technology and smart contracts. You only need to pledge a certain amount of cryptocurrency as collateral to get a loan immediately without going through a cumbersome review process. In addition, DeFi platforms can also allow you to view the status and interest of the loan at any time, providing higher transparency.</p>
<p>DeFi is not limited to lending services. It also includes a series of financial products and services such as decentralized exchanges (DEX), stablecoins, asset management, prediction markets, etc. These services allow users to trade and invest directly on the blockchain without relying on traditional financial institutions.</p>
<p>DeFi is a financial service model based on blockchain technology. It aims to eliminate centralized institutions in the financial system and provide more transparent, open and reliable financial services. Whether in lending, trading or investment, DeFi promises to change our perception of financial services and make financial markets more inclusive and efficient.</p>
<h2 id="liquidity-providers-and-liquidity-pools"><a class="header" href="#liquidity-providers-and-liquidity-pools">Liquidity Providers and Liquidity Pools</a></h2>
<p>Liquidity providers (LPs) play an important role in the decentralized finance (DeFi) market. They help improve market liquidity by injecting assets into exchanges or decentralized platforms. In short, liquidity providers are like &quot;plumbers&quot; in the financial market. They ensure the smooth flow of funds in the market so that participants can easily trade.</p>
<p>For example, if there are many fruit stalls in the market. Customers can freely buy fruit between these stalls. However, to ensure that customers can find the fruit they want, the stall owners need to maintain sufficient inventory. This is the role of liquidity providers: they provide goods (assets in the financial market) to the market to meet trading needs.</p>
<p>In the decentralized finance market, liquidity providers typically inject their assets into a smart contract called a &quot;liquidity pool&quot;. These assets can be cryptocurrencies, tokens, etc. By injecting assets into the liquidity pool, liquidity providers help platform users trade, such as token swaps and lending.</p>
<p>In return, liquidity providers can earn income from transaction fees. This is like fruit stand owners earning profits by selling fruit. In addition, some decentralized finance platforms will also issue reward tokens to liquidity providers to incentivize them to participate and improve market liquidity.</p>
<p>However, liquidity providers also face certain risks, such as &quot;impermanent loss&quot;. This risk stems from fluctuations in the prices of assets in the liquidity pool, which may cause liquidity providers to lose value when redeeming assets. Therefore, before becoming a liquidity provider, you need to carefully evaluate the potential risks and rewards.</p>
<p>Liquidity providers play an important role in the decentralized finance market. By injecting assets into the market, they improve trading liquidity so that participants can trade smoothly. In return, liquidity providers can earn income from transaction fees and reward tokens. But at the same time, they also need to pay attention to potential risks such as impermanent loss.</p>
<h2 id="automated-market-maker-amm"><a class="header" href="#automated-market-maker-amm">Automated Market Maker (AMM)</a></h2>
<p>Automated Market Maker (AMM) is an algorithm used in decentralized finance (DeFi) exchanges to ensure liquidity in the market. Unlike traditional exchanges, AMM does not require matching buyers and sellers. Instead, AMM automatically calculates the transaction price of assets using a predetermined mathematical formula.</p>
<p>AMM is implemented through smart contracts and liquidity pools. A liquidity pool consists of assets injected by liquidity providers, and users can exchange assets within these pools. When a user wants to exchange two assets, AMM calculates the exchange ratio based on a predefined mathematical formula. This ratio is adjusted in real time as transactions occur to maintain market balance.</p>
<p>Uniswap is a typical decentralized exchange that adopts the AMM algorithm. It uses a formula called \(x * y = k\) to determine the transaction price. In this formula, x and y represent the quantities of the two assets in the liquidity pool, and k is a constant value. When users trade in the pool, the quantities of x and y change, but the value of k remains constant. This ensures that the transaction price automatically adjusts to maintain market balance.</p>
<p>Suppose we have a decentralized exchange with an AMM-based liquidity pool that allows users to exchange two tokens (Token A and Token B). We use the Uniswap formula \(x * y = k\) as the AMM algorithm.</p>
<p>First, liquidity providers inject Token A and Token B into the pool. Let's say initially there are 1000 Token A and 1000 Token B in the pool. Per the AMM formula: </p>
<p>$$
x*y=k
$$</p>
<p>$$
1000*1000=1,000,000
$$</p>
<p>Here the constant k equals 1,000,000.</p>
<p>Now suppose a user wants to purchase Token B with 100 Token A. They will inject 100 Token A into the pool, changing the Token A quantity to 1100. To keep k constant, we recalculate Token B's quantity per the formula:</p>
<p>$$
1100*y=1,000,000
$$</p>
<p>$$
y‚âà909.09
$$</p>
<p>So now there are about 909.09 Token B left in the pool. The user got about 90.91 Token B (1000 - 909.09) for 100 Token A. Additionally, trading fees (if any) are awarded to liquidity providers. </p>
<p>In this process, the AMM automatically adjusted the exchange rate of Token A and Token B based on the preset formula. As trades occur, prices adjust in real-time to maintain market equilibrium. This is how AMMs work at a basic level. </p>
<p>Note this is a simplified example - actual implementations may involve additional details like fees, slippage, etc. But it should give you a good grasp of AMM's core concepts and mechanics.</p>
<p>AMMs provide advantages like simplified trading, increased liquidity, and reduced latency. However, they also have downsides like potential impermanent loss and price slippage.</p>
<p>In summary, AMM is an algorithm used in DeFi exchanges to ensure trading liquidity via smart contracts and liquidity pools. AMMs can automatically calculate asset prices to simplify trading and reduce latency. While AMMs have merits, potential risks should also be watched out for when using them.</p>
<h2 id="gamefi"><a class="header" href="#gamefi">GameFi</a></h2>
<p>GameFi is the abbreviation of &quot;Game Finance&quot;. It refers to the emerging trend of applying decentralized finance (DeFi) and blockchain technology to the gaming industry. In short, GameFi is an innovative way to combine gaming and finance, allowing players to earn income in virtual worlds while playing games.</p>
<p>Imagine that you are playing an adventure game and have obtained some virtual items and currencies in the game by completing tasks, fighting monsters, etc. Typically, these items and currencies can only be used within the game. However, in the GameFi world, these virtual items and currencies can be converted into real-world value. This is because the items and currencies in the game are often represented by cryptocurrencies (such as NFTs, non-fungible tokens) with uniqueness and scarcity, which can be traded on the blockchain.</p>
<p>Let's use a simple analogy to illustrate the GameFi concept. Imagine you are playing a &quot;pet raising&quot; game where each pet is a unique NFT. By taking care of and nurturing the pet, you can increase the attributes and skills of the pet, thereby increasing its value. In a GameFi environment, you can sell these pets in in-game or out-of-game markets in exchange for other players' cryptocurrencies. These cryptocurrencies can be traded on the blockchain and even exchanged for fiat currencies. This way, you can earn income while enjoying the fun of the game.</p>
<p>In addition, GameFi also encourages players to participate in game governance and ecosystem building. For example, by holding governance tokens in the game, players can participate in decision-making on the future direction and rule-setting of the game. This helps to establish a decentralized and shared game world where players become true stakeholders.</p>
<p>GameFi is an emerging trend of applying decentralized finance and blockchain technology to the gaming industry. It combines gaming and finance, allowing players to earn income in virtual worlds and participate in game governance and ecosystem building. This mode brings new business models and revenue opportunities to the gaming industry, while providing players with more participation and value.</p>
<h2 id="socialfi"><a class="header" href="#socialfi">SocialFi</a></h2>
<p>SocialFi is an emerging field that combines social media and decentralized finance (DeFi). By integrating social networks and financial tools, it provides users with more convenient, interesting and personalized financial services. The goal of SocialFi is to make financial services more socialized while utilizing the advantages of decentralization, security and transparency brought by blockchain technology.</p>
<p>To help you better understand SocialFi, we can metaphore it as a financial social party. At this party, you can not only communicate with friends and family, but also participate in various financial activities together, such as investment, lending and trading. In this way, financial services become more friendly and fun.</p>
<p>A typical application of SocialFi is social tokens. Social tokens are cryptocurrencies issued by communities or individuals that represent the value and trust between community members. Users can participate in community activities by purchasing, holding and trading these tokens, such as voting, obtaining privileges or sharing profits. For example, a musician can issue his own social tokens, fans buy these tokens to support the musician, and get privileges like albums, concert tickets, etc.</p>
<p>In addition, SocialFi also includes a series of social network-based financial tools and services, such as decentralized prediction markets, social investment portfolios, and community governance. These tools and services make the financial market more transparent, fair and inclusive, allowing more people to participate and benefit.</p>
<p>SocialFi is an emerging field that combines social media and decentralized finance. By integrating social networks and financial tools, SocialFi provides users with more convenient, interesting and personalized financial services. It is expected to change our perception of financial services and make the financial market more socialized, fair and inclusive.</p>
<h2 id="multi-party-computation-mpc"><a class="header" href="#multi-party-computation-mpc">Multi-party computation (MPC)</a></h2>
<p>Multi-party computation (MPC) is a cryptographic protocol that allows multiple nodes that don't trust each other to jointly compute something without revealing their private inputs.</p>
<p>Let's take a simple example with Alice, Bob and Carol who want to compute the sum of their account balances but don't want to reveal their individual balances to each other.</p>
<p>They can use a MPC protocol where each party performs encrypted computations using their private data, exchanges intermediate results, and after multiple rounds of calculation, the final result - the sum of all three account balances - can be obtained without any party knowing the inputs of the others.</p>
<p>In blockchains, MPC is mainly used to manage private keys. The private key is split into fragments and held by multiple nodes separately. To use this private key, a threshold number of nodes need to participate in the computation to reconstruct the key.</p>
<p>This distributed approach to private key management ensures both security of the keys and prevents any single node from having full control over the assets.</p>
<p>MPC increases decentralization in blockchain systems since multiple nodes participate in computation and validation rather than relying on a single central node. This enhances the security and reliability of blockchains.</p>
<p>In short, MPC is like a cryptographic technique that allows nodes to perform computations blindly, protecting privacy while maintaining system reliability.</p>
<h2 id="wallet-1"><a class="header" href="#wallet-1">Wallet</a></h2>
<p>A blockchain wallet is a tool for storing users' digital assets - simply put, it serves as a bank account in the blockchain world.</p>
<p>For example, if you want to hold and use Bitcoin, you'll need a Bitcoin wallet. This wallet will provide you with a Bitcoin address, similar to a bank account number. You can receive Bitcoins to this address and also send Bitcoins from this address to others. The wallet helps you securely manage the assets in this address.</p>
<p>Take an Ethereum wallet for another example. It stores not only Ether but various ERC-20 token assets, like a digital asset account for multiple cryptocurrencies. You can receive and send different tokens using the wallet address.</p>
<p>The wallet is also responsible for private key management. It uses cryptography to generate the public and private keys. The public key is used to derive the blockchain address, while the private key is used to authorize transactions. Wallet software will require users to set a password to encrypt and protect the private key.</p>
<p>In summary, just like a physical wallet stores banknotes, a blockchain wallet stores digital assets. It enables users to securely control their digital assets and is an essential tool to enter the blockchain world. However, it's not advisable to store large amounts of assets in a wallet. Reliable third-party custody services should be used instead.</p>
<h2 id="token"><a class="header" href="#token">Token</a></h2>
<p>A token is a digital asset based on blockchain technology, usually used to represent a certain value or right. In the cryptocurrency world, tokens can be used to exchange goods, services or as investment tools. Unlike cryptocurrencies (such as Bitcoin, Ethereum, etc.), tokens are usually created based on existing blockchain platforms (such as Ethereum) rather than having independent blockchain networks.</p>
<p>The applications of tokens are wide-ranging, including: Utility Tokens are used to access specific services or applications; Governance Tokens are used to participate in project decision making; and Security Tokens represent ownership of real assets (such as stocks, real estate, etc.). Therefore, when investing in tokens, understanding the underlying project and value is very important.</p>
<h2 id="whale"><a class="header" href="#whale">Whale</a></h2>
<p>A whale refers to an investor who holds a large amount of digital currencies or tokens. These investors have very large assets, so their trading behavior may have a significant impact on market prices. When whales buy or sell large amounts of tokens, market prices may rise or fall rapidly, attracting the attention and following of other investors.</p>
<h2 id="did-decentralized-identity"><a class="header" href="#did-decentralized-identity">DID (Decentralized Identity)</a></h2>
<p>When talking about DID (Decentralized Identity) in blockchain, you can think of it as a digital identity credential that can help us securely verify and manage personal identity information on the Internet. Traditional identity verification methods usually require trusted third-party institutions, such as banks or governments, but DID uses blockchain technology to make the identity verification process more decentralized and transparent.</p>
<p>A DID is a unique identifier consisting of a long string of numbers and letters, similar to your identity card number in real life. However, unlike ID cards, DIDs are not issued by a central authority but are self-created and controlled by individuals. This means you can manage and control your own identity information without an intermediary.</p>
<p>For example, imagine that you want to register an account on an online social platform. Typically, you need to provide a lot of personal information, including name, address, phone number, etc., and then submit this information to the platform for verification and storage. However, this approach poses risks to privacy and security because you do not have full control over your data.</p>
<p>Using a DID, you can create your own digital identity and store the required verification information on the blockchain. The platform only needs to verify that your DID is valid without directly accessing your personal information. This way, your identity information is not centrally stored in one place but is dispersedly stored on different nodes of the blockchain, greatly reducing the risk of data being hacked or misused by hackers.</p>
<p>In addition, DID allows you to reuse your identity information in different scenarios. Imagine that you want to rent a car, usually you need to provide documents such as a driver's license, credit card, and other identity information. But with a DID, you only need to go through one verification process, and then use your digital identity for authentication in multiple scenarios, from car rental companies to hotels to airlines, avoiding the hassle of repeatedly filling in and verifying personal information.</p>
<p>In summary, DID is an innovative digital identity verification method that enables decentralized and secure management of personal identity information through blockchain technology. It provides higher privacy protection and convenience to the Internet, allowing individuals to better control their own identity data.</p>
<h2 id="kyc"><a class="header" href="#kyc">KYC</a></h2>
<p>KYC stands for &quot;Know Your Customer&quot;. In the digital currency and crypto asset space, KYC typically refers to the process where users are required to provide identity information for verification by trading platforms to prevent money laundering and other illicit activities. </p>
<p>For example, when registering for a cryptocurrency exchange account, the platform will ask you to provide ID cards, passports and other documents to confirm your identity through facial recognition and other technologies. This is a KYC process.</p>
<p>The purpose of implementing KYC is to enable trading platforms to identify their users and ensure fund flows are legal and transparent. Otherwise it can easily be taken advantage of for money laundering or funding criminal activities. So any new user entering the crypto asset market needs to go through KYC screening.</p>
<p>Over time, KYC rules have also become more stringent. Some platforms may only need your name and phone number to open an account initially, but mainstream platforms now require uploading ID photos, recording videos, etc. The KYC process also often takes some time to complete verification. </p>
<p>In summary, KYC is a necessary security measure for digital asset platforms to ensure regulatory compliance in asset trading. Users need to cooperate and provide authentic information to foster a healthy trading environment.</p>
<h2 id="ama"><a class="header" href="#ama">AMA</a></h2>
<p>AMA stands for &quot;Ask Me Anything.&quot; It typically refers to a question and answer interactive activity between project teams and users in crypto communities. </p>
<p>For example, before a new project is launched, the project team may host an AMA event in their community and announce a time. Users can then ask anything about the project, and the team will come back at the scheduled time to answer user questions one by one.</p>
<p>This process is like a face-to-face conversation - users act as the questioners, while the project team serves as the answer provider. The interaction between the two sides is quite active. Users can ask freely about the motivation behind the project, technical architecture, business plans, etc., and the team tries to answer as comprehensively as possible. </p>
<p>Through this method, both the project and community users can gain better understanding of each other, and users feel more engaged in the project. Some projects may host AMAs periodically for users to ask questions anytime. This high level of transparent communication also helps projects gain user trust.</p>
<p>In summary, AMA is an open and efficient communication channel between projects and users. It helps shorten the distance between the two sides, allows users to learn more in-depth about the project, and assists project teams in gathering user feedback to improve the project. This benefits the healthy growth of both the project and community.</p>
<h2 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h2>
<p>It is the development plan outline formulated by project teams. It visually demonstrates a project's development path to let community users know what the project will do next. </p>
<p>Let's take a simple example of a roadmap for a digital collectibles trading platform:</p>
<p>Phase 1: Establish platform, implement basic collectible minting and trading functions. </p>
<p>Phase 2: Add off-chain trading functions for collectibles, support more blockchain networks.</p>
<p>Phase 3: Develop mobile App to allow trading through mobile phones. </p>
<p>Phase 4: Integrate DEX to enable exchange between collectibles and other tokens.</p>
<p>Phase 5: Launch NFT lending system for users to get funds by staking NFTs.</p>
<p>Through these simple steps, users can clearly understand the development path planned for this platform - what the team will work on, what new features will be launched.</p>
<p>The roadmap serves like a blueprint for the future, guiding teams to develop products and achieve goals in a planned direction. It can also boost community users' confidence by letting them know the project is worth long-term investment. Meanwhile, project teams need to make steady progress following the roadmap, fulfill promises made in it, and maintain community confidence.</p>
<h2 id="whitepaper"><a class="header" href="#whitepaper">Whitepaper</a></h2>
<p>A whitepaper is a detailed technical and operational proposal published by project teams. It serves like a charter document for a project, comprehensively introducing information including technical frameworks, operational models, team backgrounds, etc. </p>
<p>In short, a whitepaper is like an instruction manual for a project that allows investors and users to fully understand its underlying logic.</p>
<p>For example, the whitepaper of a new blockchain project would introduce:</p>
<ul>
<li>
<p>The problems it aims to solve and positioning </p>
</li>
<li>
<p>Technical principles such as consensus mechanisms, incentive schemes, etc.</p>
</li>
<li>
<p>Governance structure and roadmap</p>
</li>
<li>
<p>Token distribution and circulation models</p>
</li>
<li>
<p>Team background and advisor information</p>
</li>
</ul>
<p>Through the whitepaper, users can clearly understand the technological innovations of the project and compare its advantages and disadvantages to similar projects.</p>
<p>Project teams need to put in significant efforts to write and update whitepapers to fully account for technical details. It is an important benchmark to evaluate a blockchain project's professionalism and rigor. Generally, higher-quality whitepapers also help projects gain more attention.</p>
<p>In summary, a whitepaper is the foundation for community members to deeply understand a project, and its quality directly affects the professional recognition the project can gain externally.</p>
<h2 id="seed-phrase"><a class="header" href="#seed-phrase">Seed Phrase</a></h2>
<p>A seed phrase is a group of 12 to 24 words that is used to recover access to an encrypted cryptocurrency wallet. When you create a new digital wallet, the system generates a unique seed phrase derived from the private key. So it is as important as the private key. These words are like keys that allow you to control and access the assets in your wallet.</p>
<p>Note that the seed phrase is extremely important! Be sure to keep it safe and avoid disclosing it to others. Once someone else gets your seed phrase, they can easily control your assets. For security, it is recommended to write down the seed phrase on paper and keep it in a safe place.</p>
<h2 id="ido"><a class="header" href="#ido">IDO</a></h2>
<p>IDO (Initial DEX Offering) is a way for cryptocurrency projects to raise funds. It is similar to IPO (Initial Public Offering) in traditional stock markets, but it occurs on decentralized exchanges (DEXs). The purpose of IDO is to raise funds for new projects and provide liquidity and initial pricing for project tokens.</p>
<p>Let's use a simple analogy to understand IDO. Imagine that a startup company (such as an innovative cryptocurrency project) wants to raise funds to support its business development. In the traditional stock market, this company can choose to conduct an IPO to sell its stocks to the public. In the cryptocurrency market, this company can choose to conduct an IDO to sell its tokens to the public through decentralized exchanges.</p>
<p>The general process of conducting an IDO is as follows:</p>
<ol>
<li>The project party selects a decentralized exchange to conduct the IDO. This exchange needs to provide a platform for initiating IDOs, such as PancakeSwap, Uniswap, etc.</li>
<li>The project party determines the conditions of the IDO, including token price, total issuance, fundraising goals, etc. This information needs to be publicly transparent to allow investors to understand the basic information about the project.</li>
<li>When the IDO begins, investors can purchase tokens issued by the project party. This process is usually first come, first served, and purchase limits are sometimes set to prevent a single investor from occupying a large number of tokens.</li>
<li>After the IDO ends, the project party will use the raised funds for project development, marketing, etc. At the same time, tokens held by investors can be traded on decentralized exchanges. In this way, the token price is determined by the market supply and demand, forming a free market price.</li>
</ol>
<p>IDO is a way for cryptocurrency projects to raise funds on decentralized exchanges. Through IDO, new projects can raise funds, distribute tokens, and provide liquidity and initial pricing for tokens. Compared to traditional IPOs, this approach has advantages such as lower barriers, higher transparency and faster trading speed. However, IDO may also bring higher risks because the cryptocurrency market is relatively new and there may be deficiencies in regulation and market stability. When participating in IDO, investors need to carefully evaluate the potential value and risks of the project.</p>
<h2 id="ico"><a class="header" href="#ico">ICO</a></h2>
<p>ICO (Initial Coin Offering) is a way for cryptocurrency projects to raise funds, similar to IPO (Initial Public Offering) in traditional stock markets. Through ICO, new projects can raise funds to support their development and issue tokens to investors. These tokens often have certain utility, such as using within the project's ecosystem or as governance interests.</p>
<p>For example, imagine that a startup company (such as a cryptocurrency project) wants to raise funds to support its business development. In the traditional stock market, this company can choose to conduct an IPO to sell its stocks to the public. In the cryptocurrency market, this company can choose to conduct an ICO to sell its tokens to the public.</p>
<p>The general process of conducting an ICO is as follows:</p>
<ol>
<li>The project party publishes a white paper detailing the background, goals, technical architecture and other information about the project. The purpose of the white paper is to allow investors to understand the basics of the project and evaluate its potential value.</li>
<li>The project party determines the terms of the ICO, including token price, total issuance, fundraising goals, etc. This information needs to be publicly transparent to allow investors to understand the basics of the project.</li>
<li>When the ICO begins, investors can purchase tokens issued by the project party. This process is usually first come, first served, and purchase limits are sometimes set to prevent a single investor from occupying a large number of tokens.</li>
<li>After the ICO ends, the project party will use the raised funds for project development, marketing, etc. At the same time, tokens held by investors can be traded on cryptocurrency exchanges. In this way, the token price is determined by the market supply and demand, forming a free market price.</li>
</ol>
<p>ICO is a way for cryptocurrency projects to raise funds. Through ICO, new projects can raise funds, distribute tokens, and provide liquidity for tokens. Compared with traditional IPOs, this approach has advantages such as lower barriers, higher transparency and faster trading speeds. However, at the same time, ICO may also bring higher risks because the cryptocurrency market is relatively new and there may be deficiencies in regulation and market stability. When participating in ICO, investors need to carefully evaluate the potential value and risks of the project.</p>
<h2 id="ipo"><a class="header" href="#ipo">IPO</a></h2>
<p>An IPO (Initial Public Offering) is the process by which a company first offers its stocks for sale to the public on the stock market. Through IPO, a company can raise funds to support its business development while providing an investment opportunity for investors. IPO is an important way to turn a private company into a publicly listed company.</p>
<p>Let's use a simple analogy to understand IPO. Imagine that you and your friends created a company. Initially, the company only belonged to a few founders. Over time, the company succeeded and business expanded continuously. You decided to raise more funds to support the sustained development of the company. One feasible method is to sell the company's stocks to the public through IPO on the stock market. This way, the company can raise funds while investors have the opportunity to share in the company's future profits.</p>
<p>The general process of conducting an IPO is as follows:</p>
<ol>
<li>The company decides to conduct an IPO and hires investment banks and other professional institutions to prepare for the IPO. This includes writing a prospectus, auditing financial statements, etc.</li>
<li>The company submits the prospectus and related documents to regulators, such as the U.S. Securities and Exchange Commission (SEC). The regulators will review the submitted documents to ensure that they meet regulatory requirements.</li>
<li>After the review is approved, the company determines the details of the IPO, including stock issue price, issue quantity, listed exchange, etc.</li>
<li>When the IPO begins, investors can purchase stocks issued by the company. Typically, the initial price of stocks is jointly determined by investment banks and the company, while the subsequent stock price is determined by the market supply and demand.</li>
<li>After the IPO ends, the company successfully goes public, and its stocks are publicly traded on the exchange. Investors can buy and sell company stocks to share in the company's growth and profits.</li>
</ol>
<p>In summary, an IPO is the process by which a company first offers its stocks for sale to the public on the stock market. Through IPO, a company can raise funds to support business development while providing investors with an opportunity to share profits. Companies conducting IPOs need to follow strict regulatory requirements and review processes to ensure that investors' interests are protected.</p>
<h2 id="otc"><a class="header" href="#otc">OTC</a></h2>
<p>OTC (Over-The-Counter) refers to transactions conducted outside of exchanges. Unlike transactions conducted on exchanges, OTC transactions are usually conducted directly between the parties without going through a central exchange. This trading method is applied to financial products such as stocks, bonds, derivatives, etc.</p>
<p>If you want to buy a used car. Buying on an exchange is like going to an organized used car market where there are many sellers, buyers and intermediaries (such as exchanges) involved, and the prices and trading rules are standardized and public. Conducting OTC transactions is like buying a used car through private channels. You can communicate directly with the car owner to negotiate the price and trade terms.</p>
<p>The characteristics of OTC transactions are:</p>
<ul>
<li>Flexibility: OTC transactions allow the parties to freely negotiate the terms of the transaction according to their own needs, such as price, quantity, settlement method, etc. This flexibility makes OTC transactions more attractive in some cases.</li>
<li>Privacy: OTC transactions are not as publicly transparent as transactions on exchanges. The parties can maintain the privacy of the transaction. This may be beneficial in some cases, such as large transactions, sensitive information transactions, etc.</li>
<li>Risk: Because OTC transactions do not go through the central exchange, the credit risk between the parties may be higher. To reduce risks, participants may need to conduct additional credit investigations or use third-party guarantee institutions.</li>
<li>Regulatory difficulty: The decentralization of OTC transactions makes regulation more difficult. Therefore, in some cases, OTC transactions may be more susceptible to manipulation, fraud and other misconduct.</li>
</ul>
<p>OTC is a trading method conducted outside of exchanges with features such as flexibility and privacy. However, at the same time, OTC transactions may also bring higher risks and regulatory difficulties. When participating in OTC transactions, investors need to fully understand the counterparty, assess credit risks, and ensure compliance with relevant laws and regulations.</p>
<h2 id="c2c"><a class="header" href="#c2c">C2C</a></h2>
<p>C2C (Consumer-to-Consumer) is a model of direct transactions between consumers, usually conducted through online platforms. C2C platforms act as intermediaries between buyers and sellers, helping consumers find, evaluate and contact other consumers online to complete transactions.</p>
<p>For example, if you want to sell your old bicycle. In the C2C model, you can post an advertisement online describing the condition and price of the bicycle. After other consumers see your advertisement, they can contact you to negotiate the transaction details. In this process, you and the buyer transact directly without going through a merchant or other intermediary. (Xianyu, Zhuazhua Market)</p>
<p>The characteristics of C2C transactions are:</p>
<ul>
<li>Decentralization: C2C transactions are conducted directly between consumers without going through merchants and other intermediaries. This helps reduce transaction costs and allows buyers and sellers to get better prices.</li>
<li>Convenience: C2C platforms usually adopt online operations, allowing consumers to buy and sell anytime, anywhere. This convenience makes C2C transactions more attractive in some cases.</li>
<li>Diversity: There are a wide variety of goods and services on C2C platforms. Consumers can purchase various types of products on the same platform. This diversity makes C2C transactions more rich and interesting.</li>
<li>Risk: Because C2C transactions do not go through merchants, transaction security may be lower. To reduce risks, consumers need to evaluate counterparties and use secure payment methods. At the same time, the platform party also needs to take certain measures, such as real-name registration, credit rating, etc., to ensure transaction security.</li>
</ul>
<p>C2C is a mode of direct transactions between consumers, usually conducted through online platforms. C2C transactions have the characteristics of decentralization, convenience and diversity, which can enable buyers and sellers to get better prices. However, at the same time, C2C transactions may also carry higher risks. When participating in C2C transactions, consumers need to fully understand the counterparty, evaluate transaction security and ensure compliance with relevant laws and regulations.</p>
<h2 id="dex"><a class="header" href="#dex">DEX</a></h2>
<p>DEX (Decentralized Exchange) is a blockchain-based trading platform that allows users to directly trade cryptocurrencies without a centralized intermediary. Unlike traditional centralized exchanges, DEX does not hold user assets, but completes transactions directly between user cryptocurrency wallets.</p>
<p>The characteristics of DEX transactions are:</p>
<ul>
<li>Decentralization: DEX does not hold user assets, transactions are completed directly between user cryptocurrency wallets. This helps reduce trust risk and improve asset security.</li>
<li>Transparency: Because it is based on blockchain technology, DEX transaction records are public and can be queried at any time. This transparency makes DEX transactions fairer and more impartial.</li>
<li>Privacy: DEX allows users to trade without revealing their identity, increasing trade privacy. However, this may also lead to some regulatory difficulties.</li>
<li>Speed and efficiency: Due to its decentralized nature, DEX transactions may be slower and less efficient than centralized exchanges. To increase transaction speed, DEX needs to adopt some technical optimizations, such as off-chain expansion, cross-chain interoperability, etc.</li>
</ul>
<p>DEX is a decentralized exchange based on blockchain technology that allows users to directly trade cryptocurrencies without a centralized intermediary. DEX has the characteristics of decentralization, transparency and privacy, which can improve asset security. At the same time, DEX transactions may face certain challenges in terms of speed and efficiency. When using DEX for transactions, users need to fully understand the platform characteristics, evaluate transaction risks, and ensure compliance with relevant laws and regulations.</p>
<h2 id="cex"><a class="header" href="#cex">CEX</a></h2>
<p>CEX (Centralized Exchange) is a cryptocurrency trading platform where users can buy and sell different cryptocurrencies. Unlike decentralized exchanges (DEX), CEX is operated by a centralized company or organization with user assets held in exchange accounts.</p>
<p>The characteristics of CEX transactions are:</p>
<ul>
<li>Centralization: CEX is operated by a centralized company or organization that holds user assets. This makes the trading process easier, but may also bring some trust risks and asset security issues.</li>
<li>Speed and efficiency: CEX usually adopts high-performance servers and technical architectures to provide higher transaction speed and efficiency. However, this may also make exchanges a target of attacks and increase security risks.</li>
<li>Trading pairs and liquidity: CEX usually provides multiple cryptocurrency trading pairs and higher trading liquidity. This allows users to easily buy and sell different cryptocurrencies to achieve their investment goals.</li>
</ul>
<p>CEX is a centralized cryptocurrency exchange that allows users to buy and sell different cryptocurrencies on an organized platform. CEX has advantages such as speed, efficiency, regulation and compliance, but may also face trust risks and asset security issues. When using CEX for transactions, users need to fully understand the platform characteristics, evaluate transaction risks and ensure compliance with relevant laws and regulations.</p>
<h2 id="airdrop"><a class="header" href="#airdrop">Airdrop</a></h2>
<p>Airdrop is a method of distributing cryptocurrency, typically used to promote a new digital currency or token. In an airdrop campaign, the project party distributes a certain amount of tokens for free to users who meet specific conditions, such as following social media, participating in community activities, or holding certain assets.</p>
<p>Airdrop is like a company giving out free samples to attract more attention and trial of their products. In the cryptocurrency market, airdrops can help project parties expand awareness, attract users, and increase market liquidity. However, it should be noted that investors participating in airdrops should carefully understand the project background and token value to avoid potential risks.</p>
<h2 id="cz"><a class="header" href="#cz">CZ</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Changpeng_Zhao">Changpeng Zhao</a>, also known as CZ, is a Chinese-Canadian entrepreneur and a well-known figure in the cryptocurrency industry. He is the founder of Binance, currently the largest cryptocurrency exchange in the world. He has worked for companies including the Tokyo Stock Exchange, Bloomberg L.P., Blockchain.info, and OKCoin.</p>
<p>CZ is the abbreviation of Changpeng Zhao. He is an ethnic Chinese Canadian entrepreneur and a well-known figure in the cryptocurrency field. He is the founder of Binance, currently the largest cryptocurrency exchange in the world. He has worked for companies including the Tokyo Stock Exchange, Bloomberg L.P., Blockchain.info, and OKCoin.</p>
<h2 id="sbf"><a class="header" href="#sbf">SBF</a></h2>
<p>SBF is the abbreviation of Sam Bankman-Fried. He is an American entrepreneur and a well-known figure in the cryptocurrency industry. He is the founder and CEO of Alameda Research, a company focused on quantitative trading and liquidity provision. He is also the co-founder and former CEO of FTX exchange, a platform that provides a variety of digital asset derivatives.</p>
<p>SBF was born on March 6, 1992. His parents were both professors at Stanford Law School. He studied physics at MIT from 2010 to 2014 and earned a degree. SBF's career began at Jane Street Capital, a proprietary trading firm that primarily trades international ETFs. In 2017, he founded Alameda Research, and in 2019 he founded FTX. With his innovative products and keen sense of market demand, he has made FTX the second largest cryptocurrency exchange in the world.</p>
<h2 id="ftx"><a class="header" href="#ftx">FTX</a></h2>
<p>FTX is a digital asset derivatives exchange founded in May 2019 by SBF. Users can trade Bitcoin, Ethereum and other cryptocurrencies as well as related derivatives on it. In July 2021, FTX completed a $900 million Series B financing with a valuation of $18 billion, the largest financing in the history of the cryptocurrency industry.</p>
<p>The reason for FTX's collapse was that it fell into a liquidity crisis, resulting in its inability to meet customer withdrawal demands. There were reports that FTX's affiliated company Alameda Research used most of its assets to collateralize FTX's self-issued FTT tokens, and these tokens fell sharply in the market, causing a break in the capital chain.</p>
<p>On November 11, 2022, FTX announced that it had filed for bankruptcy in the United States and suspended cryptocurrency withdrawals. SBF resigned as CEO but said he would continue to assist the company in an orderly transition. FTX's collapse triggered a panic in the cryptocurrency market and sharp price declines in major cryptocurrencies such as Bitcoin.</p>
<p>FTX was once a flourishing cryptocurrency exchange, but went bankrupt due to poor capital management and market volatility. This is a heavy blow to both the cryptocurrency industry and investors.</p>
<h2 id="og"><a class="header" href="#og">OG</a></h2>
<p>OG refers to Original Gangster. Originally, OG was a word from American hip hop culture to describe people with senior experience and status in a certain field, community or industry. OG means that this person has extensive knowledge, experience and influence in their field and is usually respected and admired by people around them. In the cryptocurrency and blockchain field, OG can also be used to describe some early participants, innovators and leaders.</p>
<p>OG usually accumulates a lot of experience and knowledge in their field. Due to OG's senior status and extensive experience in the industry, their views and suggestions usually have higher authority and are easily noticed and respected by people around them.</p>
<p>OG is a word used to describe people with senior experience and status in a certain field, community or industry. In the cryptocurrency and blockchain field, OG can refer to those early participants, innovators and leaders. With their extensive experience, influence and innovative spirit, they have made important contributions to the development of the entire industry.</p>
<h2 id="to-the-moon"><a class="header" href="#to-the-moon">To the moon</a></h2>
<p>&quot;To the Moon&quot; is a popular slang in the cryptocurrency and investment fields, meaning that the price of an asset (usually cryptocurrency) is expected to rise sharply. This phrase is often used on social media, forums and chat groups to express investors' optimistic expectations for future market performance.</p>
<p>The cryptocurrency market is a huge rocket launch site, with rockets representing various cryptocurrencies. When the market expects the price of a cryptocurrency to skyrocket, people will say the cryptocurrency is &quot;going to the Moon&quot;, as if the rocket is about to launch to the moon.</p>
<p>This phrase reflects investors' optimistic expectations for the future performance of an asset. They believe the asset price will rise sharply. &quot;To the Moon&quot; is usually popular on social media and online communities. People use this phrase to express their enthusiasm and confidence in an investment. &quot;To the Moon&quot; is largely influenced by market sentiment. When the market has a strong optimistic mood towards an asset, the frequency of using this phrase will increase.</p>
<h2 id="bull--bear"><a class="header" href="#bull--bear">Bull &amp; Bear</a></h2>
<p>A bull market is a financial term referring to a prolonged period of rising prices and optimism in the market. </p>
<p>For example, if the price of Bitcoin surges from $10,000 to $30,000 and maintains an upward momentum, this is a typical bull market. Investors would feel it is a great opportunity to buy in and continue holding assets for profit.</p>
<p>We can compare a bull market to a charging bull that powers upward, knocking down all obstacles in its way with no resistance to its rising force.</p>
<p>In contrast, a bear market describes the overall downward trend when asset prices plummet in value. If Bitcoin's price drops from $30,000 to $10,000, that is a bear market. </p>
<p>The crypto market also generally follows this cyclical boom-bust pattern. Identifying market trends and making the right decisions is key to success.</p>
<p>In a bull market, investors need to watch for risks, as a meteoric rise is often unsustainable. A bear market is not without opportunity either, sometimes allowing investors to buy quality assets cheaply for future gains. </p>
<p>In short, a bull market represents upward prosperity while a bear market signals downward corrections. Gauging and harnessing market rhythms is an important part of investing.</p>
<h2 id="fomo"><a class="header" href="#fomo">FOMO</a></h2>
<p>FOMO refers to Fear of Missing Out. It is a psychological phenomenon that people worry about missing an important event, opportunity or trend, resulting in a sense of urgency and anxiety. In the investment field, especially in the cryptocurrency market, FOMO is a common emotional reaction. When the market shows a strong upward trend, people may follow the trend blindly due to the fear of missing opportunities.</p>
<p>The cryptocurrency market is a lively party where everyone is dancing, cheering and enjoying the pleasure of the rising market. At this time, standing outside the party, you see everyone's joy and start to worry that you will miss this rare opportunity. So you decide to join in, even though you may not understand the risks of cryptocurrency investment.</p>
<ul>
<li>Emotionally driven: FOMO is an emotionally based reaction. When people see others succeed or enjoy something, it is easy to have the urge to join in.</li>
<li>Late realization: FOMO often occurs after the market or trend has been going on for some time. People start to consider joining only after seeing others make profits.</li>
<li>Blind following: Due to the psychological pressure caused by FOMO, people may follow the trend blindly without fully understanding the risks, leading to losses.</li>
<li>High risk: In the cryptocurrency market, FOMO may cause investors to buy at market peaks and panic sell when prices fall, resulting in losses.</li>
</ul>
<p>FOMO is a psychological phenomenon that refers to the fear of missing important events, opportunities or trends. In the investment field, especially in the cryptocurrency market, FOMO can lead to blind follow-up and high-risk investment behavior. To avoid FOMO, investors should remain calm, fully understand and analyse the market and investment targets, and follow their investment strategies and risk tolerance.</p>
<h2 id="fud"><a class="header" href="#fud">FUD</a></h2>
<p>FUD refers to Fear, Uncertainty and Doubt. It is a psychological phenomenon that people have negative emotions due to fear, uncertainty and doubt about the future in a certain field, especially in investment markets.</p>
<p>FUD is an emotionally based reaction. When facing fear, uncertainty and doubt about the future, people tend to feel anxious and worried. FUD is usually accompanied by the spread of negative news, which may come from media reports, online forums or social media and can easily trigger market panic. To some extent, FUD can become a self-fulfilling prophecy. The spread of panic and selling behavior of investors may lead to further price drops in the market. For experienced investors, FUD may also bring investment opportunities. During market panic, they may look for undervalued high-quality assets and take countercyclical operations.</p>
<p>In the cryptocurrency market, FUD can lead to market panic, investor selling and price drops. To avoid the influence of FUD, investors should remain rational, fully understand and analyze the market and investment targets, and make wise investment decisions.</p>
<h2 id="pow"><a class="header" href="#pow">PoW</a></h2>
<p>Proof of Work (PoW) is a consensus algorithm used in cryptocurrencies and blockchain networks. Its core idea is to require participants in the network to prove their work by solving complex mathematical problems. This approach ensures network security while incentivizing participation.</p>
<p>PoW is like a math competition where participants race to find a number that satisfies certain conditions. Combined with block data, this number goes through a specific computational process to produce a hash value starting with a certain number of zeros. This process is like cracking a code, as finding the right answer requires a lot of computational trial and error, but verifying the answer is very simple. </p>
<p>To help you better understand PoW, we can use mining as an analogy. In cryptocurrency networks like Bitcoin, mining is participants trying different numbers repeatedly to find a suitable solution to unlock new blocks. Once successfully unlocked, participants are rewarded with a certain amount of Bitcoin, like striking gold while mining.</p>
<p>However, PoW has some issues. First, the computational process consumes huge amounts of energy, impacting the environment. Second, as cryptocurrency prices rise, more and more people join mining, increasing the mining difficulty and making it hard for average users to participate. This may lead to network centralization, going against blockchain's decentralized ethos. </p>
<p>In summary, PoW is a consensus algorithm used in cryptocurrencies and blockchains. It ensures network security and incentives to some extent by making participants prove their work through solving hard problems. But PoW also has issues like energy consumption and centralization. To address these, researchers and developers have proposed other consensus models like Proof of Stake to reduce energy use and improve decentralization.</p>
<h2 id="pos"><a class="header" href="#pos">PoS</a></h2>
<p>Proof of Stake (PoS) is a consensus algorithm used in cryptocurrencies and blockchain networks. Unlike Proof of Work (PoW) which proves work through solving complex math problems, PoS selects block validators based on the quantity and age of cryptocurrencies held by participants. This design aims to reduce energy consumption, increase decentralization, and enhance network security.</p>
<p>To help you understand PoS, we can think of it as a staking savings program for cryptocurrencies. In a PoS network, you can &quot;stake&quot; or &quot;lock up&quot; your holdings at a specific address, a process called staking. The more crypto you stake, the higher chance you get randomly selected as a validator (miner). Validators are responsible for creating new blocks and verifying transactions, and receive rewards after completing these operations. </p>
<p>We can analogize PoS to a lottery drawing. Participants need to purchase tickets to join the draw, and more tickets purchased means a higher chance to win. In a PoS network, cryptocurrencies held and staked are like lottery tickets, increasing your odds of becoming a validator.</p>
<p>PoS has some advantages over PoW. Firstly, PoS reduces computational work, lowering energy consumption and environmental impact. Secondly, PoS encourages long-term holding of crypto which helps price stability. Moreover, PoS lowers the risk of centralization as validator selection does not rely on computing power, making it easier for average users to participate.</p>
<p>Of course, PoS also has some drawbacks like ensuring validator honesty and preventing stake concentration. Still, PoS is considered an effective blockchain consensus model, and many new cryptocurrencies and blockchain projects have adopted PoS algorithms, like Ethereum 2.0, Cardano, etc.</p>
<p>In summary, PoS is a consensus algorithm that selects validators based on crypto holdings. Compared to PoW, PoS has advantages like lower energy use and higher decentralization. It is seen as a promising blockchain consensus mechanism.</p>
<h2 id="subnet"><a class="header" href="#subnet">Subnet</a></h2>
<p>A subnet is a collection of replicas that run their own instance of a consensus algorithm to generate a subnet blockchain, and use cryptographic chain keys to interoperate with other subnets on the IC.</p>
<h2 id="actor-model"><a class="header" href="#actor-model">Actor model</a></h2>
<p>The actor model is a programming model for concurrency and distributed computing. In this model, an actor is a container encapsulating state, behavior, and address. For example, we can think of an actor as a person with their own name (address), personality (behavior), and possessions (state). </p>
<p>Actors can communicate with each other by sending messages. Just like people can make phone calls or send text messages to each other. When an actor receives a message, it will change its state or behavior based on the message content. For instance, when Mike receives a text from his mom saying &quot;Remember to buy groceries&quot;, he will change his state from &quot;playing games&quot; to &quot;going grocery shopping&quot;, and send back the results of buying groceries to his mom.</p>
<p>Each actor runs concurrently and independently. Message passing between actors is asynchronous. Just like how everyone can do their own thing at the same time, without needing to know what others are doing. This makes the actor model very suitable for writing highly concurrent and distributed programs.</p>
<p>The actor model achieves high performance and scalability through actor concurrency and distribution. It uses message passing for communication and collaboration between actors. This pattern is very common and important in today's internet systems.</p>
<h2 id="boundary-node-1"><a class="header" href="#boundary-node-1">Boundary node</a></h2>
<p>A Boundary Node is an entry point into the Internet Computer (IC), allowing users seamless access to the Canister smart contracts running on it. Boundary Nodes make up the globally distributed edge of the IC, and all access to Canister smart contracts must pass through one of these nodes. They provide a public endpoint for the IC, routing all incoming requests to the correct subnet, load balancing requests across replica nodes, and caching responses to enhance performance.</p>
<p>Boundary Nodes provide two ways to access the Canister smart contracts hosted on the IC: One is through the HTTP gateway using a standard browser, and the other is via API Boundary Nodes using API Canister calls. The HTTP gateway enables users to access Dapps hosted on the IC in the same way as any Web 2.0 service through a browser. To this end, the HTTP gateway translates all incoming HTTP requests into API Canister calls, then routes them to the correct subnet. API Boundary Nodes allow native IC applications to directly call Canister smart contracts. In this case, the Boundary Node simply routes the API Canister calls to the right subnet. Therefore, there is no need for trust between the users and the Boundary Nodes.</p>
<h2 id="canister-1"><a class="header" href="#canister-1">Canister</a></h2>
<p>Canister is a key concept in Internet Computer (IC) that provides the foundation for an open, private, censorship-resistant and collaborative internet. Canister is a compute unit (i.e. smart contract) designed for internet-scale applications and services running at web speed. They are driven by cycles. </p>
<p>A canister is an instance of a WebAssembly module implemented on the Internet Computer. A canister is not just a WebAssembly module, but an instance of a WebAssembly module. Canisters are based on the Actor programming model, where a canister is an actor. Canisters can contain various Dapps logic, not just limited to finance. It encapsulates all the programming logic, public entrypoint methods, interface descriptions of the messages it provides, and the state information of the Dapp it describes. Canisters are able to export their own APIs to be called by other canisters.</p>
<p>Canisters have unlimited scalability potential, they are the smart contracts of the Internet Computer. They have all the properties of traditional smart contracts, plus additional capabilities and memory to store software and user data, making them an evolution of smart contracts.</p>
<h2 id="candid-ui-1"><a class="header" href="#candid-ui-1">Candid UI</a></h2>
<p>Candid UI is a web interface based on the Candid interface description language that allows you to test canister functions in the browser. It presents service descriptions in the form of forms, enabling you to quickly view and test functions, and try different data types as input without writing any frontend code.</p>
<h2 id="controller-1"><a class="header" href="#controller-1">Controller</a></h2>
<p>A controller of a canister is a person, organization, or another canister that has administrative authority over that canister. The controller is identified by its principal. For example, a canister's controller can upgrade the WebAssembly code of the canister or remove the canister.</p>
<p>A controller is a Principal with permissions to install, upgrade, and delete Canisters.</p>
<p>In general, a Canister's Controller can be designated as a certain identity, or the Wallet Canister corresponding to a certain identity.</p>
<p>After dfx 0.9, the default &quot;identity&quot; is now the Canister's Controller, and the Wallet Canister is no longer the default Controller (equivalent to dfx specifying --no-wallet).</p>
<h2 id="cycle"><a class="header" href="#cycle">Cycle</a></h2>
<p>On the Internet Computer, a &quot;cycle&quot; is a unit of measurement for processing, memory, storage, and network bandwidth consumption. Each &quot;canister&quot; has a &quot;cycles account&quot;, and the resources consumed by the canister are credited to this account. The Internet Computer's utility token, ICP, can be converted into &quot;cycles&quot; and transferred to a canister. &quot;Cycles&quot; can also be transferred between canisters by attaching them to a message between canisters.</p>
<p>ICP can be converted according to the current ICP price in SDR, based on an agreement that one trillion &quot;cycles&quot; corresponds to one SDR.</p>
<h2 id="motoko-1"><a class="header" href="#motoko-1">Motoko</a></h2>
<p>Motoko is a new, modern, type-safe programming language designed specifically for developers wanting to build the next generation of distributed applications and run them on the Internet Computer blockchain network. Motoko is designed to support the unique capabilities of the Internet Computer, offering a familiar and powerful programming environment. As a new language, Motoko continues to evolve, supporting new features and other improvements. The Motoko compiler, documentation, and other tools are all open source, and are released under the Apache 2.0 license.</p>
<p>Motoko has native support for Canister smart contracts, with Canisters represented as Motoko Actors. An Actor is an autonomous object that completely encapsulates its state and communicates with other Actors solely through asynchronous messages. For example, the following code defines a stateful Counter Actor:</p>
<pre><code class="language-motoko">actor Counter {
    var value = 0;
    public func inc () : async Nat {
        value += 1;
        return value;
    };
}
</code></pre>
<p>Its sole public function inc() can be called by this Actor and other Actors to update and read the current state of its private field value.</p>
<p>Motoko has the following characteristics:</p>
<ul>
<li>
<p><strong>Accessibility</strong>: Motoko is a modern language designed to be convenient for programmers familiar with JavaScript and other popular languages. It supports modern programming habits, including special programming abstractions for distributed applications (Dapps).</p>
</li>
<li>
<p><strong>Asynchronous Messaging and Type-Safe Execution</strong>: Each Dapp is made up of one or more Actors that communicate solely through asynchronous message passing. The state of an Actor is isolated from all other Actors, supporting distribution. There is no way to share state between multiple Actors. Motoko's Actor-based programming abstraction allows human-readable message passing patterns and enforces certain rules and avoidance of common errors for each network interaction. Specifically, Motoko programs are type-safe, as Motoko includes a practical, modern type system that checks each program before execution. The Motoko type system statically checks each Motoko program will execute safely on all possible inputs, without any dynamic type errors. Therefore, a whole category of common programming pitfalls common in other languages, and especially in Web programming languages, are excluded. These include null reference errors, mismatched argument or result types, missing field errors, etc.</p>
</li>
<li>
<p><strong>Direct Style Sequential Encoding</strong>: On the IC, Canisters can communicate with other Canisters by sending asynchronous messages. Asynchronous programming is hard, so Motoko allows you to write asynchronous code in a simpler, sequential style. Asynchronous messages are function calls that return future values, and the await construct allows you to suspend execution until the future is complete. This simple feature avoids the &quot;callback hell&quot; of explicit asynchronous programming in other languages.</p>
</li>
<li>
<p><strong>Modern Type System</strong>: Motoko is designed to be intuitive to people familiar with JavaScript and other popular languages, but offers modern features such as sound structural typing, generics, variant types, and static checking of pattern matching.</p>
</li>
<li>
<p><strong>Auto-Generated IDL Files</strong>: A Motoko actor always presents its clients with a suite of named functions with argument and (future) result types as a typed interface.</p>
</li>
</ul>
<h2 id="query-call"><a class="header" href="#query-call">Query call</a></h2>
<p>Users can query the current state of a canister or call a function that does not change the canister's state via a Query call. Responses to Query calls are very fast. Users can send Query calls to any replica within a subnet, with the result not going through consensus. </p>
<p>That is to say, there is an inherent tradeoff between security and performance: replies from a single replica are fast but may not be trustworthy or accurate. Query calls are not allowed to change the state of a canister to persist, so they are essentially read-only operations.</p>
<h2 id="update-call"><a class="header" href="#update-call">Update call</a></h2>
<p>Initiating an Update call can change a canister's state or call a function that changes the canister's state. Update calls are asynchronous and take some time to get a reply. They must be sent to all the replicas that hold the canister within a subnet, with the result going through consensus.</p>
<p>That is to say, there is an inherent tradeoff between security and performance: replies from all replicas are slow but trustworthy and accurate. Update calls allow changing the state of a canister to persist, so they are essentially read-write operations.</p>
<h2 id="replica"><a class="header" href="#replica">Replica</a></h2>
<p>In IC, a replica refers to the client/replica software running on IC nodes. A &quot;replica&quot; is a collection of protocol components that are prerequisites for a node to join a subnet.</p>
<h2 id="wallet-canister"><a class="header" href="#wallet-canister">Wallet Canister</a></h2>
<p>A Wallet Canister is a dedicated smart contract (Canister) that allows storing and managing Cycles. A Wallet Canister belongs to a developer identity. Cycles are used to pay for Gas on the IC. </p>
<p>When a developer needs to deploy a Canister, it is actually the developer's controlled Wallet Canister that allocates Cycles and creates the Canister.</p>
<h2 id="service-worker"><a class="header" href="#service-worker">Service Worker</a></h2>
<p>When a browser requests resources from the Internet Computer (IC), these resources may be stored on a special neuron called an API canister. To make these resources available, a service worker is needed to implement the HTTP gateway protocol, converting the browser's requests into API canister calls, and verifying the authenticity of these resources. Therefore, this service worker will act as an intermediary, connecting the browser and the API canister, thus enabling the browser to access resources stored on the IC.</p>
<p>Its role is to implement the HTTP gateway protocol, converting the browser's requests for static resources into API canister calls for communication with the IC, and verifying resource authentication. In simple terms, it can help the browser request static resources and convert them into API canister calls for communication with the IC (Internet Computer), and also ensure that these resources are trustworthy.</p>
<p>The HTTP gateway protocol refers to the communication protocol between the browser and the service worker, the API canister call refers to the way the service worker sends requests to the IC, and asset authentication refers to ensuring the authenticity and security of assets during the request process.</p>
<h2 id="node"><a class="header" href="#node">Node</a></h2>
<p>A Node is a physical machine node that hosts the IC.</p>
<h2 id="webassembly-wasm"><a class="header" href="#webassembly-wasm">WebAssembly (Wasm)</a></h2>
<p>WebAssembly (Wasm) is a binary instruction format that provides a virtual machine abstraction layer with features like security, portability, efficiency, lightweight, etc. It can easily achieve millisecond cold start time and extremely low resource consumption.</p>
<p>WebAssembly was first applied in browsers, and is now gradually expanding to the backend. It can compile code from languages like C/C++, Rust, Motoko into WebAssembly bytecode and run in a sandboxed environment. </p>
<p>Currently, mainstream public blockchains support WebAssembly. IC is a typical WebAssembly-enabled blockchain where DApps can be written in Motoko or Rust and deployed on IC. </p>
<p>Apart from IC, blockchains like Dot and Near also support WebAssembly.</p>
<h2 id="ledger"><a class="header" href="#ledger">Ledger</a></h2>
<p>IC records all transactions involving ICP tokens in a dedicated governance container smart contract called the Ledger canister. </p>
<p>The Ledger canister implements a smart contract that maintains accounts and balances, and keeps a history of transactions that affect accounts and balances.</p>
<p>It provides the following capabilities:</p>
<ul>
<li>
<p>Minting ICP tokens into accounts</p>
</li>
<li>
<p>Transferring ICP tokens from one account to another </p>
</li>
<li>
<p>Burning ICP tokens to eliminate their existence</p>
</li>
</ul>
<p>The Ledger canister must be owned by an identity.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="contributors"><a class="header" href="#contributors">Contributors:</a></h2>
<p><a href="https://github.com/NeutronStarPRO">NeutronStarPRO</a>, <a href="https://github.com/RyanLee0396">WoW</a>, <a href="https://github.com/Tuostarfish">tuo</a>, <a href="https://github.com/xiaoyuanxun">xiaoyuanxun</a>, <a href="https://github.com/0xkookoo">0xkookoo</a> and you. </p>
<p>Yes, you! I'm talking to you! The next one is you! ü´µ <a href="https://github.com/NeutronStarDAO">Come and join us now!</a></p>
<h2 id="acknowledgements"><a class="header" href="#acknowledgements">Acknowledgements</a></h2>
<p>Thanks to Dfinty official, ICPL, DoraHacks, TinTinLand community, some early videos and materials are referenced from the WorkShops held by these communities.</p>
<p>Special thanks to tinywateer, Neeboo, Ninegua, Ben Ji Zhai, Elie, Peter, wuhu, Anna Lai, CoCo, LastMelody, and Bei De for their support and help. </p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="references"><a class="header" href="#references">ReferencesÔºö</a></h2>
<p>B-money https://en.bitcoin.it/wiki/B-money</p>
<p>History of Blockchain Part 3: Wei Dai (1998) https://medium.com/the-capital/history-of-blockchain-part-3-wei-dai-1998-1195ab5a4e08</p>
<p>https://www.metzdowd.com/pipermail/cryptography</p>
<p>B-Money, https://zhuanlan.zhihu.com/p/159129624</p>
<p>Satoshi Nakamoto, Bitcoin P2P E-cash Paper (Oct. 31Ôºå 2008) http://www.metzdowd.com/pipermail/cryptography/2008-October/014810.html</p>
<p>James A. Donald, Bitcoin P2P E-cash Paper(Nov. 2Ôºå 2008) http://www.metzdowd.com/pipermail/cryptography/2008-November/014814.html</p>
<p>Ray Dillinger, Bitcoin P2P E-cash Paper(Nov. 6Ôºå 2008) http://www.metzdowd.com/pipermail/cryptography/2008-November/014822.html</p>
<p>https://en.wikipedia.org/wiki/Bitcoin#Creation</p>
<p>Blockchain Democracy: Technogy, Law and the Rule of the Crowd</p>
<p>The Sovereign Individual</p>
<p>https://jessewalden.com</p>
<p>https://chuan.us/archives/322</p>
<p>https://chuan.us/archives/293</p>
<p>https://twitter.com/dominic_w</p>
<p>https://icpleague.com/thread/3</p>
<p>https://eprint.iacr.org/2021/632</p>
<p>https://eprint.iacr.org/2021/339</p>
<p>https://eprint.iacr.org/2016/199.pdf</p>
<p>https://learnblockchain.cn/article/1806</p>
<p>https://zhuanlan.zhihu.com/p/22228902</p>
<p>https://zhuanlan.zhihu.com/p/23243289</p>
<p>https://zhuanlan.zhihu.com/p/353784975</p>
<p>https://zhuanlan.zhihu.com/p/142667401</p>
<p>https://internetcomputer.org/whitepaper.pdf</p>
<p>https://mmapped.blog/posts/08-ic-xnet.html</p>
<p>https://wiki.internetcomputer.org/wiki/NNS_Canisters</p>
<p>https://wiki.internetcomputer.org/wiki/Chain-key_Bitcoin</p>
<p>https://wiki.internetcomputer.org/wiki/Replica_Upgrades</p>
<p>https://www.youtube.com/watch?v=vUcDRFC09J0&amp;t=1s</p>
<p>https://internetcomputer.org/how-it-works/peer-to-peer-p2p</p>
<p>https://internetcomputer.org/how-it-works#Core-IC-Protocol</p>
<p>https://wiki.internetcomputer.org/wiki/Internet_Computer_wiki</p>
<p>https://wiki.internetcomputer.org/wiki/Exchange_rate_canister</p>
<p>https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html</p>
<p>https://www.ruanyifeng.com/blog/2023/03/weekly-issue-246.html</p>
<p>https://internetcomputer.org/docs/current/developer-docs/ic-overview</p>
<p>https://medium.com/dfinity/why-bitcoin-needs-smart-contracts-5191fbec294a</p>
<p>https://medium.com/dfinity/disentangling-dfinity-and-ethereum-dfa2151ad419</p>
<p>https://internetcomputer.org/docs/current/developer-docs/integrations/vetkeys</p>
<p>https://medium.com/@dominic-w/helo-world-im-back-blogging-ae6ceacbc1d7</p>
<p>https://wiki.internetcomputer.org/wiki/Know-Your-Transaction_(KYT)_Canister</p>
<p>https://medium.com/dfinity/the-dfinity-blockchain-nervous-system-a5dd1783288e</p>
<p>https://medium.com/dfinity/chain-key-bitcoin-a-decentralized-bitcoin-twin-ceb8f4ddf95e</p>
<p>https://wiki.internetcomputer.org/wiki/Extend_Bitcoin,_Ethereum_and_other_blockchains</p>
<p>https://medium.com/dfinity/dfinity-in-a-nutshell-a-non-technical-introduction-ec45ec5967c1</p>
<p>https://medium.com/dfinity/the-decentralized-cloud-vision-of-the-dfinity-blockchain-f68449c49be2</p>
<p>https://medium.com/dfinity/secure-scalability-the-internet-computers-peer-to-peer-layer-6662d451f2cc</p>
<p>https://medium.com/dfinity/applied-crypto-one-public-key-for-the-internet-computer-ni-dkg-4af800db869d</p>
<p>https://medium.com/dfinity/chain-key-technology-one-public-key-for-the-internet-computer-6a3644901e28</p>
<p>https://medium.com/dfinity/software-canisters-an-evolution-of-smart-contracts-internet-computer-f1f92f1bfffb</p>
<p>https://mirror.xyz/0xFd007bb46C47D8600C139E34Df9DfceC86F0B319/47TgZKY1hqmpEESvtrbrzP0nNTtri5zE6fJxU0jkKjg</p>
<p>https://mirror.xyz/0xFd007bb46C47D8600C139E34Df9DfceC86F0B319/epZ0vLkKaB-qkt9nBbgfs-bmJ6d8O-fax4HavHkWPI8</p>
<p>https://medium.com/dfinity/motoko-a-programming-language-designed-for-the-internet-computer-is-now-open-source-8d85da4db735</p>
<p>https://medium.com/dfinity/understanding-the-internet-computers-network-nervous-system-neurons-and-icp-utility-tokens-730dab65cae8</p>
<br>
<br>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="assets/custom.js"></script>
        <script type="text/javascript" src="assets/bigPicture.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>